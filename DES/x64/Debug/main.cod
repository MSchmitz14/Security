; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23918.0 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?keys@@3PA_KA					; keys
_BSS	SEGMENT
?keys@@3PA_KA DQ 011H DUP (?)				; keys
_BSS	ENDS
PUBLIC	?__empty_global_delete@@YAXPEAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPEAX_K@Z		; __empty_global_delete
PUBLIC	??0exception@std@@QEAA@AEBV01@@Z		; std::exception::exception
PUBLIC	??1exception@std@@UEAA@XZ			; std::exception::~exception
PUBLIC	?what@exception@std@@UEBAPEBDXZ			; std::exception::what
PUBLIC	??_Gexception@std@@UEAAPEAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	??1_Container_base12@std@@QEAA@XZ		; std::_Container_base12::~_Container_base12
PUBLIC	?_Adopt@_Iterator_base12@std@@QEAAXPEBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt
PUBLIC	?_Orphan_me@_Iterator_base12@std@@QEAAXXZ	; std::_Iterator_base12::_Orphan_me
PUBLIC	?_Allocate@std@@YAPEAX_K0_N@Z			; std::_Allocate
PUBLIC	?_Deallocate@std@@YAXPEAX_K1@Z			; std::_Deallocate
PUBLIC	??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAA@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >
PUBLIC	?_Free_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAXXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Free_proxy
PUBLIC	??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	??1bad_cast@std@@UEAA@XZ			; std::bad_cast::~bad_cast
PUBLIC	??0bad_cast@std@@QEAA@AEBV01@@Z			; std::bad_cast::bad_cast
PUBLIC	??_Gbad_cast@std@@UEAAPEAXI@Z			; std::bad_cast::`scalar deleting destructor'
PUBLIC	??1locale@std@@QEAA@XZ				; std::locale::~locale
PUBLIC	?errorWithMessage@@YAXPEAD@Z			; errorWithMessage
PUBLIC	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
PUBLIC	??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
PUBLIC	?init@@YAXHQEAPEAD@Z				; init
PUBLIC	?convertToChar@@YAX_KQEAD@Z			; convertToChar
PUBLIC	?rotateBits@@YA_K_KH@Z				; rotateBits
PUBLIC	?compressPermuteKey@@YA_K_K@Z			; compressPermuteKey
PUBLIC	?permutation1@@YA_K_K@Z				; permutation1
PUBLIC	?finalPermutation@@YA_K_K@Z			; finalPermutation
PUBLIC	?runIt@@YA_K_KH@Z				; runIt
PUBLIC	main
PUBLIC	??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_fstream<char,std::char_traits<char> >::basic_fstream<char,std::char_traits<char> >
PUBLIC	??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UEAA@XZ ; std::basic_fstream<char,std::char_traits<char> >::~basic_fstream<char,std::char_traits<char> >
PUBLIC	??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
PUBLIC	?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::open
PUBLIC	?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
PUBLIC	?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Lock
PUBLIC	?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Unlock
PUBLIC	?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::overflow
PUBLIC	?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::pbackfail
PUBLIC	?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ ; std::basic_filebuf<char,std::char_traits<char> >::underflow
PUBLIC	?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ ; std::basic_filebuf<char,std::char_traits<char> >::uflow
PUBLIC	?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::seekoff
PUBLIC	?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z ; std::basic_filebuf<char,std::char_traits<char> >::seekpos
PUBLIC	?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z ; std::basic_filebuf<char,std::char_traits<char> >::setbuf
PUBLIC	?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ ; std::basic_filebuf<char,std::char_traits<char> >::sync
PUBLIC	?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAXAEBVlocale@2@@Z ; std::basic_filebuf<char,std::char_traits<char> >::imbue
PUBLIC	?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite
PUBLIC	?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Reset_back
PUBLIC	?_Set_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Set_back
PUBLIC	??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z ; std::basic_filebuf<char,std::char_traits<char> >::`scalar deleting destructor'
PUBLIC	??_G?$basic_fstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z ; std::basic_fstream<char,std::char_traits<char> >::`scalar deleting destructor'
PUBLIC	??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXXZ ; std::basic_fstream<char,std::char_traits<char> >::`vbase destructor'
PUBLIC	??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAAEBDXZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator*
PUBLIC	??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z ; std::use_facet<std::codecvt<char,char,_Mbstatet> >
PUBLIC	??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@XZ ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::~_String_iterator<std::_String_val<std::_Simple_types<char> > >
PUBLIC	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??_E?$basic_fstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@EAAPEAXI@Z ; std::basic_fstream<char,std::char_traits<char> >::`vector deleting destructor'
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception?$AA@	; `string'
PUBLIC	??_C@_1JA@IJKHNLMB@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; `string'
PUBLIC	??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@ ; `string'
PUBLIC	??_C@_1DG@HGDKEBPG@?$AA?$CC?$AA_?$AAP?$AAt?$AAr?$AA_?$AAc?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn?$AAe?$AAr?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?$CC?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs?$AA?$AA@	; `string'
PUBLIC	??_C@_1JA@HEEMAOGC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; `string'
PUBLIC	??_C@_1BO@NKFMJPA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CC@GKJLLHIM@?$AA?$CC?$AA_?$AAP?$AAt?$AAr?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?$CC?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	??_C@_1EI@MLOBABC@?$AA?$CC?$AA_?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA?$CI?$AAs?$AAi?$AAz?$AAe?$AA_?$AAt?$AA?$CJ?$AA?$CI?$AA?9?$AA1?$AA?$CJ?$AA?5?$AA?1?$AA?5?$AA_?$AAS?$AAz?$AA?$CC?$AA?5?$AA?$CG@ ; `string'
PUBLIC	??_C@_1CC@LOFJFFDB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1HE@CDMBFOKC@?$AA?$CC?$AA?$CI?$AA_?$AAP?$AAt?$AAr?$AA_?$AAu?$AAs?$AAe?$AAr?$AA?5?$AA?$CG?$AA?5?$AA?$CI?$AA_?$AAB?$AAI?$AAG?$AA_?$AAA?$AAL?$AAL?$AAO?$AAC?$AAA?$AAT?$AAI?$AAO?$AAN?$AA_?$AAA@ ; `string'
PUBLIC	??_C@_1JO@EKLKIEHP@?$AA?$CC?$AAr?$AAe?$AAi?$AAn?$AAt?$AAe?$AAr?$AAp?$AAr?$AAe?$AAt?$AA_?$AAc?$AAa?$AAs?$AAt?$AA?$DM?$AAu?$AAi?$AAn?$AAt?$AAp?$AAt?$AAr?$AA_?$AAt?$AA?5?$AA?$CK?$AA?$DO?$AA?$CI?$AA_@ ; `string'
PUBLIC	??_C@_1EE@PDHAHDDC@?$AA?$CC?$AA_?$AAP?$AAt?$AAr?$AA_?$AAc?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn?$AAe?$AAr?$AA?5?$AA?$DM?$AA?5?$AA_?$AAP?$AAt?$AAr?$AA_?$AAu?$AAs?$AAe?$AAr?$AA?$CC?$AA?5?$AA?$CG?$AA?$CG?$AA?5@ ; `string'
PUBLIC	??_C@_1HA@NAPGMHAO@?$AA?$CC?$AA2?$AA?5?$AA?$CK?$AA?5?$AAs?$AAi?$AAz?$AAe?$AAo?$AAf?$AA?$CI?$AAv?$AAo?$AAi?$AAd?$AA?5?$AA?$CK?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA_?$AAP?$AAt?$AAr?$AA_?$AAu?$AAs?$AAe?$AAr@ ; `string'
PUBLIC	??_C@_1GI@DHJGPFNI@?$AA?$CC?$AA_?$AAP?$AAt?$AAr?$AA_?$AAu?$AAs?$AAe?$AAr?$AA?5?$AA?9?$AA?5?$AA_?$AAP?$AAt?$AAr?$AA_?$AAc?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn?$AAe?$AAr?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA_@ ; `string'
PUBLIC	??_7bad_cast@std@@6B@				; std::bad_cast::`vftable'
PUBLIC	??_C@_08EPJLHIJG@bad?5cast?$AA@			; `string'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	_CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
PUBLIC	??_C@_07BCFMPKIE@ERROR?4?5?$AA@			; `string'
PUBLIC	??_C@_0BP@IOHJEBAL@Incorrect?5number?5of?5arguments?4?$AA@ ; `string'
PUBLIC	??_C@_02DBLKFNPN@?9d?$AA@			; `string'
PUBLIC	??_C@_02KEDOHJFP@?9D?$AA@			; `string'
PUBLIC	??_C@_02CIKBGMLM@?9e?$AA@			; `string'
PUBLIC	??_C@_02LNCFEIBO@?9E?$AA@			; `string'
PUBLIC	??_C@_0BC@LDCMBOAO@Incorrect?5action?4?$AA@	; `string'
PUBLIC	??_C@_08DPLLBGKL@Bad?5key?4?$AA@		; `string'
PUBLIC	??_C@_0P@KNIHKEND@Incorrect?5Mode?$AA@		; `string'
PUBLIC	??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_filebuf<char,std::char_traits<char> >::`vftable'
PUBLIC	??_7?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_fstream<char,std::char_traits<char> >::`vftable'
PUBLIC	??_8?$basic_fstream@DU?$char_traits@D@std@@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@ ; std::basic_fstream<char,std::char_traits<char> >::`vbtable'
PUBLIC	??_8?$basic_fstream@DU?$char_traits@D@std@@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@ ; std::basic_fstream<char,std::char_traits<char> >::`vbtable'
PUBLIC	??_C@_0BF@NMCADOHI@File?5does?5not?5exist?4?$AA@ ; `string'
PUBLIC	??_C@_0BI@DPNHLANH@Not?5a?5valid?5char?5value?4?$AA@ ; `string'
PUBLIC	??_C@_0BO@EHAFNCKF@This?5is?5a?5weak?5key?4?5Try?5again?$AA@ ; `string'
PUBLIC	??_C@_01LKDEMHDF@s?$AA@				; `string'
PUBLIC	??_C@_0N@LGHPBDLJ@Total?5time?3?5?$AA@		; `string'
PUBLIC	??_C@_1IO@IPMLDGDI@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; `string'
PUBLIC	?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit
PUBLIC	??_C@_1EG@CNCHLAOB@?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb@ ; `string'
PUBLIC	??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ ; `string'
PUBLIC	??_C@_1MG@GDGHDIKC@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; `string'
PUBLIC	??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	_TI2?AVbad_cast@std@@
PUBLIC	_CTA2?AVbad_cast@std@@
PUBLIC	??_R0?AVbad_cast@std@@@8			; std::bad_cast `RTTI Type Descriptor'
PUBLIC	_CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QEAA@AEBV01@@Z24
PUBLIC	?_Psave@?$_Facetptr@V?$codecvt@DDU_Mbstatet@@@std@@@std@@2PEBVfacet@locale@2@EB ; std::_Facetptr<std::codecvt<char,char,_Mbstatet> >::_Psave
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_filebuf<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_streambuf<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R4?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_fstream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_fstream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_fstream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_fstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_fstream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_fstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_fstream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_fstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_fstream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@?$basic_iostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$basic_iostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_iostream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_iostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_iostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_istream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,0,4,80)'
PUBLIC	??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ios<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8	; std::basic_ios<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8	; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@ios_base@std@@8			; std::ios_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AVios_base@std@@@8			; std::ios_base `RTTI Type Descriptor'
PUBLIC	??_R3ios_base@std@@8				; std::ios_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2ios_base@std@@8				; std::ios_base::`RTTI Base Class Array'
PUBLIC	??_R17?0A@EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,-1,0,64)'
PUBLIC	??_R0?AV?$_Iosb@H@std@@@8			; std::_Iosb<int> `RTTI Type Descriptor'
PUBLIC	??_R3?$_Iosb@H@std@@8				; std::_Iosb<int>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$_Iosb@H@std@@8				; std::_Iosb<int>::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@A@3EA@ios_base@std@@8			; std::ios_base::`RTTI Base Class Descriptor at (0,0,4,64)'
PUBLIC	??_R17A@3EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,0,4,64)'
PUBLIC	??_R1BA@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (16,-1,0,64)'
PUBLIC	??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ostream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4bad_cast@std@@6B@				; std::bad_cast::`RTTI Complete Object Locator'
PUBLIC	??_R3bad_cast@std@@8				; std::bad_cast::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_cast@std@@8				; std::bad_cast::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@bad_cast@std@@8			; std::bad_cast::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@408f400000000000
EXTRN	??2@YAPEAX_K@Z:PROC				; operator new
EXTRN	??3@YAXPEAX@Z:PROC				; operator delete
EXTRN	??3@YAXPEAX_K@Z:PROC				; operator delete
EXTRN	__std_terminate:PROC
EXTRN	__imp__invalid_parameter:PROC
EXTRN	__imp__invalid_parameter_noinfo:PROC
EXTRN	__imp__errno:PROC
EXTRN	__imp_memmove:PROC
EXTRN	__imp_Sleep:PROC
EXTRN	__imp_exit:PROC
EXTRN	__imp_srand:PROC
EXTRN	__imp_rand:PROC
EXTRN	__imp_??0_Lockit@std@@QEAA@H@Z:PROC
EXTRN	__imp_??1_Lockit@std@@QEAA@XZ:PROC
EXTRN	__imp__get_stream_buffer_pointers:PROC
EXTRN	__imp_fclose:PROC
EXTRN	__imp_fflush:PROC
EXTRN	__imp_fgetc:PROC
EXTRN	__imp_fgetpos:PROC
EXTRN	__imp_fputc:PROC
EXTRN	__imp_fsetpos:PROC
EXTRN	__imp__fseeki64:PROC
EXTRN	__imp_fwrite:PROC
EXTRN	__imp_setvbuf:PROC
EXTRN	__imp_ungetc:PROC
EXTRN	__imp__lock_file:PROC
EXTRN	__imp__unlock_file:PROC
EXTRN	__imp_?uncaught_exception@std@@YA_NXZ:PROC
EXTRN	__imp___std_exception_copy:PROC
EXTRN	__imp___std_exception_destroy:PROC
EXTRN	??_Eexception@std@@UEAAPEAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	__imp__CrtDbgReportW:PROC
EXTRN	__imp_?_Debug_message@std@@YAXPEB_W0I@Z:PROC
EXTRN	__imp_?_Xbad_alloc@std@@YAXXZ:PROC
EXTRN	__imp_?_Xlength_error@std@@YAXPEBD@Z:PROC
EXTRN	__imp_?_Xout_of_range@std@@YAXPEBD@Z:PROC
EXTRN	??_Ebad_cast@std@@UEAAPEAXI@Z:PROC		; std::bad_cast::`vector deleting destructor'
EXTRN	?_Facet_Register@std@@YAXPEAV_Facet_base@1@@Z:PROC ; std::_Facet_Register
EXTRN	__imp_??Bid@locale@std@@QEAA_KXZ:PROC
EXTRN	__imp_?_Getgloballocale@locale@std@@CAPEAV_Locimp@12@XZ:PROC
EXTRN	__imp_?always_noconv@codecvt_base@std@@QEBA_NXZ:PROC
EXTRN	__imp_?in@?$codecvt@DDU_Mbstatet@@@std@@QEBAHAEAU_Mbstatet@@PEBD1AEAPEBDPEAD3AEAPEAD@Z:PROC
EXTRN	__imp_?out@?$codecvt@DDU_Mbstatet@@@std@@QEBAHAEAU_Mbstatet@@PEBD1AEAPEBDPEAD3AEAPEAD@Z:PROC
EXTRN	__imp_?unshift@?$codecvt@DDU_Mbstatet@@@std@@QEBAHAEAU_Mbstatet@@PEAD1AEAPEAD@Z:PROC
EXTRN	__imp_?_Getcat@?$codecvt@DDU_Mbstatet@@@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z:PROC
EXTRN	__imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAA@XZ:PROC
EXTRN	__imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ:PROC
EXTRN	__imp_?getloc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEBA?AVlocale@2@XZ:PROC
EXTRN	__imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z:PROC
EXTRN	__imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAA_JPEBD_J@Z:PROC
EXTRN	__imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXXZ:PROC
EXTRN	__imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ:PROC
EXTRN	__imp_?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z:PROC
EXTRN	__imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z:PROC
EXTRN	__imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADD@Z:PROC
EXTRN	__imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IEAA@XZ:PROC
EXTRN	__imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@N@Z:PROC
EXTRN	__imp_?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@D@Z:PROC
EXTRN	__imp_?write@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@PEBD_J@Z:PROC
EXTRN	__imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ:PROC
EXTRN	__imp_?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@PEAD_J@Z:PROC
EXTRN	__imp_?seekg@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@_JH@Z:PROC
EXTRN	__imp_?tellg@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA?AV?$fpos@U_Mbstatet@@@2@XZ:PROC
EXTRN	__imp_??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QEAA@PEAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z:PROC
EXTRN	__imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UEAA@XZ:PROC
EXTRN	__imp_?_Fiopen@std@@YAPEAU_iobuf@@PEBDHH@Z:PROC
EXTRN	__imp_clock:PROC
EXTRN	__imp__time64:PROC
EXTRN	??_E?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z:PROC ; std::basic_filebuf<char,std::char_traits<char> >::`vector deleting destructor'
EXTRN	??_E?$basic_fstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z:PROC ; std::basic_fstream<char,std::char_traits<char> >::`vector deleting destructor'
EXTRN	?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JXZ:PROC ; std::basic_streambuf<char,std::char_traits<char> >::showmanyc
EXTRN	?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z:PROC ; std::basic_streambuf<char,std::char_traits<char> >::xsgetn
EXTRN	?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JPEBD_J@Z:PROC ; std::basic_streambuf<char,std::char_traits<char> >::xsputn
EXTRN	_CxxThrowException:PROC
EXTRN	__CxxFrameHandler3:PROC
EXTRN	memcpy:PROC
EXTRN	memset:PROC
EXTRN	__imp_?_BADOFF@std@@3_JB:QWORD
EXTRN	??_7type_info@@6B@:BYTE				; type_info::`vftable'
EXTRN	__imp_?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A:QWORD
EXTRN	__imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A:BYTE
EXTRN	__ImageBase:BYTE
EXTRN	_fltused:DWORD
;	COMDAT ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A
_BSS	SEGMENT
?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A DQ 01H DUP (?) ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit
_BSS	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$codecvt@DDU_Mbstatet@@@std@@@std@@2PEBVfacet@locale@2@EB
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$codecvt@DDU_Mbstatet@@@std@@@std@@2PEBVfacet@locale@2@EB DQ 01H DUP (?) ; std::_Facetptr<std::codecvt<char,char,_Mbstatet> >::_Psave
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$memcpy_s DD imagerel memcpy_s
	DD	imagerel memcpy_s+171
	DD	imagerel $unwind$memcpy_s
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0exception@std@@QEAA@AEBV01@@Z DD imagerel $LN4
	DD	imagerel $LN4+54
	DD	imagerel $unwind$??0exception@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gexception@std@@UEAAPEAXI@Z DD imagerel $LN8
	DD	imagerel $LN8+67
	DD	imagerel $unwind$??_Gexception@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?copy@?$char_traits@D@std@@SAPEADPEADPEBD_K@Z DD imagerel $LN7
	DD	imagerel $LN7+28
	DD	imagerel $unwind$?copy@?$char_traits@D@std@@SAPEADPEADPEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?assign@?$char_traits@D@std@@SAPEADPEAD_KD@Z DD imagerel $LN4
	DD	imagerel $LN4+33
	DD	imagerel $unwind$?assign@?$char_traits@D@std@@SAPEADPEAD_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1_Container_base12@std@@QEAA@XZ DD imagerel $LN13
	DD	imagerel $LN13+113
	DD	imagerel $unwind$??1_Container_base12@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Orphan_all@_Container_base12@std@@QEAAXXZ DD imagerel $LN13
	DD	imagerel $LN13+96
	DD	imagerel $unwind$?_Orphan_all@_Container_base12@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1_Iterator_base12@std@@QEAA@XZ DD imagerel $LN3
	DD	imagerel $LN3+62
	DD	imagerel $unwind$??1_Iterator_base12@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Adopt@_Iterator_base12@std@@QEAAXPEBU_Container_base12@2@@Z DD imagerel $LN9
	DD	imagerel $LN9+126
	DD	imagerel $unwind$?_Adopt@_Iterator_base12@std@@QEAAXPEBU_Container_base12@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Orphan_me@_Iterator_base12@std@@QEAAXXZ DD imagerel $LN13
	DD	imagerel $LN13+108
	DD	imagerel $unwind$?_Orphan_me@_Iterator_base12@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Allocate@std@@YAPEAX_K0_N@Z DD imagerel $LN17
	DD	imagerel $LN17+44
	DD	imagerel $unwind$?_Allocate@std@@YAPEAX_K0_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Allocate@std@@YAPEAX_K0_N@Z DD imagerel $LN17+44
	DD	imagerel $LN17+247
	DD	imagerel $chain$1$?_Allocate@std@@YAPEAX_K0_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?_Allocate@std@@YAPEAX_K0_N@Z DD imagerel $LN17+247
	DD	imagerel $LN17+368
	DD	imagerel $chain$3$?_Allocate@std@@YAPEAX_K0_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Deallocate@std@@YAXPEAX_K1@Z DD imagerel $LN23
	DD	imagerel $LN23+666
	DD	imagerel $unwind$?_Deallocate@std@@YAXPEAX_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAA@XZ DD imagerel $LN76
	DD	imagerel $LN76+78
	DD	imagerel $unwind$??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAA@XZ DD imagerel $LN9
	DD	imagerel $LN9+37
	DD	imagerel $unwind$??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Alloc_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAXXZ DD imagerel $LN69
	DD	imagerel $LN69+51
	DD	imagerel $unwind$?_Alloc_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Free_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAXXZ DD imagerel $LN60
	DD	imagerel $LN60+121
	DD	imagerel $unwind$?_Free_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Orphan_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAXXZ DD imagerel $LN21
	DD	imagerel $LN21+96
	DD	imagerel $unwind$?_Orphan_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD imagerel $LN196
	DD	imagerel $LN196+117
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z DD imagerel $LN197
	DD	imagerel $LN197+163
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD imagerel $LN130
	DD	imagerel $LN130+107
	DD	imagerel $unwind$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z DD imagerel $LN218
	DD	imagerel $LN218+121
	DD	imagerel $unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z DD imagerel $LN218+121
	DD	imagerel $LN218+152
	DD	imagerel $chain$1$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z DD imagerel $LN218+152
	DD	imagerel $LN218+186
	DD	imagerel $chain$2$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z DD imagerel $LN218+186
	DD	imagerel $LN218+248
	DD	imagerel $chain$3$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z DD imagerel $LN218+248
	DD	imagerel $LN218+273
	DD	imagerel $chain$4$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z DD imagerel $LN188
	DD	imagerel $LN188+89
	DD	imagerel $unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z DD imagerel $LN188+89
	DD	imagerel $LN188+119
	DD	imagerel $chain$0$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z DD imagerel $LN188+119
	DD	imagerel $LN188+186
	DD	imagerel $chain$1$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z DD imagerel $LN188+186
	DD	imagerel $LN188+244
	DD	imagerel $chain$2$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z DD imagerel $LN188+244
	DD	imagerel $LN188+263
	DD	imagerel $chain$3$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K0@Z DD imagerel $LN128
	DD	imagerel $LN128+112
	DD	imagerel $unwind$?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K0@Z DD imagerel $LN128+112
	DD	imagerel $LN128+182
	DD	imagerel $chain$0$?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K0@Z DD imagerel $LN128+182
	DD	imagerel $LN128+196
	DD	imagerel $chain$1$?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ DD imagerel $LN35
	DD	imagerel $LN35+79
	DD	imagerel $unwind$?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z DD imagerel $LN480
	DD	imagerel $LN480+296
	DD	imagerel $unwind$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$1@?0??_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z@4HA DD imagerel ?catch$1@?0??_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z@4HA
	DD	imagerel ?catch$1@?0??_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z@4HA+55
	DD	imagerel $unwind$?catch$1@?0??_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0??_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z@4HA DD imagerel ?catch$0@?0??_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z@4HA
	DD	imagerel ?catch$0@?0??_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z@4HA+92
	DD	imagerel $unwind$?catch$0@?0??_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA_N_K_N@Z DD imagerel $LN104
	DD	imagerel $LN104+29
	DD	imagerel $unwind$?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA_N_K_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA_N_K_N@Z DD imagerel $LN104+29
	DD	imagerel $LN104+68
	DD	imagerel $chain$0$?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA_N_K_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA_N_K_N@Z DD imagerel $LN104+68
	DD	imagerel $LN104+114
	DD	imagerel $chain$2$?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA_N_K_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA_N_K_N@Z DD imagerel $LN104+114
	DD	imagerel $LN104+160
	DD	imagerel $chain$4$?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA_N_K_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_N_K@Z DD imagerel $LN120
	DD	imagerel $LN120+31
	DD	imagerel $unwind$?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_N_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_N_K@Z DD imagerel $LN120+31
	DD	imagerel $LN120+78
	DD	imagerel $chain$0$?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_N_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_N_K@Z DD imagerel $LN120+78
	DD	imagerel $LN120+132
	DD	imagerel $chain$1$?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_N_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAXXZ DD imagerel $LN4
	DD	imagerel $LN4+18
	DD	imagerel $unwind$?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Check_offset@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAX_K@Z DD imagerel $LN18
	DD	imagerel $LN18+29
	DD	imagerel $unwind$?_Check_offset@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAXXZ DD imagerel $LN4
	DD	imagerel $LN4+18
	DD	imagerel $unwind$?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_cast@std@@QEAA@AEBV01@@Z DD imagerel $LN6
	DD	imagerel $LN6+64
	DD	imagerel $unwind$??0bad_cast@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gbad_cast@std@@UEAAPEAXI@Z DD imagerel $LN11
	DD	imagerel $LN11+67
	DD	imagerel $unwind$??_Gbad_cast@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1locale@std@@QEAA@XZ DD imagerel $LN6
	DD	imagerel $LN6+57
	DD	imagerel $unwind$??1locale@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getfacet@locale@std@@QEBAPEBVfacet@12@_K@Z DD imagerel $LN12
	DD	imagerel $LN12+83
	DD	imagerel $unwind$?_Getfacet@locale@std@@QEBAPEBVfacet@12@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Fgetc@D@std@@YA_NAEADPEAU_iobuf@@@Z DD imagerel $LN6
	DD	imagerel $LN6+41
	DD	imagerel $unwind$??$_Fgetc@D@std@@YA_NAEADPEAU_iobuf@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Fputc@D@std@@YA_NDPEAU_iobuf@@@Z DD imagerel $LN4
	DD	imagerel $LN4+24
	DD	imagerel $unwind$??$_Fputc@D@std@@YA_NDPEAU_iobuf@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Ungetc@D@std@@YA_NAEBDPEAU_iobuf@@@Z DD imagerel $LN4
	DD	imagerel $LN4+24
	DD	imagerel $unwind$??$_Ungetc@D@std@@YA_NAEBDPEAU_iobuf@@@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?errorWithMessage@@YAXPEAD@Z DD imagerel $LN4
	DD	imagerel $LN4+75
	DD	imagerel $unwind$?errorWithMessage@@YAXPEAD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DD imagerel $LN113
	DD	imagerel $LN113+466
	DD	imagerel $unwind$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA DD imagerel ?catch$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
	DD	imagerel ?catch$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA+56
	DD	imagerel $unwind$?catch$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z DD imagerel $LN4
	DD	imagerel $LN4+57
	DD	imagerel $unwind$??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z
pdata	ENDS
pdata	SEGMENT
$pdata$?init@@YAXHQEAPEAD@Z DD imagerel $LN27
	DD	imagerel $LN27+341
	DD	imagerel $unwind$?init@@YAXHQEAPEAD@Z
$pdata$?compressPermuteKey@@YA_K_K@Z DD imagerel $LN53
	DD	imagerel $LN53+765
	DD	imagerel $unwind$?compressPermuteKey@@YA_K_K@Z
$pdata$?permutation1@@YA_K_K@Z DD imagerel $LN69
	DD	imagerel $LN69+1097
	DD	imagerel $unwind$?permutation1@@YA_K_K@Z
$pdata$?finalPermutation@@YA_K_K@Z DD imagerel $LN69
	DD	imagerel $LN69+1088
	DD	imagerel $unwind$?finalPermutation@@YA_K_K@Z
$pdata$?runIt@@YA_K_KH@Z DD imagerel $LN68
	DD	imagerel $LN68+1444
	DD	imagerel $unwind$?runIt@@YA_K_KH@Z
$pdata$main DD	imagerel $LN319
	DD	imagerel $LN319+7180
	DD	imagerel $unwind$main
pdata	ENDS
pdata	SEGMENT
$pdata$main$dtor$2 DD imagerel main$dtor$2
	DD	imagerel main$dtor$2+55
	DD	imagerel $unwind$main$dtor$2
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel $LN22
	DD	imagerel $LN22+223
	DD	imagerel $unwind$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA+46
	DD	imagerel $unwind$?dtor$0@?0???0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+92
	DD	imagerel $unwind$??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?open@?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXPEBDHH@Z DD imagerel $LN6
	DD	imagerel $LN6+69
	DD	imagerel $unwind$?open@?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXPEBDHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?close@?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXXZ DD imagerel $LN5
	DD	imagerel $LN5+58
	DD	imagerel $unwind$?close@?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@PEAU_iobuf@@@Z DD imagerel $LN15
	DD	imagerel $LN15+179
	DD	imagerel $unwind$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@PEAU_iobuf@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ DD imagerel $LN12
	DD	imagerel $LN12+115
	DD	imagerel $unwind$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z DD imagerel $LN33
	DD	imagerel $LN33+311
	DD	imagerel $unwind$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ DD imagerel $LN19
	DD	imagerel $LN19+127
	DD	imagerel $unwind$?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z DD imagerel $LN424
	DD	imagerel $LN424+1223
	DD	imagerel $unwind$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$4@?0??overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z@4HA DD imagerel ?dtor$4@?0??overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z@4HA
	DD	imagerel ?dtor$4@?0??overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z@4HA+38
	DD	imagerel $unwind$?dtor$4@?0??overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z DD imagerel $LN70
	DD	imagerel $LN70+169
	DD	imagerel $unwind$?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD imagerel $LN26
	DD	imagerel $LN26+51
	DD	imagerel $unwind$?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD imagerel $LN26+51
	DD	imagerel $LN26+79
	DD	imagerel $chain$0$?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD imagerel $LN26+79
	DD	imagerel $LN26+103
	DD	imagerel $chain$2$?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD imagerel $LN995
	DD	imagerel $LN995+1570
	DD	imagerel $unwind$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z DD imagerel $LN16
	DD	imagerel $LN16+216
	DD	imagerel $unwind$?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z DD imagerel $LN18
	DD	imagerel $LN18+224
	DD	imagerel $unwind$?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z DD imagerel $LN20
	DD	imagerel $LN20+65
	DD	imagerel $unwind$?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z DD imagerel $LN20+65
	DD	imagerel $LN20+218
	DD	imagerel $chain$0$?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z DD imagerel $LN20+218
	DD	imagerel $LN20+231
	DD	imagerel $chain$1$?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD imagerel $LN15
	DD	imagerel $LN15+67
	DD	imagerel $unwind$?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAXAEBVlocale@2@@Z DD imagerel $LN14
	DD	imagerel $LN14+80
	DD	imagerel $unwind$?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAXAEBVlocale@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@12@@Z DD imagerel $LN13
	DD	imagerel $LN13+149
	DD	imagerel $unwind$?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ DD imagerel $LN346
	DD	imagerel $LN346+1013
	DD	imagerel $unwind$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$4@?0??_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ@4HA DD imagerel ?dtor$4@?0??_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ@4HA
	DD	imagerel ?dtor$4@?0??_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ@4HA+44
	DD	imagerel $unwind$?dtor$4@?0??_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEBV?$codecvt@DDU_Mbstatet@@@2@@Z DD imagerel $LN12
	DD	imagerel $LN12+72
	DD	imagerel $unwind$?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEBV?$codecvt@DDU_Mbstatet@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z DD imagerel $LN6
	DD	imagerel $LN6+52
	DD	imagerel $unwind$??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$basic_fstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z DD imagerel $LN6
	DD	imagerel $LN6+59
	DD	imagerel $unwind$??_G?$basic_fstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXXZ DD imagerel $LN7
	DD	imagerel $LN7+101
	DD	imagerel $unwind$??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Iterator012@Urandom_access_iterator_tag@std@@D_JPEBDAEBDU_Iterator_base12@2@@std@@QEAA@XZ DD imagerel $LN6
	DD	imagerel $LN6+62
	DD	imagerel $unwind$??1?$_Iterator012@Urandom_access_iterator_tag@std@@D_JPEBDAEBDU_Iterator_base12@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEBDPEBU_Container_base12@1@@Z DD imagerel $LN8
	DD	imagerel $LN8+65
	DD	imagerel $unwind$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEBDPEBU_Container_base12@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAAEBDXZ DD imagerel $LN45
	DD	imagerel $LN45+226
	DD	imagerel $unwind$??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAAEBDXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@XZ DD imagerel $LN9
	DD	imagerel $LN9+62
	DD	imagerel $unwind$??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z DD imagerel $LN32
	DD	imagerel $LN32+271
	DD	imagerel $unwind$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEADPEBU_Container_base12@1@@Z DD imagerel $LN11
	DD	imagerel $LN11+65
	DD	imagerel $unwind$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEADPEBU_Container_base12@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@XZ DD imagerel $LN12
	DD	imagerel $LN12+62
	DD	imagerel $unwind$??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD imagerel $LN10
	DD	imagerel $LN10+44
	DD	imagerel $unwind$??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel $LN8
	DD	imagerel $LN8+49
	DD	imagerel $unwind$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD imagerel $LN26
	DD	imagerel $LN26+124
	DD	imagerel $unwind$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel $LN13
	DD	imagerel $LN13+72
	DD	imagerel $unwind$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT __real@408f400000000000
CONST	SEGMENT
__real@408f400000000000 DQ 0408f400000000000r	; 1000
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_cast@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_cast@std@@8 DD imagerel ??_R0?AVbad_cast@std@@@8 ; std::bad_cast::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3bad_cast@std@@8
rdata$r	ENDS
;	COMDAT ??_R2bad_cast@std@@8
rdata$r	SEGMENT
??_R2bad_cast@std@@8 DD imagerel ??_R1A@?0A@EA@bad_cast@std@@8 ; std::bad_cast::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@exception@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3bad_cast@std@@8
rdata$r	SEGMENT
??_R3bad_cast@std@@8 DD 00H				; std::bad_cast::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2bad_cast@std@@8
rdata$r	ENDS
;	COMDAT ??_R4bad_cast@std@@6B@
rdata$r	SEGMENT
??_R4bad_cast@std@@6B@ DD 01H				; std::bad_cast::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVbad_cast@std@@@8
	DD	imagerel ??_R3bad_cast@std@@8
	DD	imagerel ??_R4bad_cast@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	imagerel ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@A@3EA@ios_base@std@@8
	DD	imagerel ??_R17A@3EA@?$_Iosb@H@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	imagerel ??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::basic_ostream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R1BA@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1BA@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (16,-1,0,64)'
	DD	03H
	DD	010H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R17A@3EA@?$_Iosb@H@std@@8 DD imagerel ??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,0,4,64)'
	DD	00H
	DD	08H
	DD	00H
	DD	04H
	DD	040H
	DD	imagerel ??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@A@3EA@ios_base@std@@8
rdata$r	SEGMENT
??_R1A@A@3EA@ios_base@std@@8 DD imagerel ??_R0?AVios_base@std@@@8 ; std::ios_base::`RTTI Base Class Descriptor at (0,0,4,64)'
	DD	01H
	DD	00H
	DD	00H
	DD	04H
	DD	040H
	DD	imagerel ??_R3ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$_Iosb@H@std@@8 DD imagerel ??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R2?$_Iosb@H@std@@8 DD imagerel ??_R1A@?0A@EA@?$_Iosb@H@std@@8 ; std::_Iosb<int>::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R3?$_Iosb@H@std@@8 DD 00H				; std::_Iosb<int>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$_Iosb@H@std@@@8
data$r	SEGMENT
??_R0?AV?$_Iosb@H@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::_Iosb<int> `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$_Iosb@H@std@@', 00H
data$r	ENDS
;	COMDAT ??_R17?0A@EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R17?0A@EA@?$_Iosb@H@std@@8 DD imagerel ??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,-1,0,64)'
	DD	00H
	DD	08H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R2ios_base@std@@8
rdata$r	SEGMENT
??_R2ios_base@std@@8 DD imagerel ??_R1A@?0A@EA@ios_base@std@@8 ; std::ios_base::`RTTI Base Class Array'
	DD	imagerel ??_R17?0A@EA@?$_Iosb@H@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3ios_base@std@@8
rdata$r	SEGMENT
??_R3ios_base@std@@8 DD 00H				; std::ios_base::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVios_base@std@@@8
data$r	SEGMENT
??_R0?AVios_base@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::ios_base `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVios_base@std@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ios_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ios_base@std@@8 DD imagerel ??_R0?AVios_base@std@@@8 ; std::ios_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@ios_base@std@@8
	DD	imagerel ??_R17?0A@EA@?$_Iosb@H@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD 00H	; std::basic_ios<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	imagerel ??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::basic_ios<char,std::char_traits<char> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$basic_ios@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,0,4,80)'
	DD	02H
	DD	00H
	DD	00H
	DD	04H
	DD	050H
	DD	imagerel ??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	imagerel ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@A@3EA@ios_base@std@@8
	DD	imagerel ??_R17A@3EA@?$_Iosb@H@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_istream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	imagerel ??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::basic_istream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$basic_istream@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_iostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_iostream@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$basic_iostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@A@3EA@ios_base@std@@8
	DD	imagerel ??_R17A@3EA@?$_Iosb@H@std@@8
	DD	imagerel ??_R1BA@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@A@3EA@ios_base@std@@8
	DD	imagerel ??_R17A@3EA@?$_Iosb@H@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3?$basic_iostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_iostream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	03H
	DD	09H
	DD	imagerel ??_R2?$basic_iostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_iostream@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_iostream@DU?$char_traits@D@std@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::basic_iostream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$basic_iostream@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_iostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_iostream@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R0?AV?$basic_iostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	08H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_iostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_fstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_fstream@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R0?AV?$basic_fstream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_fstream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	09H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_fstream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_fstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_fstream@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$basic_fstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_fstream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@?$basic_iostream@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@A@3EA@ios_base@std@@8
	DD	imagerel ??_R17A@3EA@?$_Iosb@H@std@@8
	DD	imagerel ??_R1BA@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@A@3EA@ios_base@std@@8
	DD	imagerel ??_R17A@3EA@?$_Iosb@H@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3?$basic_fstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_fstream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_fstream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	03H
	DD	0aH
	DD	imagerel ??_R2?$basic_fstream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_fstream@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_fstream@DU?$char_traits@D@std@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::basic_fstream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$basic_fstream@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@ DD 01H ; std::basic_fstream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
	DD	0b8H
	DD	04H
	DD	imagerel ??_R0?AV?$basic_fstream@DU?$char_traits@D@std@@@std@@@8
	DD	imagerel ??_R3?$basic_fstream@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R4?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::basic_streambuf<char,std::char_traits<char> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::basic_filebuf<char,std::char_traits<char> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ DD 01H ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8
	DD	imagerel ??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R4?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD imagerel ??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD imagerel ??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 01H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVexception@std@@@8
	DD	imagerel ??_R3exception@std@@8
	DD	imagerel ??_R4exception@std@@6B@
rdata$r	ENDS
;	COMDAT _CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QEAA@AEBV01@@Z24 DD 00H
	DD	imagerel ??_R0?AVbad_cast@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0bad_cast@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_cast@std@@@8
data$r	SEGMENT
??_R0?AVbad_cast@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::bad_cast `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVbad_cast@std@@', 00H
data$r	ENDS
;	COMDAT _CTA2?AVbad_cast@std@@
xdata$x	SEGMENT
_CTA2?AVbad_cast@std@@ DD 02H
	DD	imagerel _CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QEAA@AEBV01@@Z24
	DD	imagerel _CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
xdata$x	ENDS
;	COMDAT _TI2?AVbad_cast@std@@
xdata$x	SEGMENT
_TI2?AVbad_cast@std@@ DD 00H
	DD	imagerel ??1bad_cast@std@@UEAA@XZ
	DD	00H
	DD	imagerel _CTA2?AVbad_cast@std@@
xdata$x	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
CONST	SEGMENT
??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ DB '"'
	DB	00H, 'o', 00H, 'u', 00H, 't', 00H, ' ', 00H, 'o', 00H, 'f', 00H
	DB	' ', 00H, 'r', 00H, 'a', 00H, 'n', 00H, 'g', 00H, 'e', 00H, '"'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1MG@GDGHDIKC@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
CONST	SEGMENT
??_C@_1MG@GDGHDIKC@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'S', 00H
	DB	't', 00H, 'r', 00H, 'i', 00H, 'n', 00H, 'g', 00H, '_', 00H, 'c'
	DB	00H, 'o', 00H, 'n', 00H, 's', 00H, 't', 00H, '_', 00H, 'i', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H
	DB	' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_'
	DB	00H, 'S', 00H, 't', 00H, 'r', 00H, 'i', 00H, 'n', 00H, 'g', 00H
	DB	'_', 00H, 'v', 00H, 'a', 00H, 'l', 00H, '<', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ' ', 00H, 's', 00H
	DB	't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'S', 00H, 'i'
	DB	00H, 'm', 00H, 'p', 00H, 'l', 00H, 'e', 00H, '_', 00H, 't', 00H
	DB	'y', 00H, 'p', 00H, 'e', 00H, 's', 00H, '<', 00H, 'c', 00H, 'h'
	DB	00H, 'a', 00H, 'r', 00H, '>', 00H, ' ', 00H, '>', 00H, ' ', 00H
	DB	'>', 00H, ':', 00H, ':', 00H, 'o', 00H, 'p', 00H, 'e', 00H, 'r'
	DB	00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, ' ', 00H, '*', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@
CONST	SEGMENT
??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ DB '"'
	DB	00H, 'S', 00H, 't', 00H, 'a', 00H, 'n', 00H, 'd', 00H, 'a', 00H
	DB	'r', 00H, 'd', 00H, ' ', 00H, 'C', 00H, '+', 00H, '+', 00H, ' '
	DB	00H, 'L', 00H, 'i', 00H, 'b', 00H, 'r', 00H, 'a', 00H, 'r', 00H
	DB	'i', 00H, 'e', 00H, 's', 00H, ' ', 00H, 'O', 00H, 'u', 00H, 't'
	DB	00H, ' ', 00H, 'o', 00H, 'f', 00H, ' ', 00H, 'R', 00H, 'a', 00H
	DB	'n', 00H, 'g', 00H, 'e', 00H, '"', 00H, ' ', 00H, '&', 00H, '&'
	DB	00H, ' ', 00H, '0', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1EG@CNCHLAOB@?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb@
CONST	SEGMENT
??_C@_1EG@CNCHLAOB@?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb@ DB 's'
	DB	00H, 't', 00H, 'r', 00H, 'i', 00H, 'n', 00H, 'g', 00H, ' ', 00H
	DB	'i', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o'
	DB	00H, 'r', 00H, ' ', 00H, 'n', 00H, 'o', 00H, 't', 00H, ' ', 00H
	DB	'd', 00H, 'e', 00H, 'r', 00H, 'e', 00H, 'f', 00H, 'e', 00H, 'r'
	DB	00H, 'e', 00H, 'n', 00H, 'c', 00H, 'a', 00H, 'b', 00H, 'l', 00H
	DB	'e', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1IO@IPMLDGDI@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
CONST	SEGMENT
??_C@_1IO@IPMLDGDI@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ DB 'C'
	DB	00H, ':', 00H, '\', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'F', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'M', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'V', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 'S', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	' ', 00H, '1', 00H, '4', 00H, '.', 00H, '0', 00H, '\', 00H, 'V'
	DB	00H, 'C', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l', 00H
	DB	'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'x', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'i', 00H, 'n', 00H, 'g', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LGHPBDLJ@Total?5time?3?5?$AA@
CONST	SEGMENT
??_C@_0N@LGHPBDLJ@Total?5time?3?5?$AA@ DB 'Total time: ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01LKDEMHDF@s?$AA@
CONST	SEGMENT
??_C@_01LKDEMHDF@s?$AA@ DB 's', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@EHAFNCKF@This?5is?5a?5weak?5key?4?5Try?5again?$AA@
CONST	SEGMENT
??_C@_0BO@EHAFNCKF@This?5is?5a?5weak?5key?4?5Try?5again?$AA@ DB 'This is '
	DB	'a weak key. Try again', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@DPNHLANH@Not?5a?5valid?5char?5value?4?$AA@
CONST	SEGMENT
??_C@_0BI@DPNHLANH@Not?5a?5valid?5char?5value?4?$AA@ DB 'Not a valid char'
	DB	' value.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@NMCADOHI@File?5does?5not?5exist?4?$AA@
CONST	SEGMENT
??_C@_0BF@NMCADOHI@File?5does?5not?5exist?4?$AA@ DB 'File does not exist.'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_8?$basic_fstream@DU?$char_traits@D@std@@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@
CONST	SEGMENT
??_8?$basic_fstream@DU?$char_traits@D@std@@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@ DD 00H ; std::basic_fstream<char,std::char_traits<char> >::`vbtable'
	DD	0a8H
CONST	ENDS
;	COMDAT ??_8?$basic_fstream@DU?$char_traits@D@std@@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@
CONST	SEGMENT
??_8?$basic_fstream@DU?$char_traits@D@std@@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@ DD 00H ; std::basic_fstream<char,std::char_traits<char> >::`vbtable'
	DD	0b8H
CONST	ENDS
;	COMDAT ??_7?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@ DQ FLAT:??_R4?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_fstream<char,std::char_traits<char> >::`vftable'
	DQ	FLAT:??_E?$basic_fstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@EAAPEAXI@Z
CONST	ENDS
;	COMDAT ??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ DQ FLAT:??_R4?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_filebuf<char,std::char_traits<char> >::`vftable'
	DQ	FLAT:??_E?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z
	DQ	FLAT:?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ
	DQ	FLAT:?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ
	DQ	FLAT:?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z
	DQ	FLAT:?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z
	DQ	FLAT:?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JXZ
	DQ	FLAT:?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
	DQ	FLAT:?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
	DQ	FLAT:?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z
	DQ	FLAT:?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JPEBD_J@Z
	DQ	FLAT:?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
	DQ	FLAT:?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
	DQ	FLAT:?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z
	DQ	FLAT:?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
	DQ	FLAT:?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAXAEBVlocale@2@@Z
CONST	ENDS
;	COMDAT ??_C@_0P@KNIHKEND@Incorrect?5Mode?$AA@
CONST	SEGMENT
??_C@_0P@KNIHKEND@Incorrect?5Mode?$AA@ DB 'Incorrect Mode', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08DPLLBGKL@Bad?5key?4?$AA@
CONST	SEGMENT
??_C@_08DPLLBGKL@Bad?5key?4?$AA@ DB 'Bad key.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@LDCMBOAO@Incorrect?5action?4?$AA@
CONST	SEGMENT
??_C@_0BC@LDCMBOAO@Incorrect?5action?4?$AA@ DB 'Incorrect action.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02LNCFEIBO@?9E?$AA@
CONST	SEGMENT
??_C@_02LNCFEIBO@?9E?$AA@ DB '-E', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02CIKBGMLM@?9e?$AA@
CONST	SEGMENT
??_C@_02CIKBGMLM@?9e?$AA@ DB '-e', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02KEDOHJFP@?9D?$AA@
CONST	SEGMENT
??_C@_02KEDOHJFP@?9D?$AA@ DB '-D', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02DBLKFNPN@?9d?$AA@
CONST	SEGMENT
??_C@_02DBLKFNPN@?9d?$AA@ DB '-d', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@IOHJEBAL@Incorrect?5number?5of?5arguments?4?$AA@
CONST	SEGMENT
??_C@_0BP@IOHJEBAL@Incorrect?5number?5of?5arguments?4?$AA@ DB 'Incorrect '
	DB	'number of arguments.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07BCFMPKIE@ERROR?4?5?$AA@
CONST	SEGMENT
??_C@_07BCFMPKIE@ERROR?4?5?$AA@ DB 'ERROR. ', 00H	; `string'
CONST	ENDS
;	COMDAT _CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24 DD 00H
	DD	imagerel ??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0exception@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT ??_C@_08EPJLHIJG@bad?5cast?$AA@
CONST	SEGMENT
??_C@_08EPJLHIJG@bad?5cast?$AA@ DB 'bad cast', 00H	; `string'
CONST	ENDS
;	COMDAT ??_7bad_cast@std@@6B@
CONST	SEGMENT
??_7bad_cast@std@@6B@ DQ FLAT:??_R4bad_cast@std@@6B@	; std::bad_cast::`vftable'
	DQ	FLAT:??_Ebad_cast@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ??_C@_1GI@DHJGPFNI@?$AA?$CC?$AA_?$AAP?$AAt?$AAr?$AA_?$AAu?$AAs?$AAe?$AAr?$AA?5?$AA?9?$AA?5?$AA_?$AAP?$AAt?$AAr?$AA_?$AAc?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn?$AAe?$AAr?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA_@
CONST	SEGMENT
??_C@_1GI@DHJGPFNI@?$AA?$CC?$AA_?$AAP?$AAt?$AAr?$AA_?$AAu?$AAs?$AAe?$AAr?$AA?5?$AA?9?$AA?5?$AA_?$AAP?$AAt?$AAr?$AA_?$AAc?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn?$AAe?$AAr?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA_@ DB '"'
	DB	00H, '_', 00H, 'P', 00H, 't', 00H, 'r', 00H, '_', 00H, 'u', 00H
	DB	's', 00H, 'e', 00H, 'r', 00H, ' ', 00H, '-', 00H, ' ', 00H, '_'
	DB	00H, 'P', 00H, 't', 00H, 'r', 00H, '_', 00H, 'c', 00H, 'o', 00H
	DB	'n', 00H, 't', 00H, 'a', 00H, 'i', 00H, 'n', 00H, 'e', 00H, 'r'
	DB	00H, ' ', 00H, '<', 00H, '=', 00H, ' ', 00H, '_', 00H, 'N', 00H
	DB	'O', 00H, 'N', 00H, '_', 00H, 'U', 00H, 'S', 00H, 'E', 00H, 'R'
	DB	00H, '_', 00H, 'S', 00H, 'I', 00H, 'Z', 00H, 'E', 00H, '"', 00H
	DB	' ', 00H, '&', 00H, '&', 00H, ' ', 00H, '0', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1HA@NAPGMHAO@?$AA?$CC?$AA2?$AA?5?$AA?$CK?$AA?5?$AAs?$AAi?$AAz?$AAe?$AAo?$AAf?$AA?$CI?$AAv?$AAo?$AAi?$AAd?$AA?5?$AA?$CK?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA_?$AAP?$AAt?$AAr?$AA_?$AAu?$AAs?$AAe?$AAr@
CONST	SEGMENT
??_C@_1HA@NAPGMHAO@?$AA?$CC?$AA2?$AA?5?$AA?$CK?$AA?5?$AAs?$AAi?$AAz?$AAe?$AAo?$AAf?$AA?$CI?$AAv?$AAo?$AAi?$AAd?$AA?5?$AA?$CK?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA_?$AAP?$AAt?$AAr?$AA_?$AAu?$AAs?$AAe?$AAr@ DB '"'
	DB	00H, '2', 00H, ' ', 00H, '*', 00H, ' ', 00H, 's', 00H, 'i', 00H
	DB	'z', 00H, 'e', 00H, 'o', 00H, 'f', 00H, '(', 00H, 'v', 00H, 'o'
	DB	00H, 'i', 00H, 'd', 00H, ' ', 00H, '*', 00H, ')', 00H, ' ', 00H
	DB	'<', 00H, '=', 00H, ' ', 00H, '_', 00H, 'P', 00H, 't', 00H, 'r'
	DB	00H, '_', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r', 00H, ' ', 00H
	DB	'-', 00H, ' ', 00H, '_', 00H, 'P', 00H, 't', 00H, 'r', 00H, '_'
	DB	00H, 'c', 00H, 'o', 00H, 'n', 00H, 't', 00H, 'a', 00H, 'i', 00H
	DB	'n', 00H, 'e', 00H, 'r', 00H, '"', 00H, ' ', 00H, '&', 00H, '&'
	DB	00H, ' ', 00H, '0', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1EE@PDHAHDDC@?$AA?$CC?$AA_?$AAP?$AAt?$AAr?$AA_?$AAc?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn?$AAe?$AAr?$AA?5?$AA?$DM?$AA?5?$AA_?$AAP?$AAt?$AAr?$AA_?$AAu?$AAs?$AAe?$AAr?$AA?$CC?$AA?5?$AA?$CG?$AA?$CG?$AA?5@
CONST	SEGMENT
??_C@_1EE@PDHAHDDC@?$AA?$CC?$AA_?$AAP?$AAt?$AAr?$AA_?$AAc?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn?$AAe?$AAr?$AA?5?$AA?$DM?$AA?5?$AA_?$AAP?$AAt?$AAr?$AA_?$AAu?$AAs?$AAe?$AAr?$AA?$CC?$AA?5?$AA?$CG?$AA?$CG?$AA?5@ DB '"'
	DB	00H, '_', 00H, 'P', 00H, 't', 00H, 'r', 00H, '_', 00H, 'c', 00H
	DB	'o', 00H, 'n', 00H, 't', 00H, 'a', 00H, 'i', 00H, 'n', 00H, 'e'
	DB	00H, 'r', 00H, ' ', 00H, '<', 00H, ' ', 00H, '_', 00H, 'P', 00H
	DB	't', 00H, 'r', 00H, '_', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r'
	DB	00H, '"', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, '0', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1JO@EKLKIEHP@?$AA?$CC?$AAr?$AAe?$AAi?$AAn?$AAt?$AAe?$AAr?$AAp?$AAr?$AAe?$AAt?$AA_?$AAc?$AAa?$AAs?$AAt?$AA?$DM?$AAu?$AAi?$AAn?$AAt?$AAp?$AAt?$AAr?$AA_?$AAt?$AA?5?$AA?$CK?$AA?$DO?$AA?$CI?$AA_@
CONST	SEGMENT
??_C@_1JO@EKLKIEHP@?$AA?$CC?$AAr?$AAe?$AAi?$AAn?$AAt?$AAe?$AAr?$AAp?$AAr?$AAe?$AAt?$AA_?$AAc?$AAa?$AAs?$AAt?$AA?$DM?$AAu?$AAi?$AAn?$AAt?$AAp?$AAt?$AAr?$AA_?$AAt?$AA?5?$AA?$CK?$AA?$DO?$AA?$CI?$AA_@ DB '"'
	DB	00H, 'r', 00H, 'e', 00H, 'i', 00H, 'n', 00H, 't', 00H, 'e', 00H
	DB	'r', 00H, 'p', 00H, 'r', 00H, 'e', 00H, 't', 00H, '_', 00H, 'c'
	DB	00H, 'a', 00H, 's', 00H, 't', 00H, '<', 00H, 'u', 00H, 'i', 00H
	DB	'n', 00H, 't', 00H, 'p', 00H, 't', 00H, 'r', 00H, '_', 00H, 't'
	DB	00H, ' ', 00H, '*', 00H, '>', 00H, '(', 00H, '_', 00H, 'P', 00H
	DB	't', 00H, 'r', 00H, '_', 00H, 'p', 00H, 't', 00H, 'r', 00H, ')'
	DB	00H, '[', 00H, '-', 00H, '1', 00H, ']', 00H, ' ', 00H, '=', 00H
	DB	'=', 00H, ' ', 00H, '_', 00H, 'B', 00H, 'I', 00H, 'G', 00H, '_'
	DB	00H, 'A', 00H, 'L', 00H, 'L', 00H, 'O', 00H, 'C', 00H, 'A', 00H
	DB	'T', 00H, 'I', 00H, 'O', 00H, 'N', 00H, '_', 00H, 'S', 00H, 'E'
	DB	00H, 'N', 00H, 'T', 00H, 'I', 00H, 'N', 00H, 'E', 00H, 'L', 00H
	DB	'"', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, '0', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1HE@CDMBFOKC@?$AA?$CC?$AA?$CI?$AA_?$AAP?$AAt?$AAr?$AA_?$AAu?$AAs?$AAe?$AAr?$AA?5?$AA?$CG?$AA?5?$AA?$CI?$AA_?$AAB?$AAI?$AAG?$AA_?$AAA?$AAL?$AAL?$AAO?$AAC?$AAA?$AAT?$AAI?$AAO?$AAN?$AA_?$AAA@
CONST	SEGMENT
??_C@_1HE@CDMBFOKC@?$AA?$CC?$AA?$CI?$AA_?$AAP?$AAt?$AAr?$AA_?$AAu?$AAs?$AAe?$AAr?$AA?5?$AA?$CG?$AA?5?$AA?$CI?$AA_?$AAB?$AAI?$AAG?$AA_?$AAA?$AAL?$AAL?$AAO?$AAC?$AAA?$AAT?$AAI?$AAO?$AAN?$AA_?$AAA@ DB '"'
	DB	00H, '(', 00H, '_', 00H, 'P', 00H, 't', 00H, 'r', 00H, '_', 00H
	DB	'u', 00H, 's', 00H, 'e', 00H, 'r', 00H, ' ', 00H, '&', 00H, ' '
	DB	00H, '(', 00H, '_', 00H, 'B', 00H, 'I', 00H, 'G', 00H, '_', 00H
	DB	'A', 00H, 'L', 00H, 'L', 00H, 'O', 00H, 'C', 00H, 'A', 00H, 'T'
	DB	00H, 'I', 00H, 'O', 00H, 'N', 00H, '_', 00H, 'A', 00H, 'L', 00H
	DB	'I', 00H, 'G', 00H, 'N', 00H, 'M', 00H, 'E', 00H, 'N', 00H, 'T'
	DB	00H, ' ', 00H, '-', 00H, ' ', 00H, '1', 00H, ')', 00H, ')', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '0', 00H, '"', 00H, ' '
	DB	00H, '&', 00H, '&', 00H, ' ', 00H, '0', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@LOFJFFDB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@LOFJFFDB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA?$AA@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'D', 00H
	DB	'e', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'a'
	DB	00H, 't', 00H, 'e', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1EI@MLOBABC@?$AA?$CC?$AA_?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA?$CI?$AAs?$AAi?$AAz?$AAe?$AA_?$AAt?$AA?$CJ?$AA?$CI?$AA?9?$AA1?$AA?$CJ?$AA?5?$AA?1?$AA?5?$AA_?$AAS?$AAz?$AA?$CC?$AA?5?$AA?$CG@
CONST	SEGMENT
??_C@_1EI@MLOBABC@?$AA?$CC?$AA_?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA?$CI?$AAs?$AAi?$AAz?$AAe?$AA_?$AAt?$AA?$CJ?$AA?$CI?$AA?9?$AA1?$AA?$CJ?$AA?5?$AA?1?$AA?5?$AA_?$AAS?$AAz?$AA?$CC?$AA?5?$AA?$CG@ DB '"'
	DB	00H, '_', 00H, 'C', 00H, 'o', 00H, 'u', 00H, 'n', 00H, 't', 00H
	DB	' ', 00H, '<', 00H, '=', 00H, ' ', 00H, '(', 00H, 's', 00H, 'i'
	DB	00H, 'z', 00H, 'e', 00H, '_', 00H, 't', 00H, ')', 00H, '(', 00H
	DB	'-', 00H, '1', 00H, ')', 00H, ' ', 00H, '/', 00H, ' ', 00H, '_'
	DB	00H, 'S', 00H, 'z', 00H, '"', 00H, ' ', 00H, '&', 00H, '&', 00H
	DB	' ', 00H, '0', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@GKJLLHIM@?$AA?$CC?$AA_?$AAP?$AAt?$AAr?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?$CC?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@GKJLLHIM@?$AA?$CC?$AA_?$AAP?$AAt?$AAr?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?$CC?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA0?$AA?$AA@ DB '"'
	DB	00H, '_', 00H, 'P', 00H, 't', 00H, 'r', 00H, ' ', 00H, '!', 00H
	DB	'=', 00H, ' ', 00H, '0', 00H, '"', 00H, ' ', 00H, '&', 00H, '&'
	DB	00H, ' ', 00H, '0', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@
CONST	SEGMENT
??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@ DB '"'
	DB	00H, 'i', 00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H
	DB	'd', 00H, ' ', 00H, 'a', 00H, 'r', 00H, 'g', 00H, 'u', 00H, 'm'
	DB	00H, 'e', 00H, 'n', 00H, 't', 00H, '"', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BO@NKFMJPA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1BO@NKFMJPA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA?$AA@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'A', 00H
	DB	'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'a', 00H, 't', 00H, 'e'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1JA@HEEMAOGC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
CONST	SEGMENT
??_C@_1JA@HEEMAOGC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ DB 'C'
	DB	00H, ':', 00H, '\', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'F', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'M', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'V', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 'S', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	' ', 00H, '1', 00H, '4', 00H, '.', 00H, '0', 00H, '\', 00H, 'V'
	DB	00H, 'C', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l', 00H
	DB	'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'x', 00H, 'm', 00H, 'e'
	DB	00H, 'm', 00H, 'o', 00H, 'r', 00H, 'y', 00H, '0', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs?$AA?$AA@ DB '%', 00H, 'l', 00H, 's', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1DG@HGDKEBPG@?$AA?$CC?$AA_?$AAP?$AAt?$AAr?$AA_?$AAc?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn?$AAe?$AAr?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?$CC?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1DG@HGDKEBPG@?$AA?$CC?$AA_?$AAP?$AAt?$AAr?$AA_?$AAc?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn?$AAe?$AAr?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?$CC?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA0?$AA?$AA@ DB '"'
	DB	00H, '_', 00H, 'P', 00H, 't', 00H, 'r', 00H, '_', 00H, 'c', 00H
	DB	'o', 00H, 'n', 00H, 't', 00H, 'a', 00H, 'i', 00H, 'n', 00H, 'e'
	DB	00H, 'r', 00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H, '0', 00H
	DB	'"', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, '0', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@
CONST	SEGMENT
??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@ DB 'I'
	DB	00H, 'T', 00H, 'E', 00H, 'R', 00H, 'A', 00H, 'T', 00H, 'O', 00H
	DB	'R', 00H, ' ', 00H, 'L', 00H, 'I', 00H, 'S', 00H, 'T', 00H, ' '
	DB	00H, 'C', 00H, 'O', 00H, 'R', 00H, 'R', 00H, 'U', 00H, 'P', 00H
	DB	'T', 00H, 'E', 00H, 'D', 00H, '!', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1JA@IJKHNLMB@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
CONST	SEGMENT
??_C@_1JA@IJKHNLMB@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ DB 'C'
	DB	00H, ':', 00H, '\', 00H, 'P', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'F', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'M', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'V', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 'S', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	' ', 00H, '1', 00H, '4', 00H, '.', 00H, '0', 00H, '\', 00H, 'V'
	DB	00H, 'C', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l', 00H
	DB	'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'x', 00H, 'u', 00H, 't'
	DB	00H, 'i', 00H, 'l', 00H, 'i', 00H, 't', 00H, 'y', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception?$AA@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception?$AA@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DQ FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DQ	FLAT:??_Eexception@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DD	0ffffffffH
	DD	imagerel ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ+39
	DD	00H
	DD	imagerel ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ+66
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DD	020H
	DD	00H
	DD	05H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 020f19H
	DD	030025206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD imagerel ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
	DD	0ffffffffH
	DD	imagerel ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z+57
	DD	00H
	DD	imagerel ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z+110
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD 041811H
	DD	093418H
	DD	07006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DD	0ffffffffH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DD	020H
	DD	00H
	DD	05H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 010d19H
	DD	06204H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@XZ DD imagerel ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@XZ
	DD	0ffffffffH
	DD	imagerel ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@XZ+18
	DD	00H
	DD	imagerel ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@XZ+56
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@XZ DD 0ffffffffH
	DD	imagerel ?dtor$2@?0???1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@XZ DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@XZ
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@XZ
	DD	020H
	DD	00H
	DD	05H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@XZ DD 020f19H
	DD	030025206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEADPEBU_Container_base12@1@@Z DD imagerel ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEADPEBU_Container_base12@1@@Z
	DD	0ffffffffH
	DD	imagerel ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEADPEBU_Container_base12@1@@Z+39
	DD	00H
	DD	imagerel ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEADPEBU_Container_base12@1@@Z+51
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEADPEBU_Container_base12@1@@Z DD 0ffffffffH
	DD	imagerel ?dtor$1@?0???0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEADPEBU_Container_base12@1@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEADPEBU_Container_base12@1@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEADPEBU_Container_base12@1@@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEADPEBU_Container_base12@1@@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEADPEBU_Container_base12@1@@Z DD 041811H
	DD	093418H
	DD	07006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEADPEBU_Container_base12@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z DD imagerel ??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z
	DD	0ffffffffH
	DD	imagerel ??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z+42
	DD	00H
	DD	imagerel ??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z+241
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z DD 061911H
	DD	0d6419H
	DD	0c3414H
	DD	070027206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@XZ DD imagerel ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@XZ
	DD	0ffffffffH
	DD	imagerel ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@XZ+18
	DD	00H
	DD	imagerel ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@XZ+56
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@XZ DD 0ffffffffH
	DD	imagerel ?dtor$1@?0???1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@XZ DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@XZ
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@XZ
	DD	020H
	DD	00H
	DD	05H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@XZ DD 020f19H
	DD	030025206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAAEBDXZ DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEBDPEBU_Container_base12@1@@Z DD imagerel ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEBDPEBU_Container_base12@1@@Z
	DD	0ffffffffH
	DD	imagerel ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEBDPEBU_Container_base12@1@@Z+39
	DD	00H
	DD	imagerel ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEBDPEBU_Container_base12@1@@Z+51
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEBDPEBU_Container_base12@1@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEBDPEBU_Container_base12@1@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEBDPEBU_Container_base12@1@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEBDPEBU_Container_base12@1@@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEBDPEBU_Container_base12@1@@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEBDPEBU_Container_base12@1@@Z DD 041811H
	DD	093418H
	DD	07006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEBDPEBU_Container_base12@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$_Iterator012@Urandom_access_iterator_tag@std@@D_JPEBDAEBDU_Iterator_base12@2@@std@@QEAA@XZ DD imagerel ??1?$_Iterator012@Urandom_access_iterator_tag@std@@D_JPEBDAEBDU_Iterator_base12@2@@std@@QEAA@XZ
	DD	0ffffffffH
	DD	imagerel ??1?$_Iterator012@Urandom_access_iterator_tag@std@@D_JPEBDAEBDU_Iterator_base12@2@@std@@QEAA@XZ+18
	DD	00H
	DD	imagerel ??1?$_Iterator012@Urandom_access_iterator_tag@std@@D_JPEBDAEBDU_Iterator_base12@2@@std@@QEAA@XZ+56
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$_Iterator012@Urandom_access_iterator_tag@std@@D_JPEBDAEBDU_Iterator_base12@2@@std@@QEAA@XZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???1?$_Iterator012@Urandom_access_iterator_tag@std@@D_JPEBDAEBDU_Iterator_base12@2@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1?$_Iterator012@Urandom_access_iterator_tag@std@@D_JPEBDAEBDU_Iterator_base12@2@@std@@QEAA@XZ DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??1?$_Iterator012@Urandom_access_iterator_tag@std@@D_JPEBDAEBDU_Iterator_base12@2@@std@@QEAA@XZ
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??1?$_Iterator012@Urandom_access_iterator_tag@std@@D_JPEBDAEBDU_Iterator_base12@2@@std@@QEAA@XZ
	DD	020H
	DD	00H
	DD	05H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Iterator012@Urandom_access_iterator_tag@std@@D_JPEBDAEBDU_Iterator_base12@2@@std@@QEAA@XZ DD 020f19H
	DD	030025206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??1?$_Iterator012@Urandom_access_iterator_tag@std@@D_JPEBDAEBDU_Iterator_base12@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$basic_fstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEBV?$codecvt@DDU_Mbstatet@@@2@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$4@?0??_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ DD imagerel ?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ
	DD	0ffffffffH
	DD	imagerel ?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ+112
	DD	00H
	DD	imagerel ?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ+128
	DD	01H
	DD	imagerel ?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ+144
	DD	02H
	DD	imagerel ?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ+199
	DD	03H
	DD	imagerel ?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ+316
	DD	04H
	DD	imagerel ?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ+428
	DD	00H
	DD	imagerel ?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ+462
	DD	05H
	DD	imagerel ?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ+477
	DD	06H
	DD	imagerel ?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ+588
	DD	00H
	DD	imagerel ?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ+607
	DD	07H
	DD	imagerel ?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ+660
	DD	00H
	DD	imagerel ?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ+670
	DD	08H
	DD	imagerel ?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ+780
	DD	00H
	DD	imagerel ?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ+831
	DD	0ffffffffH
	DD	imagerel ?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ+875
	DD	09H
	DD	imagerel ?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ+986
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0??_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ@4HA
	DD	01H
	DD	imagerel ?dtor$2@?0??_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ@4HA
	DD	01H
	DD	imagerel ?dtor$15@?0??_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ@4HA
	DD	00H
	DD	imagerel ?dtor$19@?0??_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ@4HA
	DD	00H
	DD	imagerel ?dtor$3@?0??_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ@4HA
	DD	00H
	DD	imagerel ?dtor$23@?0??_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ@4HA
	DD	00H
	DD	imagerel ?dtor$4@?0??_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ@4HA
	DD	00H
	DD	imagerel ?dtor$27@?0??_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$61@?0??_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ DD 019930522H
	DD	0aH
	DD	imagerel $stateUnwindMap$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ
	DD	00H
	DD	00H
	DD	011H
	DD	imagerel $ip2state$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ
	DD	0b0H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ DD 0a2111H
	DD	0190119H
	DD	0e00bf00dH
	DD	0c007d009H
	DD	060047005H
	DD	050023003H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@12@@Z DD 040801H
	DD	070043208H
	DD	030026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAXAEBVlocale@2@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z DD 021H
	DD	imagerel $LN20
	DD	imagerel $LN20+65
	DD	imagerel $unwind$?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z DD 020521H
	DD	097405H
	DD	imagerel $LN20
	DD	imagerel $LN20+65
	DD	imagerel $unwind$?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z DD 040a01H
	DD	0a340aH
	DD	06006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z DD 081501H
	DD	097415H
	DD	086415H
	DD	073415H
	DD	0e0113215H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z DD 081401H
	DD	096414H
	DD	085414H
	DD	073414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD imagerel ?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
	DD	0ffffffffH
	DD	imagerel ?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ+197
	DD	00H
	DD	imagerel ?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ+270
	DD	01H
	DD	imagerel ?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ+450
	DD	02H
	DD	imagerel ?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ+466
	DD	03H
	DD	imagerel ?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ+548
	DD	04H
	DD	imagerel ?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ+668
	DD	05H
	DD	imagerel ?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ+780
	DD	01H
	DD	imagerel ?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ+846
	DD	08H
	DD	imagerel ?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ+873
	DD	09H
	DD	imagerel ?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ+988
	DD	01H
	DD	imagerel ?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ+1020
	DD	0aH
	DD	imagerel ?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ+1063
	DD	0bH
	DD	imagerel ?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ+1180
	DD	01H
	DD	imagerel ?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ+1191
	DD	06H
	DD	imagerel ?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ+1207
	DD	07H
	DD	imagerel ?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ+1324
	DD	01H
	DD	imagerel ?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ+1395
	DD	0ffffffffH
	DD	imagerel ?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ+1439
	DD	0cH
	DD	imagerel ?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ+1549
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD 0ffffffffH
	DD	imagerel ?dtor$10@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$0@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA
	DD	01H
	DD	imagerel ?dtor$1@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA
	DD	02H
	DD	imagerel ?dtor$2@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA
	DD	02H
	DD	imagerel ?dtor$152@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA
	DD	01H
	DD	imagerel ?dtor$156@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA
	DD	01H
	DD	imagerel ?dtor$3@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA
	DD	01H
	DD	imagerel ?dtor$164@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA
	DD	01H
	DD	imagerel ?dtor$4@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA
	DD	01H
	DD	imagerel ?dtor$169@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA
	DD	01H
	DD	imagerel ?dtor$5@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA
	DD	01H
	DD	imagerel ?dtor$177@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$213@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA
	DD	0cH
	DD	imagerel ?dtor$230@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD 019930522H
	DD	0eH
	DD	imagerel $stateUnwindMap$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
	DD	00H
	DD	00H
	DD	014H
	DD	imagerel $ip2state$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
	DD	0c0H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD 091f11H
	DD	01a0117H
	DD	0e009f00bH
	DD	07005c007H
	DD	030036004H
	DD	05002H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD 020021H
	DD	067400H
	DD	imagerel $LN26
	DD	imagerel $LN26+51
	DD	imagerel $unwind$?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD 020521H
	DD	067405H
	DD	imagerel $LN26
	DD	imagerel $LN26+51
	DD	imagerel $unwind$?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$4@?0??overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z DD imagerel ?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z
	DD	0ffffffffH
	DD	imagerel ?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z+256
	DD	00H
	DD	imagerel ?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z+272
	DD	01H
	DD	imagerel ?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z+288
	DD	02H
	DD	imagerel ?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z+367
	DD	03H
	DD	imagerel ?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z+477
	DD	04H
	DD	imagerel ?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z+588
	DD	00H
	DD	imagerel ?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z+619
	DD	05H
	DD	imagerel ?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z+634
	DD	06H
	DD	imagerel ?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z+748
	DD	00H
	DD	imagerel ?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z+767
	DD	07H
	DD	imagerel ?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z+820
	DD	00H
	DD	imagerel ?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z+830
	DD	08H
	DD	imagerel ?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z+940
	DD	00H
	DD	imagerel ?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z+1037
	DD	0ffffffffH
	DD	imagerel ?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z+1081
	DD	09H
	DD	imagerel ?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z+1194
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0??overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z@4HA
	DD	01H
	DD	imagerel ?dtor$2@?0??overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z@4HA
	DD	01H
	DD	imagerel ?dtor$22@?0??overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z@4HA
	DD	00H
	DD	imagerel ?dtor$26@?0??overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z@4HA
	DD	00H
	DD	imagerel ?dtor$3@?0??overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z@4HA
	DD	00H
	DD	imagerel ?dtor$30@?0??overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z@4HA
	DD	00H
	DD	imagerel ?dtor$4@?0??overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z@4HA
	DD	00H
	DD	imagerel ?dtor$34@?0??overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$76@?0??overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z DD 019930522H
	DD	0aH
	DD	imagerel $stateUnwindMap$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z
	DD	00H
	DD	00H
	DD	011H
	DD	imagerel $ip2state$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z
	DD	0d0H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z DD 0b2811H
	DD	0243428H
	DD	01c0118H
	DD	0e00af00cH
	DD	0c006d008H
	DD	060037004H
	DD	05002H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z DD imagerel ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z
	DD	0ffffffffH
	DD	imagerel ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z+208
	DD	00H
	DD	imagerel ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z+252
	DD	01H
	DD	imagerel ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z+288
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$1@?0??open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z
	DD	00H
	DD	00H
	DD	04H
	DD	imagerel $ip2state$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z
	DD	038H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z DD 061911H
	DD	0c6419H
	DD	0b3414H
	DD	070027206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ DD imagerel ??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
	DD	0ffffffffH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
	DD	020H
	DD	00H
	DD	05H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ DD 020f19H
	DD	030025206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@PEAU_iobuf@@@Z DD imagerel ??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@PEAU_iobuf@@@Z
	DD	0ffffffffH
	DD	imagerel ??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@PEAU_iobuf@@@Z+34
	DD	00H
	DD	imagerel ??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@PEAU_iobuf@@@Z+168
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@PEAU_iobuf@@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@PEAU_iobuf@@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@PEAU_iobuf@@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@PEAU_iobuf@@@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@PEAU_iobuf@@@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@PEAU_iobuf@@@Z DD 041511H
	DD	07008520cH
	DD	030066007H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@PEAU_iobuf@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?close@?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?open@?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXPEBDHH@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel ??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DD	0ffffffffH
	DD	imagerel ??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ+74
	DD	00H
	DD	imagerel ??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ+102
	DD	01H
	DD	imagerel ??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ+152
	DD	02H
	DD	imagerel ??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ+209
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0???0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA
	DD	01H
	DD	imagerel ?dtor$3@?0???0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 019930522H
	DD	03H
	DD	imagerel $stateUnwindMap$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DD	00H
	DD	00H
	DD	05H
	DD	imagerel $ip2state$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 041811H
	DD	0b3418H
	DD	07006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
CONST	SEGMENT
$cppxdata$main DD 019930522H
	DD	05H
	DD	imagerel $stateUnwindMap$main
	DD	00H
	DD	00H
	DD	0aH
	DD	imagerel $ip2state$main
	DD	01a0H
	DD	00H
	DD	01H
	ORG $+8
?S1@@3QBEB DB	0eH					; S1
	DB	04H
	DB	0dH
	DB	01H
	DB	02H
	DB	0fH
	DB	0bH
	DB	08H
	DB	03H
	DB	0aH
	DB	06H
	DB	0cH
	DB	05H
	DB	09H
	DB	00H
	DB	07H
	DB	00H
	DB	0fH
	DB	07H
	DB	04H
	DB	0eH
	DB	02H
	DB	0dH
	DB	01H
	DB	0aH
	DB	06H
	DB	0cH
	DB	0bH
	DB	09H
	DB	05H
	DB	03H
	DB	08H
	DB	04H
	DB	01H
	DB	0eH
	DB	08H
	DB	0dH
	DB	06H
	DB	02H
	DB	0bH
	DB	0fH
	DB	0cH
	DB	09H
	DB	07H
	DB	03H
	DB	0aH
	DB	05H
	DB	00H
	DB	0fH
	DB	0cH
	DB	08H
	DB	02H
	DB	04H
	DB	09H
	DB	01H
	DB	07H
	DB	05H
	DB	0bH
	DB	03H
	DB	0eH
	DB	0aH
	DB	00H
	DB	06H
	DB	0dH
?S2@@3QBEB DB	0fH					; S2
	DB	01H
	DB	08H
	DB	0eH
	DB	06H
	DB	0bH
	DB	03H
	DB	04H
	DB	09H
	DB	07H
	DB	02H
	DB	0dH
	DB	0cH
	DB	00H
	DB	05H
	DB	0aH
	DB	03H
	DB	0dH
	DB	04H
	DB	07H
	DB	0fH
	DB	02H
	DB	08H
	DB	0eH
	DB	0cH
	DB	00H
	DB	01H
	DB	0aH
	DB	06H
	DB	09H
	DB	0bH
	DB	05H
	DB	00H
	DB	0eH
	DB	07H
	DB	0bH
	DB	0aH
	DB	04H
	DB	0dH
	DB	01H
	DB	05H
	DB	08H
	DB	0cH
	DB	06H
	DB	09H
	DB	03H
	DB	02H
	DB	0fH
	DB	0dH
	DB	08H
	DB	0aH
	DB	01H
	DB	03H
	DB	0fH
	DB	04H
	DB	02H
	DB	0bH
	DB	06H
	DB	07H
	DB	0cH
	DB	00H
	DB	05H
	DB	0eH
	DB	09H
?S3@@3QBEB DB	0aH					; S3
	DB	00H
	DB	09H
	DB	0eH
	DB	06H
	DB	03H
	DB	0fH
	DB	05H
	DB	01H
	DB	0dH
	DB	0cH
	DB	07H
	DB	0bH
	DB	04H
	DB	02H
	DB	08H
	DB	0dH
	DB	07H
	DB	00H
	DB	09H
	DB	03H
	DB	04H
	DB	06H
	DB	0aH
	DB	02H
	DB	08H
	DB	05H
	DB	0eH
	DB	0cH
	DB	0bH
	DB	0fH
	DB	01H
	DB	0dH
	DB	06H
	DB	04H
	DB	09H
	DB	08H
	DB	0fH
	DB	03H
	DB	00H
	DB	0bH
	DB	01H
	DB	02H
	DB	0cH
	DB	05H
	DB	0aH
	DB	0eH
	DB	07H
	DB	01H
	DB	0aH
	DB	0dH
	DB	00H
	DB	06H
	DB	09H
	DB	08H
	DB	07H
	DB	04H
	DB	0fH
	DB	0eH
	DB	03H
	DB	0bH
	DB	05H
	DB	02H
	DB	0cH
?S4@@3QBEB DB	07H					; S4
	DB	0dH
	DB	0eH
	DB	03H
	DB	00H
	DB	06H
	DB	09H
	DB	0aH
	DB	01H
	DB	02H
	DB	08H
	DB	05H
	DB	0bH
	DB	0cH
	DB	04H
	DB	0fH
	DB	0dH
	DB	08H
	DB	0bH
	DB	05H
	DB	06H
	DB	0fH
	DB	00H
	DB	03H
	DB	04H
	DB	07H
	DB	02H
	DB	0cH
	DB	01H
	DB	0aH
	DB	0eH
	DB	09H
	DB	0aH
	DB	06H
	DB	09H
	DB	00H
	DB	0cH
	DB	0bH
	DB	07H
	DB	0dH
	DB	0fH
	DB	01H
	DB	03H
	DB	0eH
	DB	05H
	DB	02H
	DB	08H
	DB	04H
	DB	03H
	DB	0fH
	DB	00H
	DB	06H
	DB	0aH
	DB	01H
	DB	0dH
	DB	08H
	DB	09H
	DB	04H
	DB	05H
	DB	0bH
	DB	0cH
	DB	07H
	DB	02H
	DB	0eH
?S5@@3QBEB DB	02H					; S5
	DB	0cH
	DB	04H
	DB	01H
	DB	07H
	DB	0aH
	DB	0bH
	DB	06H
	DB	08H
	DB	05H
	DB	03H
	DB	0fH
	DB	0dH
	DB	00H
	DB	0eH
	DB	09H
	DB	0eH
	DB	0bH
	DB	02H
	DB	0cH
	DB	04H
	DB	07H
	DB	0dH
	DB	01H
	DB	05H
	DB	00H
	DB	0fH
	DB	0aH
	DB	03H
	DB	09H
	DB	08H
	DB	06H
	DB	04H
	DB	02H
	DB	01H
	DB	0bH
	DB	0aH
	DB	0dH
	DB	07H
	DB	08H
	DB	0fH
	DB	09H
	DB	0cH
	DB	05H
	DB	06H
	DB	03H
	DB	00H
	DB	0eH
	DB	0bH
	DB	08H
	DB	0cH
	DB	07H
	DB	01H
	DB	0eH
	DB	02H
	DB	0dH
	DB	06H
	DB	0fH
	DB	00H
	DB	09H
	DB	0aH
	DB	04H
	DB	05H
	DB	03H
?S6@@3QBEB DB	0cH					; S6
	DB	01H
	DB	0aH
	DB	0fH
	DB	09H
	DB	02H
	DB	06H
	DB	08H
	DB	00H
	DB	0dH
	DB	03H
	DB	04H
	DB	0eH
	DB	07H
	DB	05H
	DB	0bH
	DB	0aH
	DB	0fH
	DB	04H
	DB	02H
	DB	07H
	DB	0cH
	DB	09H
	DB	05H
	DB	06H
	DB	01H
	DB	0dH
	DB	0eH
	DB	00H
	DB	0bH
	DB	03H
	DB	08H
	DB	09H
	DB	0eH
	DB	0fH
	DB	05H
	DB	02H
	DB	08H
	DB	0cH
	DB	03H
	DB	07H
	DB	00H
	DB	04H
	DB	0aH
	DB	01H
	DB	0dH
	DB	0bH
	DB	06H
	DB	04H
	DB	03H
	DB	02H
	DB	0cH
	DB	09H
	DB	05H
	DB	0fH
	DB	0aH
	DB	0bH
	DB	0eH
	DB	01H
	DB	07H
	DB	06H
	DB	00H
	DB	08H
	DB	0dH
?S7@@3QBEB DB	04H					; S7
	DB	0bH
	DB	02H
	DB	0eH
	DB	0fH
	DB	00H
	DB	08H
	DB	0dH
	DB	03H
	DB	0cH
	DB	09H
	DB	07H
	DB	05H
	DB	0aH
	DB	06H
	DB	01H
	DB	0dH
	DB	00H
	DB	0bH
	DB	07H
	DB	04H
	DB	09H
	DB	01H
	DB	0aH
	DB	0eH
	DB	03H
	DB	05H
	DB	0cH
	DB	02H
	DB	0fH
	DB	08H
	DB	06H
	DB	01H
	DB	04H
	DB	0bH
	DB	0dH
	DB	0cH
	DB	03H
	DB	07H
	DB	0eH
	DB	0aH
	DB	0fH
	DB	06H
	DB	08H
	DB	00H
	DB	05H
	DB	09H
	DB	02H
	DB	06H
	DB	0bH
	DB	0dH
	DB	08H
	DB	01H
	DB	04H
	DB	0aH
	DB	07H
	DB	09H
	DB	05H
	DB	00H
	DB	0fH
	DB	0eH
	DB	02H
	DB	03H
	DB	0cH
?S8@@3QBEB DB	0dH					; S8
	DB	02H
	DB	08H
	DB	04H
	DB	06H
	DB	0fH
	DB	0bH
	DB	01H
	DB	0aH
	DB	09H
	DB	03H
	DB	0eH
	DB	05H
	DB	00H
	DB	0cH
	DB	07H
	DB	01H
	DB	0fH
	DB	0dH
	DB	08H
	DB	0aH
	DB	03H
	DB	07H
	DB	04H
	DB	0cH
	DB	05H
	DB	06H
	DB	0bH
	DB	00H
	DB	0eH
	DB	09H
	DB	02H
	DB	07H
	DB	0bH
	DB	04H
	DB	01H
	DB	09H
	DB	0cH
	DB	0eH
	DB	02H
	DB	00H
	DB	06H
	DB	0aH
	DB	0dH
	DB	0fH
	DB	03H
	DB	05H
	DB	08H
	DB	02H
	DB	01H
	DB	0eH
	DB	07H
	DB	04H
	DB	0aH
	DB	08H
	DB	0dH
	DB	0fH
	DB	0cH
	DB	09H
	DB	00H
	DB	03H
	DB	05H
	DB	06H
	DB	0bH
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA DD 020a19H
	DD	05006320aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DD imagerel ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
	DD	0ffffffffH
	DD	imagerel ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z+127
	DD	00H
	DD	imagerel ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z+181
	DD	01H
	DD	imagerel ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z+195
	DD	02H
	DD	imagerel ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z+359
	DD	01H
	DD	imagerel ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z+397
	DD	04H
	DD	imagerel ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z+417
	DD	05H
	DD	imagerel ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z+442
	DD	0ffffffffH
	DD	imagerel ?catch$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
	DD	00H
	DD	imagerel ?catch$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA+13
	DD	03H
	DD	imagerel ?catch$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA+42
	DD	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$0$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DD 040H
	DD	00H
	DD	00H
	DD	imagerel ?catch$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
	DD	038H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	imagerel $handlerMap$0$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DD 0ffffffffH
	DD	imagerel ?dtor$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	imagerel ?dtor$6@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
	DD	04H
	DD	imagerel ?dtor$7@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DD 019930522H
	DD	06H
	DD	imagerel $stateUnwindMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
	DD	01H
	DD	imagerel $tryMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
	DD	0bH
	DD	imagerel $ip2state$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DD 082219H
	DD	0103422H
	DD	0f00d7211H
	DD	0c009e00bH
	DD	060067007H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
xdata	ENDS
xdata	SEGMENT
$unwind$?errorWithMessage@@YAXPEAD@Z DD 020601H
	DD	030023206H
$unwind$?init@@YAXHQEAPEAD@Z DD 010401H
	DD	04204H
$unwind$?compressPermuteKey@@YA_K_K@Z DD 081401H
	DD	047414H
	DD	03640fH
	DD	02540aH
	DD	013405H
$unwind$?permutation1@@YA_K_K@Z DD 0c1c01H
	DD	08741cH
	DD	07641cH
	DD	06541cH
	DD	05341cH
	DD	0e01af01cH
	DD	0c016d018H
$unwind$?finalPermutation@@YA_K_K@Z DD 0c1c01H
	DD	08741cH
	DD	07641cH
	DD	06541cH
	DD	05341cH
	DD	0e01af01cH
	DD	0c016d018H
$unwind$?runIt@@YA_K_KH@Z DD 0c1c01H
	DD	08741cH
	DD	07641cH
	DD	06541cH
	DD	05341cH
	DD	0e01af01cH
	DD	0c016d018H
$unwind$main DD	0d3311H
	DD	02f6833H
	DD	068342fH
	DD	0600120H
	DD	0e010f012H
	DD	0c00cd00eH
	DD	06009700aH
	DD	05008H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$main
$stateUnwindMap$main DD 0ffffffffH
	DD	imagerel main$dtor$2
	DD	00H
	DD	imagerel main$dtor$3
	DD	01H
	DD	imagerel main$dtor$5
	DD	0ffffffffH
	DD	imagerel main$dtor$0
	DD	03H
	DD	imagerel main$dtor$1
$ip2state$main DD imagerel main
	DD	0ffffffffH
	DD	imagerel main+123
	DD	00H
	DD	imagerel main+151
	DD	01H
	DD	imagerel main+209
	DD	02H
	DD	imagerel main+257
	DD	03H
	DD	imagerel main+372
	DD	04H
	DD	imagerel main+6768
	DD	03H
	DD	imagerel main+6857
	DD	0ffffffffH
	DD	imagerel main+6924
	DD	04H
	DD	imagerel main+7145
	DD	0ffffffffH
$unwind$main$dtor$2 DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Ungetc@D@std@@YA_NAEBDPEAU_iobuf@@@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Fputc@D@std@@YA_NDPEAU_iobuf@@@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Fgetc@D@std@@YA_NAEADPEAU_iobuf@@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getfacet@locale@std@@QEBAPEBVfacet@12@_K@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1locale@std@@QEAA@XZ DD imagerel ??1locale@std@@QEAA@XZ
	DD	0ffffffffH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1locale@std@@QEAA@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??1locale@std@@QEAA@XZ
	DD	020H
	DD	00H
	DD	05H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1locale@std@@QEAA@XZ DD 010d19H
	DD	06204H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??1locale@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gbad_cast@std@@UEAAPEAXI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_cast@std@@QEAA@AEBV01@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Check_offset@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAX_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_N_K@Z DD 021H
	DD	imagerel $LN120
	DD	imagerel $LN120+31
	DD	imagerel $unwind$?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_N_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_N_K@Z DD 020521H
	DD	066405H
	DD	imagerel $LN120
	DD	imagerel $LN120+31
	DD	imagerel $unwind$?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_N_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_N_K@Z DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA_N_K_N@Z DD 020021H
	DD	067400H
	DD	imagerel $LN104
	DD	imagerel $LN104+29
	DD	imagerel $unwind$?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA_N_K_N@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA_N_K_N@Z DD 020021H
	DD	067400H
	DD	imagerel $LN104
	DD	imagerel $LN104+29
	DD	imagerel $unwind$?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA_N_K_N@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA_N_K_N@Z DD 020521H
	DD	067405H
	DD	imagerel $LN104
	DD	imagerel $LN104+29
	DD	imagerel $unwind$?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA_N_K_N@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA_N_K_N@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$0@?0??_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z@4HA DD 030b19H
	DD	05007420bH
	DD	03006H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$1@?0??_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z@4HA DD 020a19H
	DD	05006320aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z DD imagerel ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z
	DD	0ffffffffH
	DD	imagerel ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z+110
	DD	00H
	DD	imagerel ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z+130
	DD	0ffffffffH
	DD	imagerel ?catch$1@?0??_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z@4HA
	DD	00H
	DD	imagerel ?catch$1@?0??_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z@4HA+13
	DD	01H
	DD	imagerel ?catch$1@?0??_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z@4HA+21
	DD	02H
	DD	imagerel ?catch$1@?0??_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z@4HA+41
	DD	00H
	DD	imagerel ?catch$0@?0??_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z@4HA+14
	DD	03H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$1$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z DD 040H
	DD	00H
	DD	00H
	DD	imagerel ?catch$0@?0??_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z@4HA
	DD	048H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$0$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z DD 040H
	DD	00H
	DD	00H
	DD	imagerel ?catch$1@?0??_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z@4HA
	DD	038H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z DD 00H
	DD	00H
	DD	03H
	DD	01H
	DD	imagerel $handlerMap$0$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	imagerel $handlerMap$1$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z DD 019930522H
	DD	04H
	DD	imagerel $stateUnwindMap$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z
	DD	02H
	DD	imagerel $tryMap$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z
	DD	08H
	DD	imagerel $ip2state$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z DD 052119H
	DD	0e0146218H
	DD	060117012H
	DD	03010H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ DD imagerel ?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ
	DD	0ffffffffH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ
	DD	020H
	DD	00H
	DD	05H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ DD 041419H
	DD	083414H
	DD	070025206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K0@Z DD 021H
	DD	imagerel $LN128
	DD	imagerel $LN128+112
	DD	imagerel $unwind$?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K0@Z DD 020521H
	DD	067405H
	DD	imagerel $LN128
	DD	imagerel $LN128+112
	DD	imagerel $unwind$?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K0@Z DD 040a01H
	DD	07340aH
	DD	06006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z DD 021H
	DD	imagerel $LN188
	DD	imagerel $LN188+89
	DD	imagerel $unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z DD 020021H
	DD	066400H
	DD	imagerel $LN188
	DD	imagerel $LN188+89
	DD	imagerel $unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z DD 021H
	DD	imagerel $LN188
	DD	imagerel $LN188+89
	DD	imagerel $unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z DD 020521H
	DD	066405H
	DD	imagerel $LN188
	DD	imagerel $LN188+89
	DD	imagerel $unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z DD 060f01H
	DD	08540fH
	DD	07340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z DD 021H
	DD	imagerel $LN218
	DD	imagerel $LN218+121
	DD	imagerel $unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z DD 020021H
	DD	077400H
	DD	imagerel $LN218
	DD	imagerel $LN218+121
	DD	imagerel $unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z DD 021H
	DD	imagerel $LN218
	DD	imagerel $LN218+121
	DD	imagerel $unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z DD 020521H
	DD	077405H
	DD	imagerel $LN218
	DD	imagerel $LN218+121
	DD	imagerel $unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z DD 083d01H
	DD	06643dH
	DD	095410H
	DD	083410H
	DD	0e00c3210H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DD	0ffffffffH
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ+83
	DD	00H
	DD	imagerel ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ+101
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD 0ffffffffH
	DD	imagerel ?dtor$32@?0???1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DD	020H
	DD	00H
	DD	05H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD 020f19H
	DD	030025206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z DD imagerel ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z
	DD	0ffffffffH
	DD	imagerel ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z+57
	DD	00H
	DD	imagerel ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z+91
	DD	01H
	DD	imagerel ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z+139
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z DD 0ffffffffH
	DD	imagerel ?dtor$1@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z
	DD	00H
	DD	00H
	DD	04H
	DD	imagerel $ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z DD 082211H
	DD	0b6422H
	DD	0a541dH
	DD	093418H
	DD	07006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD imagerel ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DD	0ffffffffH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
	DD	020H
	DD	00H
	DD	05H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD 041419H
	DD	083414H
	DD	070025206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Orphan_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Free_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAXXZ DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Alloc_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAA@XZ DD imagerel ??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAA@XZ
	DD	0ffffffffH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAA@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAA@XZ
	DD	020H
	DD	00H
	DD	05H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAA@XZ DD 020f19H
	DD	030025206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAA@XZ DD imagerel ??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAA@XZ
	DD	0ffffffffH
	DD	imagerel ??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAA@XZ+35
	DD	00H
	DD	imagerel ??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAA@XZ+69
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAA@XZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAA@XZ DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAA@XZ
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAA@XZ
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAA@XZ DD 021311H
	DD	03006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Deallocate@std@@YAXPEAX_K1@Z DD 0a1a01H
	DD	0b741aH
	DD	0a641aH
	DD	09541aH
	DD	08341aH
	DD	0e016521aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?_Allocate@std@@YAPEAX_K0_N@Z DD 020021H
	DD	083400H
	DD	imagerel $LN17
	DD	imagerel $LN17+44
	DD	imagerel $unwind$?_Allocate@std@@YAPEAX_K0_N@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?_Allocate@std@@YAPEAX_K0_N@Z DD 043321H
	DD	067433H
	DD	083405H
	DD	imagerel $LN17
	DD	imagerel $LN17+44
	DD	imagerel $unwind$?_Allocate@std@@YAPEAX_K0_N@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Allocate@std@@YAPEAX_K0_N@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Orphan_me@_Iterator_base12@std@@QEAAXXZ DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Adopt@_Iterator_base12@std@@QEAAXPEBU_Container_base12@2@@Z DD imagerel ?_Adopt@_Iterator_base12@std@@QEAAXPEBU_Container_base12@2@@Z
	DD	0ffffffffH
	DD	imagerel ?_Adopt@_Iterator_base12@std@@QEAAXPEBU_Container_base12@2@@Z+45
	DD	00H
	DD	imagerel ?_Adopt@_Iterator_base12@std@@QEAAXPEBU_Container_base12@2@@Z+54
	DD	0ffffffffH
	DD	imagerel ?_Adopt@_Iterator_base12@std@@QEAAXPEBU_Container_base12@2@@Z+81
	DD	01H
	DD	imagerel ?_Adopt@_Iterator_base12@std@@QEAAXPEBU_Container_base12@2@@Z+104
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?_Adopt@_Iterator_base12@std@@QEAAXPEBU_Container_base12@2@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??_Adopt@_Iterator_base12@std@@QEAAXPEBU_Container_base12@2@@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$1@?0??_Adopt@_Iterator_base12@std@@QEAAXPEBU_Container_base12@2@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?_Adopt@_Iterator_base12@std@@QEAAXPEBU_Container_base12@2@@Z DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$?_Adopt@_Iterator_base12@std@@QEAAXPEBU_Container_base12@2@@Z
	DD	00H
	DD	00H
	DD	05H
	DD	imagerel $ip2state$?_Adopt@_Iterator_base12@std@@QEAAXPEBU_Container_base12@2@@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Adopt@_Iterator_base12@std@@QEAAXPEBU_Container_base12@2@@Z DD 041411H
	DD	083414H
	DD	070025206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?_Adopt@_Iterator_base12@std@@QEAAXPEBU_Container_base12@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1_Iterator_base12@std@@QEAA@XZ DD imagerel ??1_Iterator_base12@std@@QEAA@XZ
	DD	0ffffffffH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1_Iterator_base12@std@@QEAA@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??1_Iterator_base12@std@@QEAA@XZ
	DD	020H
	DD	00H
	DD	05H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1_Iterator_base12@std@@QEAA@XZ DD 020f19H
	DD	030025206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??1_Iterator_base12@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Orphan_all@_Container_base12@std@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1_Container_base12@std@@QEAA@XZ DD imagerel ??1_Container_base12@std@@QEAA@XZ
	DD	0ffffffffH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1_Container_base12@std@@QEAA@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??1_Container_base12@std@@QEAA@XZ
	DD	020H
	DD	00H
	DD	05H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1_Container_base12@std@@QEAA@XZ DD 020f19H
	DD	030025206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??1_Container_base12@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?assign@?$char_traits@D@std@@SAPEADPEAD_KD@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?copy@?$char_traits@D@std@@SAPEADPEADPEBD_K@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gexception@std@@UEAAPEAXI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0exception@std@@QEAA@AEBV01@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$memcpy_s DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_E?$basic_fstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@EAAPEAXI@Z
_TEXT	SEGMENT
??_E?$basic_fstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@EAAPEAXI@Z PROC ; std::basic_fstream<char,std::char_traits<char> >::`vector deleting destructor', COMDAT
  00000	48 63 41 fc	 movsxd	 rax, DWORD PTR [rcx-4]
  00004	48 2b c8	 sub	 rcx, rax
  00007	e9 00 00 00 00	 jmp	 ??_E?$basic_fstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z
??_E?$basic_fstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@EAAPEAXI@Z ENDP ; std::basic_fstream<char,std::char_traits<char> >::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QEAAXPEAU_Container_proxy@1@$$QEAU21@@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QEAAXPEAU_Container_proxy@1@$$QEAU21@@Z PROC ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>, COMDAT

; 637  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00000	48 85 d2	 test	 rdx, rdx
  00003	74 07		 je	 SHORT $LN3@construct
  00005	41 0f 10 00	 movups	 xmm0, XMMWORD PTR [r8]
  00009	0f 11 02	 movups	 XMMWORD PTR [rdx], xmm0
$LN3@construct:

; 638  : 		}

  0000c	c3		 ret	 0
??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QEAAXPEAU_Container_proxy@1@$$QEAU21@@Z ENDP ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAAXPEAU_Container_proxy@1@@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAAXPEAU_Container_proxy@1@@Z PROC ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>, COMDAT

; 644  : 		_Ptr->~_Uty();
; 645  : 		}

  00000	c2 00 00	 ret	 0
??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QEAAXPEAU_Container_proxy@1@@Z ENDP ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PEADAEAPEAD@?$allocator@D@std@@QEAAXPEAPEADAEAPEAD@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@PEADAEAPEAD@?$allocator@D@std@@QEAAXPEAPEADAEAPEAD@Z PROC ; std::allocator<char>::construct<char * __ptr64,char * __ptr64 & __ptr64>, COMDAT

; 637  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00000	48 85 d2	 test	 rdx, rdx
  00003	74 06		 je	 SHORT $LN3@construct
  00005	49 8b 00	 mov	 rax, QWORD PTR [r8]
  00008	48 89 02	 mov	 QWORD PTR [rdx], rax
$LN3@construct:

; 638  : 		}

  0000b	c3		 ret	 0
??$construct@PEADAEAPEAD@?$allocator@D@std@@QEAAXPEAPEADAEAPEAD@Z ENDP ; std::allocator<char>::construct<char * __ptr64,char * __ptr64 & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PEAD@?$allocator@D@std@@QEAAXPEAPEAD@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
??$destroy@PEAD@?$allocator@D@std@@QEAAXPEAPEAD@Z PROC	; std::allocator<char>::destroy<char * __ptr64>, COMDAT

; 644  : 		_Ptr->~_Uty();
; 645  : 		}

  00000	c2 00 00	 ret	 0
??$destroy@PEAD@?$allocator@D@std@@QEAAXPEAPEAD@Z ENDP	; std::allocator<char>::destroy<char * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@1@PEAU_Container_proxy@1@$$QEAU31@@Z
_TEXT	SEGMENT
_Al$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@1@PEAU_Container_proxy@1@$$QEAU31@@Z PROC ; std::allocator_traits<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>, COMDAT

; 637  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00000	48 85 d2	 test	 rdx, rdx
  00003	74 07		 je	 SHORT $LN8@construct
  00005	41 0f 10 00	 movups	 xmm0, XMMWORD PTR [r8]
  00009	0f 11 02	 movups	 XMMWORD PTR [rdx], xmm0
$LN8@construct:

; 755  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 756  : 		}

  0000c	c3		 ret	 0
??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@1@PEAU_Container_proxy@1@$$QEAU31@@Z ENDP ; std::allocator_traits<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@U_Container_proxy@std@@@std@@YA$$QEAU_Container_proxy@0@AEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@U_Container_proxy@std@@@std@@YA$$QEAU_Container_proxy@0@AEAU10@@Z PROC ; std::forward<std::_Container_proxy>, COMDAT

; 1299 : 	return (static_cast<_Ty&&>(_Arg));

  00000	48 8b c1	 mov	 rax, rcx

; 1300 : 	}

  00003	c3		 ret	 0
??$forward@U_Container_proxy@std@@@std@@YA$$QEAU_Container_proxy@0@AEAU10@@Z ENDP ; std::forward<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@1@PEAU_Container_proxy@1@@Z
_TEXT	SEGMENT
_Al$ = 8
_Ptr$ = 16
??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@1@PEAU_Container_proxy@1@@Z PROC ; std::allocator_traits<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>, COMDAT

; 762  : 		_Al.destroy(_Ptr);
; 763  : 		}

  00000	c2 00 00	 ret	 0
??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAEAV?$allocator@U_Container_proxy@std@@@1@PEAU_Container_proxy@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?0D@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@D@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
??$?0D@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@D@1@@Z PROC ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>, COMDAT

; 610  : 		}

  00000	48 8b c1	 mov	 rax, rcx
  00003	c3		 ret	 0
??$?0D@?$allocator@U_Container_proxy@std@@@std@@QEAA@AEBV?$allocator@D@1@@Z ENDP ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AEAU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAAEAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AEAU10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAAEAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AEAU10@@Z PROC ; std::forward<std::_Wrap_alloc<std::allocator<char> > & __ptr64>, COMDAT

; 1299 : 	return (static_cast<_Ty&&>(_Arg));

  00000	48 8b c1	 mov	 rax, rcx

; 1300 : 	}

  00003	c3		 ret	 0
??$forward@AEAU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAAEAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AEAU10@@Z ENDP ; std::forward<std::_Wrap_alloc<std::allocator<char> > & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PEADAEAPEAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAEAV?$allocator@D@1@PEAPEADAEAPEAD@Z
_TEXT	SEGMENT
_Al$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@PEADAEAPEAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAEAV?$allocator@D@1@PEAPEADAEAPEAD@Z PROC ; std::allocator_traits<std::allocator<char> >::construct<char * __ptr64,char * __ptr64 & __ptr64>, COMDAT

; 637  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00000	48 85 d2	 test	 rdx, rdx
  00003	74 06		 je	 SHORT $LN8@construct
  00005	49 8b 00	 mov	 rax, QWORD PTR [r8]
  00008	48 89 02	 mov	 QWORD PTR [rdx], rax
$LN8@construct:

; 755  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 756  : 		}

  0000b	c3		 ret	 0
??$construct@PEADAEAPEAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAEAV?$allocator@D@1@PEAPEADAEAPEAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::construct<char * __ptr64,char * __ptr64 & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AEAPEAD@std@@YAAEAPEADAEAPEAD@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEAPEAD@std@@YAAEAPEADAEAPEAD@Z PROC		; std::forward<char * __ptr64 & __ptr64>, COMDAT

; 1299 : 	return (static_cast<_Ty&&>(_Arg));

  00000	48 8b c1	 mov	 rax, rcx

; 1300 : 	}

  00003	c3		 ret	 0
??$forward@AEAPEAD@std@@YAAEAPEADAEAPEAD@Z ENDP		; std::forward<char * __ptr64 & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Addressof@D@std@@YAPEADAEADU?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
_Val$ = 8
__formal$ = 16
??$_Addressof@D@std@@YAPEADAEADU?$integral_constant@_N$0A@@0@@Z PROC ; std::_Addressof<char>, COMDAT

; 708  : 	return (reinterpret_cast<_Ty *>(

  00000	48 8b c1	 mov	 rax, rcx

; 709  : 		&const_cast<char&>(
; 710  : 		reinterpret_cast<const volatile char&>(_Val))));
; 711  : 	}

  00003	c3		 ret	 0
??$_Addressof@D@std@@YAPEADAEADU?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Addressof<char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PEAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAEAV?$allocator@D@1@PEAPEAD@Z
_TEXT	SEGMENT
_Al$ = 8
_Ptr$ = 16
??$destroy@PEAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAEAV?$allocator@D@1@PEAPEAD@Z PROC ; std::allocator_traits<std::allocator<char> >::destroy<char * __ptr64>, COMDAT

; 762  : 		_Al.destroy(_Ptr);
; 763  : 		}

  00000	c2 00 00	 ret	 0
??$destroy@PEAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAEAV?$allocator@D@1@PEAPEAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::destroy<char * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAAXPEAU_Container_proxy@1@$$QEAU21@@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAAXPEAU_Container_proxy@1@$$QEAU21@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>, COMDAT

; 637  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00000	48 85 d2	 test	 rdx, rdx
  00003	74 07		 je	 SHORT $LN13@construct
  00005	41 0f 10 00	 movups	 xmm0, XMMWORD PTR [r8]
  00009	0f 11 02	 movups	 XMMWORD PTR [rdx], xmm0
$LN13@construct:

; 893  : 		_Mytraits::construct(*this, _Ptr,
; 894  : 			_STD forward<_Types>(_Args)...);
; 895  : 		}

  0000c	c3		 ret	 0
??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAAXPEAU_Container_proxy@1@$$QEAU21@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAAXPEAU_Container_proxy@1@@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAAXPEAU_Container_proxy@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>, COMDAT

; 901  : 		_Mytraits::destroy(*this, _Ptr);
; 902  : 		}

  00000	c2 00 00	 ret	 0
??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAAXPEAU_Container_proxy@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?0AEAU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@AEAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??$?0AEAU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@AEAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::_Wrap_alloc<std::allocator<std::_Container_proxy> ><std::_Wrap_alloc<std::allocator<char> > & __ptr64>, COMDAT

; 851  : 		}

  00000	48 8b c1	 mov	 rax, rcx
  00003	c3		 ret	 0
??$?0AEAU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAA@AEAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::_Wrap_alloc<std::allocator<std::_Container_proxy> ><std::_Wrap_alloc<std::allocator<char> > & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAAXPEAU_Container_proxy@2@_K@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
_Count$ = 24
?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAAXPEAU_Container_proxy@2@_K@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::deallocate, COMDAT

; 884  : 		{	// deallocate object at _Ptr, ignore size

  00000	49 8b c0	 mov	 rax, r8
  00003	48 8b ca	 mov	 rcx, rdx

; 620  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00006	48 8b d0	 mov	 rdx, rax
  00009	41 b8 10 00 00
	00		 mov	 r8d, 16
  0000f	e9 00 00 00 00	 jmp	 ?_Deallocate@std@@YAXPEAX_K1@Z ; std::_Deallocate
?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAAXPEAU_Container_proxy@2@_K@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z
_TEXT	SEGMENT
this$ = 8
_Count$ = 16
?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::allocate, COMDAT

; 873  : 		{	// allocate array of _Count elements

  00000	48 8b ca	 mov	 rcx, rdx

; 625  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

  00003	41 b0 01	 mov	 r8b, 1
  00006	ba 10 00 00 00	 mov	 edx, 16
  0000b	e9 00 00 00 00	 jmp	 ?_Allocate@std@@YAPEAX_K0_N@Z ; std::_Allocate
?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@U_Container_proxy@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z
_TEXT	SEGMENT
this$ = 8
_Count$ = 16
?allocate@?$allocator@U_Container_proxy@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z PROC ; std::allocator<std::_Container_proxy>::allocate, COMDAT

; 624  : 		{	// allocate array of _Count elements

  00000	48 8b ca	 mov	 rcx, rdx

; 625  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

  00003	41 b0 01	 mov	 r8b, 1
  00006	ba 10 00 00 00	 mov	 edx, 16
  0000b	e9 00 00 00 00	 jmp	 ?_Allocate@std@@YAPEAX_K0_N@Z ; std::_Allocate
?allocate@?$allocator@U_Container_proxy@std@@@std@@QEAAPEAU_Container_proxy@2@_K@Z ENDP ; std::allocator<std::_Container_proxy>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QEAAXPEAU_Container_proxy@2@_K@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
_Count$ = 24
?deallocate@?$allocator@U_Container_proxy@std@@@std@@QEAAXPEAU_Container_proxy@2@_K@Z PROC ; std::allocator<std::_Container_proxy>::deallocate, COMDAT

; 619  : 		{	// deallocate object at _Ptr

  00000	49 8b c0	 mov	 rax, r8
  00003	48 8b ca	 mov	 rcx, rdx

; 620  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00006	48 8b d0	 mov	 rdx, rax
  00009	41 b8 10 00 00
	00		 mov	 r8d, 16
  0000f	e9 00 00 00 00	 jmp	 ?_Deallocate@std@@YAXPEAX_K1@Z ; std::_Deallocate
?deallocate@?$allocator@U_Container_proxy@std@@@std@@QEAAXPEAU_Container_proxy@2@_K@Z ENDP ; std::allocator<std::_Container_proxy>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PEADAEAPEAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QEAAXPEAPEADAEAPEAD@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@PEADAEAPEAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QEAAXPEAPEADAEAPEAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::construct<char * __ptr64,char * __ptr64 & __ptr64>, COMDAT

; 637  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00000	48 85 d2	 test	 rdx, rdx
  00003	74 06		 je	 SHORT $LN13@construct
  00005	49 8b 00	 mov	 rax, QWORD PTR [r8]
  00008	48 89 02	 mov	 QWORD PTR [rdx], rax
$LN13@construct:

; 893  : 		_Mytraits::construct(*this, _Ptr,
; 894  : 			_STD forward<_Types>(_Args)...);
; 895  : 		}

  0000b	c3		 ret	 0
??$construct@PEADAEAPEAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QEAAXPEAPEADAEAPEAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::construct<char * __ptr64,char * __ptr64 & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@D@std@@YAPEADAEAD@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@D@std@@YAPEADAEAD@Z PROC			; std::addressof<char>, COMDAT

; 716  : 	return (_Addressof(_Val, is_function<_Ty>()));

  00000	48 8b c1	 mov	 rax, rcx

; 717  : 	}

  00003	c3		 ret	 0
??$addressof@D@std@@YAPEADAEAD@Z ENDP			; std::addressof<char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PEAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QEAAXPEAPEAD@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
??$destroy@PEAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QEAAXPEAPEAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::destroy<char * __ptr64>, COMDAT

; 901  : 		_Mytraits::destroy(*this, _Ptr);
; 902  : 		}

  00000	c2 00 00	 ret	 0
??$destroy@PEAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QEAAXPEAPEAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::destroy<char * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><>, COMDAT

; 79   : 		: _Myproxy(0)

  00000	33 c0		 xor	 eax, eax
  00002	48 89 01	 mov	 QWORD PTR [rcx], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 488  : 		_Mysize = 0;

  00005	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 489  : 		_Myres = 0;

  00009	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 280  : 		}

  0000d	48 8b c1	 mov	 rax, rcx
  00010	c3		 ret	 0
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool, COMDAT

; 142  : 			return (_Ok);

  00000	0f b6 41 08	 movzx	 eax, BYTE PTR [rcx+8]

; 143  : 			}

  00004	c3		 ret	 0
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry, COMDAT

; 130  : 			{	// destroy the object

$LN13:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  0000f	48 8b d9	 mov	 rbx, rcx

; 131  :  #if _HAS_EXCEPTIONS
; 132  : 			if (!_XSTD uncaught_exception())

  00012	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?uncaught_exception@std@@YA_NXZ
  00018	90		 npad	 1
  00019	84 c0		 test	 al, al
  0001b	75 0a		 jne	 SHORT $LN2@sentry

; 133  : 				this->_Myostr._Osfx();

  0001d	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00020	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ
  00026	90		 npad	 1
$LN2@sentry:

; 107  : 			if (_Myostr.rdbuf() != 0)

  00027	48 8b 13	 mov	 rdx, QWORD PTR [rbx]
  0002a	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  0002d	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 92   : 		return (_Mystrbuf);

  00031	48 8b 4c 11 48	 mov	 rcx, QWORD PTR [rcx+rdx+72]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 107  : 			if (_Myostr.rdbuf() != 0)

  00036	48 85 c9	 test	 rcx, rcx
  00039	74 07		 je	 SHORT $LN12@sentry

; 108  : 				_Myostr.rdbuf()->_Unlock();

  0003b	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  0003e	ff 50 10	 call	 QWORD PTR [rax+16]
  00041	90		 npad	 1
$LN12@sentry:

; 134  : 
; 135  :  #else /* _HAS_EXCEPTIONS */
; 136  : 			this->_Myostr._Osfx();
; 137  :  #endif /* _HAS_EXCEPTIONS */
; 138  : 			}

  00042	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00046	5b		 pop	 rbx
  00047	c3		 ret	 0
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
?dtor$0@?0???1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA PROC ; `std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry'::`1'::dtor$0
  00000	e9 00 00 00 00	 jmp	 __std_terminate
?dtor$0@?0???1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA ENDP ; `std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
?dtor$0@?0???1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA PROC ; `std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry'::`1'::dtor$0
  00000	e9 00 00 00 00	 jmp	 __std_terminate
?dtor$0@?0???1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA ENDP ; `std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_Ostr$ = 72
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry, COMDAT

; 123  : 			{	// construct locking and testing stream

$LN26:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  00013	48 89 5c 24 48	 mov	 QWORD PTR [rsp+72], rbx
  00018	48 8b da	 mov	 rbx, rdx
  0001b	48 8b f9	 mov	 rdi, rcx

; 99   : 			: _Myostr(_Ostr)

  0001e	48 89 11	 mov	 QWORD PTR [rcx], rdx

; 101  : 			if (_Myostr.rdbuf() != 0)

  00021	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00024	4c 63 40 04	 movsxd	 r8, DWORD PTR [rax+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 92   : 		return (_Mystrbuf);

  00028	49 8b 4c 10 48	 mov	 rcx, QWORD PTR [r8+rdx+72]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 101  : 			if (_Myostr.rdbuf() != 0)

  0002d	48 85 c9	 test	 rcx, rcx
  00030	74 07		 je	 SHORT $LN6@sentry

; 102  : 				_Myostr.rdbuf()->_Lock();

  00032	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00035	ff 50 08	 call	 QWORD PTR [rax+8]
  00038	90		 npad	 1
$LN6@sentry:

; 124  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

  00039	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0003c	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 339  : 		return (rdstate() == goodbit);

  00040	83 7c 19 10 00	 cmp	 DWORD PTR [rcx+rbx+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 124  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

  00045	75 15		 jne	 SHORT $LN2@sentry
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 80   : 		return (_Tiestr);

  00047	48 8b 4c 19 50	 mov	 rcx, QWORD PTR [rcx+rbx+80]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 124  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

  0004c	48 85 c9	 test	 rcx, rcx
  0004f	74 0b		 je	 SHORT $LN2@sentry
  00051	48 3b cb	 cmp	 rcx, rbx
  00054	74 06		 je	 SHORT $LN2@sentry

; 125  : 				_Ostr.tie()->flush();

  00056	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ
$LN2@sentry:

; 126  : 			_Ok = _Ostr.good();	// store test only after flushing tie

  0005c	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0005f	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 339  : 		return (rdstate() == goodbit);

  00063	83 7c 19 10 00	 cmp	 DWORD PTR [rcx+rbx+16], 0
  00068	0f 94 c0	 sete	 al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 126  : 			_Ok = _Ostr.good();	// store test only after flushing tie

  0006b	88 47 08	 mov	 BYTE PTR [rdi+8], al

; 127  : 			}

  0006e	48 8b c7	 mov	 rax, rdi
  00071	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00076	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0007a	5f		 pop	 rdi
  0007b	c3		 ret	 0
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
_Ostr$ = 72
?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA PROC ; `std::basic_ostream<char,std::char_traits<char> >::sentry::sentry'::`1'::dtor$0
  00000	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA ENDP ; `std::basic_ostream<char,std::char_traits<char> >::sentry::sentry'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
_Ostr$ = 72
?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA PROC ; `std::basic_ostream<char,std::char_traits<char> >::sentry::sentry'::`1'::dtor$0
  00000	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA ENDP ; `std::basic_ostream<char,std::char_traits<char> >::sentry::sentry'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT

; 106  : 			{	// destroy after unlocking

$LN8:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00004	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2

; 107  : 			if (_Myostr.rdbuf() != 0)

  0000d	48 8b 11	 mov	 rdx, QWORD PTR [rcx]
  00010	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00013	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00017	48 8b 4c 11 48	 mov	 rcx, QWORD PTR [rcx+rdx+72]
  0001c	48 85 c9	 test	 rcx, rcx
  0001f	74 0b		 je	 SHORT $LN2@Sentry_bas

; 108  : 				_Myostr.rdbuf()->_Unlock();

  00021	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 109  : 			}

  00024	48 83 c4 38	 add	 rsp, 56			; 00000038H

; 108  : 				_Myostr.rdbuf()->_Unlock();

  00028	48 ff 60 10	 rex_jmp QWORD PTR [rax+16]
$LN2@Sentry_bas:

; 109  : 			}

  0002c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00030	c3		 ret	 0
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
_TEXT	SEGMENT
this$ = 48
_Ostr$ = 56
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT

; 100  : 			{	// lock the stream buffer, if there

$LN10:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 99   : 			: _Myostr(_Ostr)

  00006	48 89 11	 mov	 QWORD PTR [rcx], rdx

; 100  : 			{	// lock the stream buffer, if there

  00009	48 8b d9	 mov	 rbx, rcx

; 101  : 			if (_Myostr.rdbuf() != 0)

  0000c	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  0000f	4c 63 40 04	 movsxd	 r8, DWORD PTR [rax+4]
  00013	49 8b 4c 10 48	 mov	 rcx, QWORD PTR [r8+rdx+72]
  00018	48 85 c9	 test	 rcx, rcx
  0001b	74 06		 je	 SHORT $LN8@Sentry_bas

; 102  : 				_Myostr.rdbuf()->_Lock();

  0001d	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00020	ff 50 08	 call	 QWORD PTR [rax+8]
$LN8@Sentry_bas:

; 103  : 			}

  00023	48 8b c3	 mov	 rax, rbx
  00026	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002a	5b		 pop	 rbx
  0002b	c3		 ret	 0
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_Lock$2 = 72
??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@XZ PROC ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::~_String_iterator<std::_String_val<std::_Simple_types<char> > >, COMDAT
$LN12:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  0000f	48 8b d9	 mov	 rbx, rcx

; 142  : 		_Lockit _Lock(_LOCK_DEBUG);

  00012	ba 03 00 00 00	 mov	 edx, 3
  00017	48 8d 4c 24 48	 lea	 rcx, QWORD PTR _Lock$2[rsp]
  0001c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0_Lockit@std@@QEAA@H@Z
  00022	90		 npad	 1

; 143  : 		_Orphan_me();

  00023	48 8b cb	 mov	 rcx, rbx
  00026	e8 00 00 00 00	 call	 ?_Orphan_me@_Iterator_base12@std@@QEAAXXZ ; std::_Iterator_base12::_Orphan_me
  0002b	90		 npad	 1

; 144  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 145  : 		}

  0002c	48 8d 4c 24 48	 lea	 rcx, QWORD PTR _Lock$2[rsp]
  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
  00037	90		 npad	 1
  00038	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0003c	5b		 pop	 rbx
  0003d	c3		 ret	 0
??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@XZ ENDP ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::~_String_iterator<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
_Lock$2 = 72
?dtor$2@?0???1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@XZ@4HA PROC ; `std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::~_String_iterator<std::_String_val<std::_Simple_types<char> > >'::`1'::dtor$2
  00000	e9 00 00 00 00	 jmp	 __std_terminate
?dtor$2@?0???1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@XZ@4HA ENDP ; `std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::~_String_iterator<std::_String_val<std::_Simple_types<char> > >'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
_Lock$2 = 72
?dtor$2@?0???1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@XZ@4HA PROC ; `std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::~_String_iterator<std::_String_val<std::_Simple_types<char> > >'::`1'::dtor$2
  00000	e9 00 00 00 00	 jmp	 __std_terminate
?dtor$2@?0???1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@XZ@4HA ENDP ; `std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::~_String_iterator<std::_String_val<std::_Simple_types<char> > >'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??D?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAAEADXZ
_TEXT	SEGMENT
this$ = 8
??D?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAAEADXZ PROC ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::operator*, COMDAT

; 332  : 		return ((reference)**(_Mybase *)this);

  00000	e9 00 00 00 00	 jmp	 ??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAAEBDXZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator*
??D?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAAEADXZ ENDP ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEADPEBU_Container_base12@1@@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_Parg$ = 72
_Pstring$ = 80
??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEADPEBU_Container_base12@1@@Z PROC ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_String_iterator<std::_String_val<std::_Simple_types<char> > >, COMDAT

; 314  : 		{	// construct with pointer _Parg

$LN11:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  00013	48 89 5c 24 48	 mov	 QWORD PTR [rsp+72], rbx
  00018	48 8b da	 mov	 rbx, rdx
  0001b	48 8b f9	 mov	 rdi, rcx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 113  : 		: _Myproxy(0), _Mynextiter(0)

  0001e	33 c0		 xor	 eax, eax
  00020	48 89 01	 mov	 QWORD PTR [rcx], rax
  00023	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 49   : 		this->_Adopt(_Pstring);

  00027	49 8b d0	 mov	 rdx, r8
  0002a	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base12@std@@QEAAXPEBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt

; 50   : 		_Ptr = _Parg;

  0002f	48 89 5f 10	 mov	 QWORD PTR [rdi+16], rbx

; 315  : 		}

  00033	48 8b c7	 mov	 rax, rdi
  00036	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  0003b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0003f	5f		 pop	 rdi
  00040	c3		 ret	 0
??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEADPEBU_Container_base12@1@@Z ENDP ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_String_iterator<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
_Parg$ = 72
_Pstring$ = 80
?dtor$1@?0???0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEADPEBU_Container_base12@1@@Z@4HA PROC ; `std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_String_iterator<std::_String_val<std::_Simple_types<char> > >'::`1'::dtor$1
  00000	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$_Iterator012@Urandom_access_iterator_tag@std@@D_JPEBDAEBDU_Iterator_base12@2@@std@@QEAA@XZ
?dtor$1@?0???0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEADPEBU_Container_base12@1@@Z@4HA ENDP ; `std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_String_iterator<std::_String_val<std::_Simple_types<char> > >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
_Parg$ = 72
_Pstring$ = 80
?dtor$1@?0???0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEADPEBU_Container_base12@1@@Z@4HA PROC ; `std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_String_iterator<std::_String_val<std::_Simple_types<char> > >'::`1'::dtor$1
  00000	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$_Iterator012@Urandom_access_iterator_tag@std@@D_JPEBDAEBDU_Iterator_base12@2@@std@@QEAA@XZ
?dtor$1@?0???0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEADPEBU_Container_base12@1@@Z@4HA ENDP ; `std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_String_iterator<std::_String_val<std::_Simple_types<char> > >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_exception.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_typeinfo.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
_Lock$3 = 80
_Loc$ = 80
_Psave$4 = 88
??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z PROC ; std::use_facet<std::codecvt<char,char,_Mbstatet> >, COMDAT

; 553  : 	{	// get facet reference from locale

$LN32:
  00000	40 57		 push	 rdi
  00002	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00006	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  0000f	48 89 5c 24 60	 mov	 QWORD PTR [rsp+96], rbx
  00014	48 89 74 24 68	 mov	 QWORD PTR [rsp+104], rsi
  00019	48 8b f1	 mov	 rsi, rcx

; 554  :  #if _NO_LOCALES
; 555  : 	static _Wrap_facet<_Facet> _Wfac;
; 556  : 	return (*(_Facet *)&_Wfac);
; 557  : 
; 558  :  #else /* _NO_LOCALES */
; 559  : 	_BEGIN_LOCK(_LOCK_LOCALE)	// the thread lock, make get atomic

  0001c	33 d2		 xor	 edx, edx
  0001e	48 8d 4c 24 50	 lea	 rcx, QWORD PTR _Lock$3[rsp]
  00023	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0_Lockit@std@@QEAA@H@Z
  00029	90		 npad	 1

; 560  : 		const locale::facet *_Psave =
; 561  : 			_Facetptr<_Facet>::_Psave;	// static pointer to lazy facet

  0002a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?_Psave@?$_Facetptr@V?$codecvt@DDU_Mbstatet@@@std@@@std@@2PEBVfacet@locale@2@EB ; std::_Facetptr<std::codecvt<char,char,_Mbstatet> >::_Psave
  00031	48 89 44 24 58	 mov	 QWORD PTR _Psave$4[rsp], rax

; 562  : 
; 563  : 		size_t _Id = _Facet::id;

  00036	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A
  0003d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??Bid@locale@std@@QEAA_KXZ
  00043	48 8b f8	 mov	 rdi, rax

; 459  : 		const facet *_Facptr = _Id < _Ptr->_Facetcount

  00046	48 8b 46 08	 mov	 rax, QWORD PTR [rsi+8]
  0004a	48 3b 78 18	 cmp	 rdi, QWORD PTR [rax+24]
  0004e	73 13		 jae	 SHORT $LN20@use_facet
  00050	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00054	48 8b 1c f9	 mov	 rbx, QWORD PTR [rcx+rdi*8]

; 460  : 			? _Ptr->_Facetvec[_Id] : 0;	// null if id off end
; 461  : 		if (_Facptr != 0 || !_Ptr->_Xparent)

  00058	48 85 db	 test	 rbx, rbx
  0005b	0f 85 90 00 00
	00		 jne	 $LN7@use_facet
  00061	eb 02		 jmp	 SHORT $LN28@use_facet
$LN20@use_facet:

; 459  : 		const facet *_Facptr = _Id < _Ptr->_Facetcount

  00063	33 db		 xor	 ebx, ebx
$LN28@use_facet:

; 460  : 			? _Ptr->_Facetvec[_Id] : 0;	// null if id off end
; 461  : 		if (_Facptr != 0 || !_Ptr->_Xparent)

  00065	80 78 24 00	 cmp	 BYTE PTR [rax+36], 0
  00069	74 14		 je	 SHORT $LN17@use_facet

; 462  : 			return (_Facptr);	// found facet or not transparent
; 463  : 		else
; 464  : 			{	// look in current locale
; 465  : 			locale::_Locimp *_Ptr0 = _Getgloballocale();

  0006b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Getgloballocale@locale@std@@CAPEAV_Locimp@12@XZ

; 466  : 			return (_Id < _Ptr0->_Facetcount

  00071	48 3b 78 18	 cmp	 rdi, QWORD PTR [rax+24]
  00075	73 0d		 jae	 SHORT $LN29@use_facet
  00077	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0007b	48 8b 1c f8	 mov	 rbx, QWORD PTR [rax+rdi*8]
$LN17@use_facet:

; 564  : 		const locale::facet *_Pf = _Loc._Getfacet(_Id);
; 565  : 
; 566  : 		if (_Pf != 0)

  0007f	48 85 db	 test	 rbx, rbx
  00082	75 6d		 jne	 SHORT $LN7@use_facet
$LN29@use_facet:

; 567  : 			;	// got facet from locale
; 568  : 		else if (_Psave != 0)

  00084	48 8b 5c 24 58	 mov	 rbx, QWORD PTR _Psave$4[rsp]
  00089	48 85 db	 test	 rbx, rbx
  0008c	75 63		 jne	 SHORT $LN7@use_facet

; 569  : 			_Pf = _Psave;	// lazy facet already allocated
; 570  : 		else if (_Facet::_Getcat(&_Psave, &_Loc) == (size_t)(-1))

  0008e	48 8b d6	 mov	 rdx, rsi
  00091	48 8d 4c 24 58	 lea	 rcx, QWORD PTR _Psave$4[rsp]
  00096	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Getcat@?$codecvt@DDU_Mbstatet@@@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z
  0009c	48 83 f8 ff	 cmp	 rax, -1
  000a0	75 31		 jne	 SHORT $LN6@use_facet
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_exception.h

; 59   :         : _Data()

  000a2	33 c0		 xor	 eax, eax
  000a4	48 89 44 24 38	 mov	 QWORD PTR $T2[rsp+16], rax

; 60   :     {
; 61   :         _Data._What = _Message;

  000a9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_08EPJLHIJG@bad?5cast?$AA@
  000b0	48 89 44 24 30	 mov	 QWORD PTR $T2[rsp+8], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_typeinfo.h

; 125  :     {

  000b5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7bad_cast@std@@6B@
  000bc	48 89 44 24 28	 mov	 QWORD PTR $T2[rsp], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale

; 574  : 			_THROW_NCEE(_XSTD bad_cast, _EMPTY_ARGUMENT);	// lazy disallowed

  000c1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_TI2?AVbad_cast@std@@
  000c8	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T2[rsp]
  000cd	e8 00 00 00 00	 call	 _CxxThrowException
  000d2	cc		 int	 3
$LN6@use_facet:

; 575  : 
; 576  :  #else /* _HAS_EXCEPTIONS */
; 577  : 			abort();	// lazy disallowed
; 578  :  #endif /* _HAS_EXCEPTIONS */
; 579  : 
; 580  : 		else
; 581  : 			{	// queue up lazy facet for destruction
; 582  : 			_Pf = _Psave;

  000d3	48 8b 5c 24 58	 mov	 rbx, QWORD PTR _Psave$4[rsp]

; 583  : 			_Facetptr<_Facet>::_Psave = _Psave;

  000d8	48 89 1d 00 00
	00 00		 mov	 QWORD PTR ?_Psave@?$_Facetptr@V?$codecvt@DDU_Mbstatet@@@std@@@std@@2PEBVfacet@locale@2@EB, rbx ; std::_Facetptr<std::codecvt<char,char,_Mbstatet> >::_Psave

; 584  : 
; 585  : 			locale::facet *_Pfmod = (_Facet *)_Psave;
; 586  : 			_Pfmod->_Incref();

  000df	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  000e2	48 8b cb	 mov	 rcx, rbx
  000e5	ff 50 08	 call	 QWORD PTR [rax+8]

; 587  : 
; 588  :  #if defined(_M_CEE)
; 589  : 			_Facet_Register_m(_Pfmod);
; 590  : 
; 591  :  #else /* defined(_M_CEE) */
; 592  : 			_Facet_Register(_Pfmod);

  000e8	48 8b cb	 mov	 rcx, rbx
  000eb	e8 00 00 00 00	 call	 ?_Facet_Register@std@@YAXPEAV_Facet_base@1@@Z ; std::_Facet_Register
  000f0	90		 npad	 1
$LN7@use_facet:

; 593  :  #endif /* defined(_M_CEE) */
; 594  : 			}
; 595  : 
; 596  : 		return ((const _Facet&)(*_Pf));	// should be dynamic_cast

  000f1	48 8d 4c 24 50	 lea	 rcx, QWORD PTR _Lock$3[rsp]
  000f6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
  000fc	48 8b c3	 mov	 rax, rbx

; 597  : 	_END_LOCK()
; 598  :  #endif /* _NO_LOCALES */
; 599  : 	}	// end of use_facet body

  000ff	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  00104	48 8b 74 24 68	 mov	 rsi, QWORD PTR [rsp+104]
  00109	48 83 c4 40	 add	 rsp, 64			; 00000040H
  0010d	5f		 pop	 rdi
  0010e	c3		 ret	 0
$LN30@use_facet:
??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z ENDP ; std::use_facet<std::codecvt<char,char,_Mbstatet> >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
_Lock$3 = 80
_Loc$ = 80
_Psave$4 = 88
?dtor$0@?0???$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z@4HA PROC ; `std::use_facet<std::codecvt<char,char,_Mbstatet> >'::`1'::dtor$0
  00000	48 8d 8a 50 00
	00 00		 lea	 rcx, QWORD PTR _Lock$3[rdx]
  00007	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
?dtor$0@?0???$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z@4HA ENDP ; `std::use_facet<std::codecvt<char,char,_Mbstatet> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
_Lock$3 = 80
_Loc$ = 80
_Psave$4 = 88
?dtor$0@?0???$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z@4HA PROC ; `std::use_facet<std::codecvt<char,char,_Mbstatet> >'::`1'::dtor$0
  00000	48 8d 8a 50 00
	00 00		 lea	 rcx, QWORD PTR _Lock$3[rdx]
  00007	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
?dtor$0@?0???$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z@4HA ENDP ; `std::use_facet<std::codecvt<char,char,_Mbstatet> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_Lock$2 = 72
??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@XZ PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::~_String_const_iterator<std::_String_val<std::_Simple_types<char> > >, COMDAT
$LN9:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  0000f	48 8b d9	 mov	 rbx, rcx

; 142  : 		_Lockit _Lock(_LOCK_DEBUG);

  00012	ba 03 00 00 00	 mov	 edx, 3
  00017	48 8d 4c 24 48	 lea	 rcx, QWORD PTR _Lock$2[rsp]
  0001c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0_Lockit@std@@QEAA@H@Z
  00022	90		 npad	 1

; 143  : 		_Orphan_me();

  00023	48 8b cb	 mov	 rcx, rbx
  00026	e8 00 00 00 00	 call	 ?_Orphan_me@_Iterator_base12@std@@QEAAXXZ ; std::_Iterator_base12::_Orphan_me
  0002b	90		 npad	 1

; 144  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 145  : 		}

  0002c	48 8d 4c 24 48	 lea	 rcx, QWORD PTR _Lock$2[rsp]
  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
  00037	90		 npad	 1
  00038	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0003c	5b		 pop	 rbx
  0003d	c3		 ret	 0
??1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@XZ ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::~_String_const_iterator<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
_Lock$2 = 72
?dtor$1@?0???1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@XZ@4HA PROC ; `std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::~_String_const_iterator<std::_String_val<std::_Simple_types<char> > >'::`1'::dtor$1
  00000	e9 00 00 00 00	 jmp	 __std_terminate
?dtor$1@?0???1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@XZ@4HA ENDP ; `std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::~_String_const_iterator<std::_String_val<std::_Simple_types<char> > >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
_Lock$2 = 72
?dtor$1@?0???1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@XZ@4HA PROC ; `std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::~_String_const_iterator<std::_String_val<std::_Simple_types<char> > >'::`1'::dtor$1
  00000	e9 00 00 00 00	 jmp	 __std_terminate
?dtor$1@?0???1?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@XZ@4HA ENDP ; `std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::~_String_const_iterator<std::_String_val<std::_Simple_types<char> > >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAAEBDXZ
_TEXT	SEGMENT
this$ = 64
??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAAEBDXZ PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator*, COMDAT

; 67   : 		{	// return designated object

$LN45:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 183  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

  00006	48 8b 01	 mov	 rax, QWORD PTR [rcx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 67   : 		{	// return designated object

  00009	48 8b d9	 mov	 rbx, rcx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 183  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

  0000c	48 85 c0	 test	 rax, rax
  0000f	74 4d		 je	 SHORT $LN3@operator
  00011	48 8b 00	 mov	 rax, QWORD PTR [rax]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 72   : 			|| ((_Mystr *)this->_Getcont())->_Myptr()

  00014	48 85 c0	 test	 rax, rax
  00017	74 45		 je	 SHORT $LN3@operator
  00019	48 8b 51 10	 mov	 rdx, QWORD PTR [rcx+16]
  0001d	48 85 d2	 test	 rdx, rdx
  00020	74 3c		 je	 SHORT $LN3@operator

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  00022	48 83 78 20 10	 cmp	 QWORD PTR [rax+32], 16
  00027	72 06		 jb	 SHORT $LN17@operator
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 708  : 	return (reinterpret_cast<_Ty *>(

  00029	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  0002d	eb 04		 jmp	 SHORT $LN18@operator
$LN17@operator:
  0002f	48 8d 48 08	 lea	 rcx, QWORD PTR [rax+8]
$LN18@operator:

; 72   : 			|| ((_Mystr *)this->_Getcont())->_Myptr()

  00033	48 3b d1	 cmp	 rdx, rcx
  00036	72 26		 jb	 SHORT $LN3@operator

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  00038	48 83 78 20 10	 cmp	 QWORD PTR [rax+32], 16
  0003d	72 06		 jb	 SHORT $LN31@operator
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 708  : 	return (reinterpret_cast<_Ty *>(

  0003f	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  00043	eb 04		 jmp	 SHORT $LN32@operator
$LN31@operator:
  00045	48 8d 48 08	 lea	 rcx, QWORD PTR [rax+8]
$LN32@operator:

; 72   : 			|| ((_Mystr *)this->_Getcont())->_Myptr()

  00049	48 8b 40 18	 mov	 rax, QWORD PTR [rax+24]
  0004d	48 03 c8	 add	 rcx, rax
  00050	48 3b ca	 cmp	 rcx, rdx
  00053	76 09		 jbe	 SHORT $LN3@operator

; 77   : 			}
; 78   : 
; 79   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 80   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && _Ptr != 0);
; 81   : 		_SCL_SECURE_VALIDATE_RANGE(
; 82   : 			((_Mystr *)this->_Getcont())->_Myptr() <= _Ptr
; 83   : 			&& _Ptr < ((_Mystr *)this->_Getcont())->_Myptr()
; 84   : 				+ ((_Mystr *)this->_Getcont())->_Mysize);
; 85   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 86   : 
; 87   : 		_Analysis_assume_(_Ptr != 0);
; 88   : 
; 89   : 		return (*_Ptr);

  00055	48 8b c2	 mov	 rax, rdx

; 90   : 		}

  00058	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0005c	5b		 pop	 rbx
  0005d	c3		 ret	 0
$LN3@operator:

; 73   : 				+ ((_Mystr *)this->_Getcont())->_Mysize <= _Ptr)
; 74   : 			{	// report error
; 75   : 			_DEBUG_ERROR("string iterator not dereferencable");

  0005e	41 b8 4b 00 00
	00		 mov	 r8d, 75			; 0000004bH
  00064	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1IO@IPMLDGDI@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  0006b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1EG@CNCHLAOB@?$AAs?$AAt?$AAr?$AAi?$AAn?$AAg?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb@
  00072	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Debug_message@std@@YAXPEB_W0I@Z

; 76   : 			_SCL_SECURE_OUT_OF_RANGE;

  00078	45 33 c9	 xor	 r9d, r9d
  0007b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@
  00082	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00087	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1IO@IPMLDGDI@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  0008e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs?$AA?$AA@
  00095	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0009a	45 8d 41 4c	 lea	 r8d, QWORD PTR [r9+76]
  0009e	41 8d 49 02	 lea	 ecx, QWORD PTR [r9+2]
  000a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__CrtDbgReportW
  000a8	83 f8 01	 cmp	 eax, 1
  000ab	75 01		 jne	 SHORT $LN6@operator
  000ad	cc		 int	 3
$LN6@operator:
  000ae	41 b9 4c 00 00
	00		 mov	 r9d, 76			; 0000004cH
  000b4	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  000bd	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_1IO@IPMLDGDI@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  000c4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1MG@GDGHDIKC@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAS?$AAt?$AAr?$AAi?$AAn?$AAg?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
  000cb	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
  000d2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter

; 77   : 			}
; 78   : 
; 79   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 80   : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && _Ptr != 0);
; 81   : 		_SCL_SECURE_VALIDATE_RANGE(
; 82   : 			((_Mystr *)this->_Getcont())->_Myptr() <= _Ptr
; 83   : 			&& _Ptr < ((_Mystr *)this->_Getcont())->_Myptr()
; 84   : 				+ ((_Mystr *)this->_Getcont())->_Mysize);
; 85   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 86   : 
; 87   : 		_Analysis_assume_(_Ptr != 0);
; 88   : 
; 89   : 		return (*_Ptr);

  000d8	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]

; 90   : 		}

  000dc	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000e0	5b		 pop	 rbx
  000e1	c3		 ret	 0
??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAAEBDXZ ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEBDPEBU_Container_base12@1@@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_Parg$ = 72
_Pstring$ = 80
??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEBDPEBU_Container_base12@1@@Z PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >, COMDAT

; 47   : 	_String_const_iterator(pointer _Parg, const _Container_base *_Pstring)

$LN8:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  00013	48 89 5c 24 48	 mov	 QWORD PTR [rsp+72], rbx
  00018	48 8b da	 mov	 rbx, rdx
  0001b	48 8b f9	 mov	 rdi, rcx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 113  : 		: _Myproxy(0), _Mynextiter(0)

  0001e	33 c0		 xor	 eax, eax
  00020	48 89 01	 mov	 QWORD PTR [rcx], rax
  00023	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 49   : 		this->_Adopt(_Pstring);

  00027	49 8b d0	 mov	 rdx, r8
  0002a	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base12@std@@QEAAXPEBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt

; 50   : 		_Ptr = _Parg;

  0002f	48 89 5f 10	 mov	 QWORD PTR [rdi+16], rbx

; 51   : 		}

  00033	48 8b c7	 mov	 rax, rdi
  00036	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  0003b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0003f	5f		 pop	 rdi
  00040	c3		 ret	 0
??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEBDPEBU_Container_base12@1@@Z ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
_Parg$ = 72
_Pstring$ = 80
?dtor$0@?0???0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEBDPEBU_Container_base12@1@@Z@4HA PROC ; `std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >'::`1'::dtor$0
  00000	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$_Iterator012@Urandom_access_iterator_tag@std@@D_JPEBDAEBDU_Iterator_base12@2@@std@@QEAA@XZ
?dtor$0@?0???0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEBDPEBU_Container_base12@1@@Z@4HA ENDP ; `std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
_Parg$ = 72
_Pstring$ = 80
?dtor$0@?0???0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEBDPEBU_Container_base12@1@@Z@4HA PROC ; `std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >'::`1'::dtor$0
  00000	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$_Iterator012@Urandom_access_iterator_tag@std@@D_JPEBDAEBDU_Iterator_base12@2@@std@@QEAA@XZ
?dtor$0@?0???0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEBDPEBU_Container_base12@1@@Z@4HA ENDP ; `std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??1?$_Iterator012@Urandom_access_iterator_tag@std@@D_JPEBDAEBDU_Iterator_base12@2@@std@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_Lock$2 = 72
??1?$_Iterator012@Urandom_access_iterator_tag@std@@D_JPEBDAEBDU_Iterator_base12@2@@std@@QEAA@XZ PROC ; std::_Iterator012<std::random_access_iterator_tag,char,__int64,char const * __ptr64,char const & __ptr64,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,char,__int64,char const * __ptr64,char const & __ptr64,std::_Iterator_base12>, COMDAT
$LN6:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  0000f	48 8b d9	 mov	 rbx, rcx

; 142  : 		_Lockit _Lock(_LOCK_DEBUG);

  00012	ba 03 00 00 00	 mov	 edx, 3
  00017	48 8d 4c 24 48	 lea	 rcx, QWORD PTR _Lock$2[rsp]
  0001c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0_Lockit@std@@QEAA@H@Z
  00022	90		 npad	 1

; 143  : 		_Orphan_me();

  00023	48 8b cb	 mov	 rcx, rbx
  00026	e8 00 00 00 00	 call	 ?_Orphan_me@_Iterator_base12@std@@QEAAXXZ ; std::_Iterator_base12::_Orphan_me
  0002b	90		 npad	 1

; 144  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 145  : 		}

  0002c	48 8d 4c 24 48	 lea	 rcx, QWORD PTR _Lock$2[rsp]
  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
  00037	90		 npad	 1
  00038	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0003c	5b		 pop	 rbx
  0003d	c3		 ret	 0
??1?$_Iterator012@Urandom_access_iterator_tag@std@@D_JPEBDAEBDU_Iterator_base12@2@@std@@QEAA@XZ ENDP ; std::_Iterator012<std::random_access_iterator_tag,char,__int64,char const * __ptr64,char const & __ptr64,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,char,__int64,char const * __ptr64,char const & __ptr64,std::_Iterator_base12>
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
_Lock$2 = 72
?dtor$0@?0???1?$_Iterator012@Urandom_access_iterator_tag@std@@D_JPEBDAEBDU_Iterator_base12@2@@std@@QEAA@XZ@4HA PROC ; `std::_Iterator012<std::random_access_iterator_tag,char,__int64,char const * __ptr64,char const & __ptr64,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,char,__int64,char const * __ptr64,char const & __ptr64,std::_Iterator_base12>'::`1'::dtor$0
  00000	e9 00 00 00 00	 jmp	 __std_terminate
?dtor$0@?0???1?$_Iterator012@Urandom_access_iterator_tag@std@@D_JPEBDAEBDU_Iterator_base12@2@@std@@QEAA@XZ@4HA ENDP ; `std::_Iterator012<std::random_access_iterator_tag,char,__int64,char const * __ptr64,char const & __ptr64,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,char,__int64,char const * __ptr64,char const & __ptr64,std::_Iterator_base12>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
_Lock$2 = 72
?dtor$0@?0???1?$_Iterator012@Urandom_access_iterator_tag@std@@D_JPEBDAEBDU_Iterator_base12@2@@std@@QEAA@XZ@4HA PROC ; `std::_Iterator012<std::random_access_iterator_tag,char,__int64,char const * __ptr64,char const & __ptr64,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,char,__int64,char const * __ptr64,char const & __ptr64,std::_Iterator_base12>'::`1'::dtor$0
  00000	e9 00 00 00 00	 jmp	 __std_terminate
?dtor$0@?0???1?$_Iterator012@Urandom_access_iterator_tag@std@@D_JPEBDAEBDU_Iterator_base12@2@@std@@QEAA@XZ@4HA ENDP ; `std::_Iterator012<std::random_access_iterator_tag,char,__int64,char const * __ptr64,char const & __ptr64,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,char,__int64,char const * __ptr64,char const & __ptr64,std::_Iterator_base12>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??0?$_Iterator012@Urandom_access_iterator_tag@std@@D_JPEBDAEBDU_Iterator_base12@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Iterator012@Urandom_access_iterator_tag@std@@D_JPEBDAEBDU_Iterator_base12@2@@std@@QEAA@XZ PROC ; std::_Iterator012<std::random_access_iterator_tag,char,__int64,char const * __ptr64,char const & __ptr64,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,char,__int64,char const * __ptr64,char const & __ptr64,std::_Iterator_base12>, COMDAT

; 113  : 		: _Myproxy(0), _Mynextiter(0)

  00000	33 c0		 xor	 eax, eax
  00002	48 89 01	 mov	 QWORD PTR [rcx], rax
  00005	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
  00009	48 8b c1	 mov	 rax, rcx
  0000c	c3		 ret	 0
??0?$_Iterator012@Urandom_access_iterator_tag@std@@D_JPEBDAEBDU_Iterator_base12@2@@std@@QEAA@XZ ENDP ; std::_Iterator012<std::random_access_iterator_tag,char,__int64,char const * __ptr64,char const & __ptr64,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,char,__int64,char const * __ptr64,char const & __ptr64,std::_Iterator_base12>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ??B?$fpos@U_Mbstatet@@@std@@QEBA_JXZ
_TEXT	SEGMENT
this$ = 8
??B?$fpos@U_Mbstatet@@@std@@QEBA_JXZ PROC		; std::fpos<_Mbstatet>::operator __int64, COMDAT

; 68   : 		return ((streamoff)(_Myoff + _FPOSOFF(_Fpos)));

  00000	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  00004	48 03 01	 add	 rax, QWORD PTR [rcx]

; 69   : 		}

  00007	c3		 ret	 0
??B?$fpos@U_Mbstatet@@@std@@QEBA_JXZ ENDP		; std::fpos<_Mbstatet>::operator __int64
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?seekpos@?$fpos@U_Mbstatet@@@std@@QEBA_JXZ
_TEXT	SEGMENT
this$ = 8
?seekpos@?$fpos@U_Mbstatet@@@std@@QEBA_JXZ PROC		; std::fpos<_Mbstatet>::seekpos, COMDAT

; 63   : 		return (_Fpos);

  00000	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]

; 64   : 		}

  00004	c3		 ret	 0
?seekpos@?$fpos@U_Mbstatet@@@std@@QEBA_JXZ ENDP		; std::fpos<_Mbstatet>::seekpos
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?state@?$fpos@U_Mbstatet@@@std@@QEBA?AU_Mbstatet@@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?state@?$fpos@U_Mbstatet@@@std@@QEBA?AU_Mbstatet@@XZ PROC ; std::fpos<_Mbstatet>::state, COMDAT

; 53   : 		return (_Mystate);

  00000	48 8b 41 10	 mov	 rax, QWORD PTR [rcx+16]
  00004	48 89 02	 mov	 QWORD PTR [rdx], rax
  00007	48 8b c2	 mov	 rax, rdx

; 54   : 		}

  0000a	c3		 ret	 0
?state@?$fpos@U_Mbstatet@@@std@@QEBA?AU_Mbstatet@@XZ ENDP ; std::fpos<_Mbstatet>::state
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ??0?$fpos@U_Mbstatet@@@std@@QEAA@U_Mbstatet@@_J@Z
_TEXT	SEGMENT
this$ = 8
_State$ = 16
_Fileposition$ = 24
??0?$fpos@U_Mbstatet@@@std@@QEAA@U_Mbstatet@@_J@Z PROC	; std::fpos<_Mbstatet>::fpos<_Mbstatet>, COMDAT

; 47   : 		: _Myoff(0), _Fpos(_Fileposition), _Mystate(_State)

  00000	48 c7 01 00 00
	00 00		 mov	 QWORD PTR [rcx], 0

; 49   : 		}

  00007	48 8b c1	 mov	 rax, rcx
  0000a	4c 89 41 08	 mov	 QWORD PTR [rcx+8], r8
  0000e	48 89 51 10	 mov	 QWORD PTR [rcx+16], rdx
  00012	c3		 ret	 0
??0?$fpos@U_Mbstatet@@@std@@QEAA@U_Mbstatet@@_J@Z ENDP	; std::fpos<_Mbstatet>::fpos<_Mbstatet>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ??0?$fpos@U_Mbstatet@@@std@@QEAA@_J@Z
_TEXT	SEGMENT
this$ = 8
_Off$ = 16
??0?$fpos@U_Mbstatet@@@std@@QEAA@_J@Z PROC		; std::fpos<_Mbstatet>::fpos<_Mbstatet>, COMDAT

; 42   : 		: _Myoff(_Off), _Fpos(_Fpz), _Mystate()

  00000	33 c0		 xor	 eax, eax
  00002	48 89 11	 mov	 QWORD PTR [rcx], rdx
  00005	48 c7 41 08 00
	00 00 00	 mov	 QWORD PTR [rcx+8], 0
  0000d	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 44   : 		}

  00011	48 8b c1	 mov	 rax, rcx
  00014	c3		 ret	 0
??0?$fpos@U_Mbstatet@@@std@@QEAA@_J@Z ENDP		; std::fpos<_Mbstatet>::fpos<_Mbstatet>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
;	COMDAT ??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXXZ PROC ; std::basic_fstream<char,std::char_traits<char> >::`vbase destructor', COMDAT
$LN7:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1292 : 		{	// destroy the object

  00006	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00009	48 8d 99 b8 00
	00 00		 lea	 rbx, QWORD PTR [rcx+184]

; 1293 : 		}

  00010	48 8d 8b 60 ff
	ff ff		 lea	 rcx, QWORD PTR [rbx-160]
  00017	48 63 50 04	 movsxd	 rdx, DWORD PTR [rax+4]
  0001b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@
  00022	48 89 84 1a 48
	ff ff ff	 mov	 QWORD PTR [rdx+rbx-184], rax
  0002a	48 8b 83 48 ff
	ff ff		 mov	 rax, QWORD PTR [rbx-184]
  00031	48 63 50 04	 movsxd	 rdx, DWORD PTR [rax+4]
  00035	44 8d 82 48 ff
	ff ff		 lea	 r8d, DWORD PTR [rdx-184]
  0003c	44 89 84 1a 44
	ff ff ff	 mov	 DWORD PTR [rdx+rbx-188], r8d
  00044	e8 00 00 00 00	 call	 ??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
  00049	48 8d 8b 68 ff
	ff ff		 lea	 rcx, QWORD PTR [rbx-152]
  00050	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UEAA@XZ
  00056	48 8b cb	 mov	 rcx, rbx
  00059	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005d	5b		 pop	 rbx
  0005e	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXXZ ENDP ; std::basic_fstream<char,std::char_traits<char> >::`vbase destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_G?$basic_fstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G?$basic_fstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z PROC ; std::basic_fstream<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
$LN6:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8d b9 48 ff
	ff ff		 lea	 rdi, QWORD PTR [rcx-184]
  00011	8b da		 mov	 ebx, edx
  00013	48 8b cf	 mov	 rcx, rdi
  00016	e8 00 00 00 00	 call	 ??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
  0001b	f6 c3 01	 test	 bl, 1
  0001e	74 0d		 je	 SHORT $LN4@scalar
  00020	ba 18 01 00 00	 mov	 edx, 280		; 00000118H
  00025	48 8b cf	 mov	 rcx, rdi
  00028	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN4@scalar:
  0002d	48 8b c7	 mov	 rax, rdi
  00030	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00035	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00039	5f		 pop	 rdi
  0003a	c3		 ret	 0
??_G?$basic_fstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z ENDP ; std::basic_fstream<char,std::char_traits<char> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
$LN6:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	8b da		 mov	 ebx, edx
  0000c	48 8b f9	 mov	 rdi, rcx
  0000f	e8 00 00 00 00	 call	 ??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
  00014	f6 c3 01	 test	 bl, 1
  00017	74 0d		 je	 SHORT $LN4@scalar
  00019	ba 98 00 00 00	 mov	 edx, 152		; 00000098H
  0001e	48 8b cf	 mov	 rcx, rdi
  00021	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN4@scalar:
  00026	48 8b c7	 mov	 rax, rdi
  00029	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0002e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00032	5f		 pop	 rdi
  00033	c3		 ret	 0
??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
;	COMDAT ?_Set_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Set_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Set_back, COMDAT

; 709  : 		{	// set up putback area

  00000	4c 8b c1	 mov	 r8, rcx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 222  : 		return (*_IGfirst);

  00003	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream

; 710  : 		if (_Mysb::eback() != &_Mychar)

  00007	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  0000a	4d 8d 48 70	 lea	 r9, QWORD PTR [r8+112]
  0000e	49 3b c1	 cmp	 rax, r9
  00011	74 1c		 je	 SHORT $LN2@Set_back

; 711  : 			{	// save current get buffer
; 712  : 			_Set_eback = _Mysb::eback();

  00013	49 89 80 88 00
	00 00		 mov	 QWORD PTR [r8+136], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 242  : 		return (*_IGnext + *_IGcount);

  0001a	49 8b 40 50	 mov	 rax, QWORD PTR [r8+80]
  0001e	48 63 10	 movsxd	 rdx, DWORD PTR [rax]
  00021	49 8b 40 38	 mov	 rax, QWORD PTR [r8+56]
  00025	48 03 10	 add	 rdx, QWORD PTR [rax]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream

; 713  : 			_Set_egptr = _Mysb::egptr();

  00028	49 89 90 90 00
	00 00		 mov	 QWORD PTR [r8+144], rdx
$LN2@Set_back:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 253  : 		*_IGfirst = _First;

  0002f	4c 89 09	 mov	 QWORD PTR [rcx], r9

; 254  : 		*_IGnext = _Next;
; 255  : 		*_IGcount = (int)(_Last - _Next);

  00032	41 8b c8	 mov	 ecx, r8d
  00035	49 8b 40 38	 mov	 rax, QWORD PTR [r8+56]
  00039	41 2b c9	 sub	 ecx, r9d
  0003c	83 c1 71	 add	 ecx, 113		; 00000071H
  0003f	4c 89 08	 mov	 QWORD PTR [rax], r9
  00042	49 8b 40 50	 mov	 rax, QWORD PTR [r8+80]
  00046	89 08		 mov	 DWORD PTR [rax], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream

; 716  : 		}

  00048	c3		 ret	 0
?_Set_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Set_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
;	COMDAT ?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Reset_back, COMDAT
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 222  : 		return (*_IGfirst);

  00000	4c 8b 49 18	 mov	 r9, QWORD PTR [rcx+24]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream

; 704  : 		if (_Mysb::eback() == &_Mychar)

  00004	48 8d 41 70	 lea	 rax, QWORD PTR [rcx+112]
  00008	49 39 01	 cmp	 QWORD PTR [r9], rax
  0000b	75 22		 jne	 SHORT $LN2@Reset_back

; 705  : 			_Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

  0000d	48 8b 91 88 00
	00 00		 mov	 rdx, QWORD PTR [rcx+136]
  00014	4c 8b 81 90 00
	00 00		 mov	 r8, QWORD PTR [rcx+144]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 253  : 		*_IGfirst = _First;

  0001b	49 89 11	 mov	 QWORD PTR [r9], rdx

; 254  : 		*_IGnext = _Next;
; 255  : 		*_IGcount = (int)(_Last - _Next);

  0001e	44 2b c2	 sub	 r8d, edx
  00021	48 8b 41 38	 mov	 rax, QWORD PTR [rcx+56]
  00025	48 89 10	 mov	 QWORD PTR [rax], rdx
  00028	48 8b 41 50	 mov	 rax, QWORD PTR [rcx+80]
  0002c	44 89 00	 mov	 DWORD PTR [rax], r8d
$LN2@Reset_back:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream

; 706  : 		}

  0002f	c3		 ret	 0
?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Reset_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
;	COMDAT ?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEBV?$codecvt@DDU_Mbstatet@@@2@@Z
_TEXT	SEGMENT
this$ = 48
_Newpcvt$ = 56
?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEBV?$codecvt@DDU_Mbstatet@@@2@@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Initcvt, COMDAT

; 684  : 		{	// initialize codecvt pointer

$LN12:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b d9	 mov	 rbx, rcx
  0000d	48 8b fa	 mov	 rdi, rdx

; 685  : 		if (_Newpcvt->always_noconv())

  00010	48 8b ca	 mov	 rcx, rdx
  00013	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?always_noconv@codecvt_base@std@@QEBA_NXZ
  00019	84 c0		 test	 al, al
  0001b	74 13		 je	 SHORT $LN2@Initcvt

; 686  : 			_Pcvt = 0;	// nothing to do

  0001d	48 c7 43 68 00
	00 00 00	 mov	 QWORD PTR [rbx+104], 0

; 691  : 			}
; 692  : 		}

  00025	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0002a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002e	5f		 pop	 rdi
  0002f	c3		 ret	 0
$LN2@Initcvt:

; 687  : 		else
; 688  : 			{	// set up for nontrivial codecvt facet
; 689  : 			_Pcvt = _Newpcvt;
; 690  : 			_Mysb::_Init();	// reset any buffering

  00030	48 8b cb	 mov	 rcx, rbx
  00033	48 89 7b 68	 mov	 QWORD PTR [rbx+104], rdi

; 691  : 			}
; 692  : 		}

  00037	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0003c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00040	5f		 pop	 rdi

; 687  : 		else
; 688  : 			{	// set up for nontrivial codecvt facet
; 689  : 			_Pcvt = _Newpcvt;
; 690  : 			_Mysb::_Init();	// reset any buffering

  00041	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXXZ
?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEBV?$codecvt@DDU_Mbstatet@@@2@@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Initcvt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
;	COMDAT ?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ
_TEXT	SEGMENT
_Lock$1 = 48
_Str$2 = 56
$T3 = 96
$T4 = 96
_Dest$5 = 120
$T6 = 128
$T7 = 152
$T8 = 176
_Lock$9 = 272
_Lock$10 = 272
this$ = 272
_Lock$11 = 280
_Lock$12 = 288
$T13 = 296
?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite, COMDAT

; 643  : 		{	// put shift to initial conversion state, as needed

$LN346:
  00000	40 55		 push	 rbp
  00002	53		 push	 rbx
  00003	56		 push	 rsi
  00004	57		 push	 rdi
  00005	41 54		 push	 r12
  00007	41 55		 push	 r13
  00009	41 56		 push	 r14
  0000b	41 57		 push	 r15
  0000d	48 8d 6c 24 e1	 lea	 rbp, QWORD PTR [rsp-31]
  00012	48 81 ec c8 00
	00 00		 sub	 rsp, 200		; 000000c8H
  00019	48 c7 45 07 fe
	ff ff ff	 mov	 QWORD PTR $T8[rbp-169], -2
  00021	4c 8b f9	 mov	 r15, rcx
  00024	45 33 ed	 xor	 r13d, r13d
  00027	45 8b f5	 mov	 r14d, r13d
  0002a	44 89 6d 7f	 mov	 DWORD PTR $T13[rbp-169], r13d

; 644  : 		if (_Pcvt == 0 || !_Wrotesome)

  0002e	4c 39 69 68	 cmp	 QWORD PTR [rcx+104], r13
  00032	0f 84 a7 03 00
	00		 je	 $LN9@Endwrite
  00038	44 38 69 71	 cmp	 BYTE PTR [rcx+113], r13b
  0003c	0f 84 9d 03 00
	00		 je	 $LN9@Endwrite

; 650  : 			if (_Traits::eq_int_type(_Traits::eof(), overflow()))

  00042	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00045	83 ca ff	 or	 edx, -1
  00048	ff 50 18	 call	 QWORD PTR [rax+24]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 595  : 		return (_Left == _Right);

  0004b	83 f8 ff	 cmp	 eax, -1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream

; 650  : 			if (_Traits::eq_int_type(_Traits::eof(), overflow()))

  0004e	75 07		 jne	 SHORT $LN10@Endwrite

; 651  : 				return (false);

  00050	32 c0		 xor	 al, al
  00052	e9 8a 03 00 00	 jmp	 $LN8@Endwrite
$LN10@Endwrite:

; 652  : 
; 653  : 			string _Str(_STRING_INC, '\0');

  00057	45 33 c0	 xor	 r8d, r8d
  0005a	41 8d 50 08	 lea	 edx, QWORD PTR [r8+8]
  0005e	48 8d 4d 8f	 lea	 rcx, QWORD PTR _Str$2[rbp-169]
  00062	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00067	90		 npad	 1
  00068	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL2@Endwrite:

; 655  : 				switch (_Pcvt->unshift(_State,

  00070	48 8d 55 ef	 lea	 rdx, QWORD PTR $T7[rbp-169]
  00074	48 8d 4d 8f	 lea	 rcx, QWORD PTR _Str$2[rbp-169]
  00078	e8 00 00 00 00	 call	 ?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
  0007d	48 8b d8	 mov	 rbx, rax
  00080	48 8d 55 d7	 lea	 rdx, QWORD PTR $T6[rbp-169]
  00084	48 8d 4d 8f	 lea	 rcx, QWORD PTR _Str$2[rbp-169]
  00088	e8 00 00 00 00	 call	 ?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
  0008d	48 8b f0	 mov	 rsi, rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 332  : 		return ((reference)**(_Mybase *)this);

  00090	48 8b cb	 mov	 rcx, rbx
  00093	e8 00 00 00 00	 call	 ??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAAEBDXZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator*
  00098	48 8b f8	 mov	 rdi, rax

; 1742 : 		return (this->_Mysize());

  0009b	48 8b 5d a7	 mov	 rbx, QWORD PTR _Str$2[rbp-145]

; 332  : 		return ((reference)**(_Mybase *)this);

  0009f	48 8b ce	 mov	 rcx, rsi
  000a2	e8 00 00 00 00	 call	 ??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAAEBDXZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator*
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream

; 655  : 				switch (_Pcvt->unshift(_State,

  000a7	4c 8d 0c 3b	 lea	 r9, QWORD PTR [rbx+rdi]
  000ab	48 8d 4d cf	 lea	 rcx, QWORD PTR _Dest$5[rbp-169]
  000af	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  000b4	4c 8b c0	 mov	 r8, rax
  000b7	49 8d 57 74	 lea	 rdx, QWORD PTR [r15+116]
  000bb	49 8b 4f 68	 mov	 rcx, QWORD PTR [r15+104]
  000bf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?unshift@?$codecvt@DDU_Mbstatet@@@std@@QEBAHAEAU_Mbstatet@@PEAD1AEAPEAD@Z
  000c5	8b f8		 mov	 edi, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 142  : 		_Lockit _Lock(_LOCK_DEBUG);

  000c7	ba 03 00 00 00	 mov	 edx, 3
  000cc	48 8d 4d 67	 lea	 rcx, QWORD PTR _Lock$10[rbp-169]
  000d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0_Lockit@std@@QEAA@H@Z

; 194  : 		if (_Myproxy != 0)

  000d6	48 8b 5d d7	 mov	 rbx, QWORD PTR $T6[rbp-169]
  000da	48 85 db	 test	 rbx, rbx
  000dd	74 52		 je	 SHORT $LN71@Endwrite

; 195  : 			{	// adopted, remove self from list
; 196  : 			_Iterator_base12 **_Pnext = &_Myproxy->_Myfirstiter;

  000df	48 83 c3 08	 add	 rbx, 8

; 197  : 			while (*_Pnext != 0 && *_Pnext != this)

  000e3	48 83 3b 00	 cmp	 QWORD PTR [rbx], 0
  000e7	74 23		 je	 SHORT $LN341@Endwrite
  000e9	0f 1f 80 00 00
	00 00		 npad	 7
$LL69@Endwrite:
  000f0	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  000f3	48 8d 4d d7	 lea	 rcx, QWORD PTR $T6[rbp-169]
  000f7	48 3b c1	 cmp	 rax, rcx
  000fa	74 0a		 je	 SHORT $LN70@Endwrite

; 198  : 				_Pnext = &(*_Pnext)->_Mynextiter;

  000fc	48 8d 58 08	 lea	 rbx, QWORD PTR [rax+8]

; 197  : 			while (*_Pnext != 0 && *_Pnext != this)

  00100	48 83 3b 00	 cmp	 QWORD PTR [rbx], 0
  00104	75 ea		 jne	 SHORT $LL69@Endwrite
$LN70@Endwrite:

; 199  : 
; 200  : 			if (*_Pnext == 0)

  00106	48 83 3b 00	 cmp	 QWORD PTR [rbx], 0
  0010a	75 1a		 jne	 SHORT $LN72@Endwrite
$LN341@Endwrite:

; 201  : 				_DEBUG_ERROR("ITERATOR LIST CORRUPTED!");

  0010c	41 b8 c9 00 00
	00		 mov	 r8d, 201		; 000000c9H
  00112	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1JA@IJKHNLMB@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  00119	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@
  00120	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Debug_message@std@@YAXPEB_W0I@Z
$LN72@Endwrite:

; 202  : 			*_Pnext = _Mynextiter;

  00126	48 8b 45 df	 mov	 rax, QWORD PTR $T6[rbp-161]
  0012a	48 89 03	 mov	 QWORD PTR [rbx], rax

; 203  : 			_Myproxy = 0;

  0012d	4c 89 6d d7	 mov	 QWORD PTR $T6[rbp-169], r13
$LN71@Endwrite:

; 145  : 		}

  00131	48 8d 4d 67	 lea	 rcx, QWORD PTR _Lock$10[rbp-169]
  00135	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
  0013b	90		 npad	 1

; 142  : 		_Lockit _Lock(_LOCK_DEBUG);

  0013c	ba 03 00 00 00	 mov	 edx, 3
  00141	48 8d 4d 6f	 lea	 rcx, QWORD PTR _Lock$11[rbp-169]
  00145	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0_Lockit@std@@QEAA@H@Z

; 194  : 		if (_Myproxy != 0)

  0014b	48 8b 5d ef	 mov	 rbx, QWORD PTR $T7[rbp-169]
  0014f	48 85 db	 test	 rbx, rbx
  00152	74 4d		 je	 SHORT $LN89@Endwrite

; 195  : 			{	// adopted, remove self from list
; 196  : 			_Iterator_base12 **_Pnext = &_Myproxy->_Myfirstiter;

  00154	48 83 c3 08	 add	 rbx, 8

; 197  : 			while (*_Pnext != 0 && *_Pnext != this)

  00158	48 83 3b 00	 cmp	 QWORD PTR [rbx], 0
  0015c	74 1e		 je	 SHORT $LN342@Endwrite
  0015e	66 90		 npad	 2
$LL87@Endwrite:
  00160	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00163	48 8d 4d ef	 lea	 rcx, QWORD PTR $T7[rbp-169]
  00167	48 3b c1	 cmp	 rax, rcx
  0016a	74 0a		 je	 SHORT $LN88@Endwrite

; 198  : 				_Pnext = &(*_Pnext)->_Mynextiter;

  0016c	48 8d 58 08	 lea	 rbx, QWORD PTR [rax+8]

; 197  : 			while (*_Pnext != 0 && *_Pnext != this)

  00170	48 83 3b 00	 cmp	 QWORD PTR [rbx], 0
  00174	75 ea		 jne	 SHORT $LL87@Endwrite
$LN88@Endwrite:

; 199  : 
; 200  : 			if (*_Pnext == 0)

  00176	48 83 3b 00	 cmp	 QWORD PTR [rbx], 0
  0017a	75 1a		 jne	 SHORT $LN90@Endwrite
$LN342@Endwrite:

; 201  : 				_DEBUG_ERROR("ITERATOR LIST CORRUPTED!");

  0017c	41 b8 c9 00 00
	00		 mov	 r8d, 201		; 000000c9H
  00182	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1JA@IJKHNLMB@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  00189	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@
  00190	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Debug_message@std@@YAXPEB_W0I@Z
$LN90@Endwrite:

; 202  : 			*_Pnext = _Mynextiter;

  00196	48 8b 45 f7	 mov	 rax, QWORD PTR $T7[rbp-161]
  0019a	48 89 03	 mov	 QWORD PTR [rbx], rax

; 203  : 			_Myproxy = 0;

  0019d	4c 89 6d ef	 mov	 QWORD PTR $T7[rbp-169], r13
$LN89@Endwrite:

; 145  : 		}

  001a1	48 8d 4d 6f	 lea	 rcx, QWORD PTR _Lock$11[rbp-169]
  001a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
  001ab	90		 npad	 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream

; 655  : 				switch (_Pcvt->unshift(_State,

  001ac	85 ff		 test	 edi, edi
  001ae	74 0b		 je	 SHORT $LN11@Endwrite
  001b0	83 ef 01	 sub	 edi, 1
  001b3	0f 85 7b 01 00
	00		 jne	 $LN345@Endwrite
  001b9	eb 05		 jmp	 SHORT $LN12@Endwrite
$LN11@Endwrite:

; 656  : 					&*_Str.begin(), &*_Str.begin() + _Str.size(), _Dest))
; 657  : 				{	// test result of homing conversion
; 658  : 				case codecvt_base::ok:
; 659  : 					_Wrotesome = false;	// homed successfully

  001bb	41 c6 47 71 00	 mov	 BYTE PTR [r15+113], 0
$LN12@Endwrite:

; 663  : 					size_t _Count = _Dest - &*_Str.begin();

  001c0	48 8d 55 b7	 lea	 rdx, QWORD PTR $T4[rbp-169]
  001c4	48 8d 4d 8f	 lea	 rcx, QWORD PTR _Str$2[rbp-169]
  001c8	e8 00 00 00 00	 call	 ?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
  001cd	90		 npad	 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 332  : 		return ((reference)**(_Mybase *)this);

  001ce	48 8b c8	 mov	 rcx, rax
  001d1	e8 00 00 00 00	 call	 ??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAAEBDXZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator*
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream

; 663  : 					size_t _Count = _Dest - &*_Str.begin();

  001d6	48 8b 7d cf	 mov	 rdi, QWORD PTR _Dest$5[rbp-169]
  001da	48 2b f8	 sub	 rdi, rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 142  : 		_Lockit _Lock(_LOCK_DEBUG);

  001dd	ba 03 00 00 00	 mov	 edx, 3
  001e2	48 8d 4d 77	 lea	 rcx, QWORD PTR _Lock$12[rbp-169]
  001e6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0_Lockit@std@@QEAA@H@Z

; 194  : 		if (_Myproxy != 0)

  001ec	48 8b 5d b7	 mov	 rbx, QWORD PTR $T4[rbp-169]
  001f0	48 85 db	 test	 rbx, rbx
  001f3	74 4c		 je	 SHORT $LN109@Endwrite

; 195  : 			{	// adopted, remove self from list
; 196  : 			_Iterator_base12 **_Pnext = &_Myproxy->_Myfirstiter;

  001f5	48 83 c3 08	 add	 rbx, 8

; 197  : 			while (*_Pnext != 0 && *_Pnext != this)

  001f9	48 83 3b 00	 cmp	 QWORD PTR [rbx], 0
  001fd	74 1d		 je	 SHORT $LN343@Endwrite
  001ff	90		 npad	 1
$LL107@Endwrite:
  00200	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00203	48 8d 4d b7	 lea	 rcx, QWORD PTR $T4[rbp-169]
  00207	48 3b c1	 cmp	 rax, rcx
  0020a	74 0a		 je	 SHORT $LN108@Endwrite

; 198  : 				_Pnext = &(*_Pnext)->_Mynextiter;

  0020c	48 8d 58 08	 lea	 rbx, QWORD PTR [rax+8]

; 197  : 			while (*_Pnext != 0 && *_Pnext != this)

  00210	48 83 3b 00	 cmp	 QWORD PTR [rbx], 0
  00214	75 ea		 jne	 SHORT $LL107@Endwrite
$LN108@Endwrite:

; 199  : 
; 200  : 			if (*_Pnext == 0)

  00216	48 83 3b 00	 cmp	 QWORD PTR [rbx], 0
  0021a	75 1a		 jne	 SHORT $LN110@Endwrite
$LN343@Endwrite:

; 201  : 				_DEBUG_ERROR("ITERATOR LIST CORRUPTED!");

  0021c	41 b8 c9 00 00
	00		 mov	 r8d, 201		; 000000c9H
  00222	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1JA@IJKHNLMB@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  00229	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@
  00230	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Debug_message@std@@YAXPEB_W0I@Z
$LN110@Endwrite:

; 202  : 			*_Pnext = _Mynextiter;

  00236	48 8b 45 bf	 mov	 rax, QWORD PTR $T4[rbp-161]
  0023a	48 89 03	 mov	 QWORD PTR [rbx], rax

; 203  : 			_Myproxy = 0;

  0023d	4c 89 6d b7	 mov	 QWORD PTR $T4[rbp-169], r13
$LN109@Endwrite:

; 145  : 		}

  00241	48 8d 4d 77	 lea	 rcx, QWORD PTR _Lock$12[rbp-169]
  00245	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
  0024b	90		 npad	 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream

; 664  : 					if (0 < _Count && _Count !=

  0024c	48 85 ff	 test	 rdi, rdi
  0024f	74 40		 je	 SHORT $LN19@Endwrite
  00251	48 8d 55 b7	 lea	 rdx, QWORD PTR $T3[rbp-169]
  00255	48 8d 4d 8f	 lea	 rcx, QWORD PTR _Str$2[rbp-169]
  00259	e8 00 00 00 00	 call	 ?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
  0025e	90		 npad	 1
  0025f	41 83 ce 01	 or	 r14d, 1
  00263	44 89 75 7f	 mov	 DWORD PTR $T13[rbp-169], r14d
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 332  : 		return ((reference)**(_Mybase *)this);

  00267	48 8b c8	 mov	 rcx, rax
  0026a	e8 00 00 00 00	 call	 ??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAAEBDXZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator*
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream

; 664  : 					if (0 < _Count && _Count !=

  0026f	4d 8b 8f 80 00
	00 00		 mov	 r9, QWORD PTR [r15+128]
  00276	4c 8b c7	 mov	 r8, rdi
  00279	ba 01 00 00 00	 mov	 edx, 1
  0027e	48 8b c8	 mov	 rcx, rax
  00281	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwrite
  00287	48 3b f8	 cmp	 rdi, rax
  0028a	74 05		 je	 SHORT $LN19@Endwrite
  0028c	40 b6 01	 mov	 sil, 1
  0028f	eb 03		 jmp	 SHORT $LN20@Endwrite
$LN19@Endwrite:
  00291	40 32 f6	 xor	 sil, sil
$LN20@Endwrite:
  00294	41 f6 c6 01	 test	 r14b, 1
  00298	74 72		 je	 SHORT $LN124@Endwrite
  0029a	41 83 e6 fe	 and	 r14d, -2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 142  : 		_Lockit _Lock(_LOCK_DEBUG);

  0029e	ba 03 00 00 00	 mov	 edx, 3
  002a3	48 8d 4d 87	 lea	 rcx, QWORD PTR _Lock$1[rbp-169]
  002a7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0_Lockit@std@@QEAA@H@Z

; 194  : 		if (_Myproxy != 0)

  002ad	48 8b 5d b7	 mov	 rbx, QWORD PTR $T3[rbp-169]
  002b1	48 85 db	 test	 rbx, rbx
  002b4	74 4b		 je	 SHORT $LN129@Endwrite

; 195  : 			{	// adopted, remove self from list
; 196  : 			_Iterator_base12 **_Pnext = &_Myproxy->_Myfirstiter;

  002b6	48 83 c3 08	 add	 rbx, 8

; 197  : 			while (*_Pnext != 0 && *_Pnext != this)

  002ba	48 83 3b 00	 cmp	 QWORD PTR [rbx], 0
  002be	74 1c		 je	 SHORT $LN344@Endwrite
$LL127@Endwrite:
  002c0	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  002c3	48 8d 4d b7	 lea	 rcx, QWORD PTR $T3[rbp-169]
  002c7	48 3b c1	 cmp	 rax, rcx
  002ca	74 0a		 je	 SHORT $LN128@Endwrite

; 198  : 				_Pnext = &(*_Pnext)->_Mynextiter;

  002cc	48 8d 58 08	 lea	 rbx, QWORD PTR [rax+8]

; 197  : 			while (*_Pnext != 0 && *_Pnext != this)

  002d0	48 83 3b 00	 cmp	 QWORD PTR [rbx], 0
  002d4	75 ea		 jne	 SHORT $LL127@Endwrite
$LN128@Endwrite:

; 199  : 
; 200  : 			if (*_Pnext == 0)

  002d6	48 83 3b 00	 cmp	 QWORD PTR [rbx], 0
  002da	75 1a		 jne	 SHORT $LN130@Endwrite
$LN344@Endwrite:

; 201  : 				_DEBUG_ERROR("ITERATOR LIST CORRUPTED!");

  002dc	41 b8 c9 00 00
	00		 mov	 r8d, 201		; 000000c9H
  002e2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1JA@IJKHNLMB@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  002e9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@
  002f0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Debug_message@std@@YAXPEB_W0I@Z
$LN130@Endwrite:

; 202  : 			*_Pnext = _Mynextiter;

  002f6	48 8b 45 bf	 mov	 rax, QWORD PTR $T3[rbp-161]
  002fa	48 89 03	 mov	 QWORD PTR [rbx], rax

; 203  : 			_Myproxy = 0;

  002fd	4c 89 6d b7	 mov	 QWORD PTR $T3[rbp-169], r13
$LN129@Endwrite:

; 145  : 		}

  00301	48 8d 4d 87	 lea	 rcx, QWORD PTR _Lock$1[rbp-169]
  00305	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
  0030b	90		 npad	 1
$LN124@Endwrite:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream

; 664  : 					if (0 < _Count && _Count !=

  0030c	40 84 f6	 test	 sil, sil
  0030f	75 2c		 jne	 SHORT $LN322@Endwrite

; 665  : 						fwrite(&*_Str.begin(), 1, _Count, _Myfile))
; 666  : 						return (false);	// write failed
; 667  : 					if (!_Wrotesome)

  00311	41 38 77 71	 cmp	 BYTE PTR [r15+113], sil
  00315	74 22		 je	 SHORT $LN323@Endwrite

; 668  : 						return (true);
; 669  : 					if (_Count == 0)

  00317	48 85 ff	 test	 rdi, rdi
  0031a	0f 85 50 fd ff
	ff		 jne	 $LL2@Endwrite

; 670  : 						_Str.append(_STRING_INC, '\0');	// try with more space

  00320	45 33 c0	 xor	 r8d, r8d
  00323	8d 57 08	 lea	 edx, QWORD PTR [rdi+8]
  00326	48 8d 4d 8f	 lea	 rcx, QWORD PTR _Str$2[rbp-169]
  0032a	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 679  : 				}

  0032f	e9 3c fd ff ff	 jmp	 $LL2@Endwrite
$LN345@Endwrite:

; 655  : 				switch (_Pcvt->unshift(_State,

  00334	83 ff 02	 cmp	 edi, 2
  00337	75 04		 jne	 SHORT $LN322@Endwrite
$LN323@Endwrite:

; 671  : 					break;
; 672  : 					}
; 673  : 
; 674  : 				case codecvt_base::noconv:
; 675  : 					return (true);	// nothing to do

  00339	b3 01		 mov	 bl, 1
  0033b	eb 02		 jmp	 SHORT $LN30@Endwrite
$LN322@Endwrite:
  0033d	32 db		 xor	 bl, bl
$LN30@Endwrite:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2246 : 		else if (this->_BUF_SIZE <= this->_Myres())

  0033f	48 8b 55 af	 mov	 rdx, QWORD PTR _Str$2[rbp-137]
  00343	48 83 fa 10	 cmp	 rdx, 16
  00347	72 12		 jb	 SHORT $LN138@Endwrite

; 2247 : 			{	// copy any leftovers to small buffer and deallocate
; 2248 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2249 : 			this->_Getal().destroy(&this->_Bx()._Ptr);
; 2250 : 			if (0 < _Newsize)
; 2251 : 				_Traits::copy(this->_Bx()._Buf,
; 2252 : 					_STD addressof(*_Ptr), _Newsize);
; 2253 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

  00349	48 ff c2	 inc	 rdx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 620  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  0034c	41 b8 01 00 00
	00		 mov	 r8d, 1
  00352	48 8b 4d 97	 mov	 rcx, QWORD PTR _Str$2[rbp-161]
  00356	e8 00 00 00 00	 call	 ?_Deallocate@std@@YAXPEAX_K1@Z ; std::_Deallocate
$LN138@Endwrite:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2255 : 		this->_Myres() = this->_BUF_SIZE - 1;

  0035b	48 c7 45 af 0f
	00 00 00	 mov	 QWORD PTR _Str$2[rbp-137], 15

; 2214 : 		_Traits::assign(this->_Myptr()[this->_Mysize() = _Newsize], _Elem());

  00363	4c 89 6d a7	 mov	 QWORD PTR _Str$2[rbp-145], r13
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  00367	c6 45 97 00	 mov	 BYTE PTR _Str$2[rbp-161], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 216  : 	if (_Myproxy != 0)

  0036b	48 8b 4d 8f	 mov	 rcx, QWORD PTR _Str$2[rbp-169]
  0036f	48 85 c9	 test	 rcx, rcx
  00372	74 4a		 je	 SHORT $LN276@Endwrite

; 217  : 		{	// proxy allocated, drain it
; 218  : 		_Lockit _Lock(_LOCK_DEBUG);

  00374	ba 03 00 00 00	 mov	 edx, 3
  00379	48 8d 4d 67	 lea	 rcx, QWORD PTR _Lock$9[rbp-169]
  0037d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0_Lockit@std@@QEAA@H@Z

; 219  : 
; 220  : 		for (_Iterator_base12 **_Pnext = &_Myproxy->_Myfirstiter;

  00383	4c 8b 45 8f	 mov	 r8, QWORD PTR _Str$2[rbp-169]

; 221  : 			*_Pnext != 0; *_Pnext = (*_Pnext)->_Mynextiter)

  00387	49 83 78 08 00	 cmp	 QWORD PTR [r8+8], 0
  0038c	74 1e		 je	 SHORT $LN274@Endwrite
  0038e	66 90		 npad	 2
$LL275@Endwrite:

; 222  : 			(*_Pnext)->_Myproxy = 0;

  00390	49 8b 40 08	 mov	 rax, QWORD PTR [r8+8]
  00394	4c 89 28	 mov	 QWORD PTR [rax], r13

; 221  : 			*_Pnext != 0; *_Pnext = (*_Pnext)->_Mynextiter)

  00397	49 8b 40 08	 mov	 rax, QWORD PTR [r8+8]
  0039b	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0039f	49 89 48 08	 mov	 QWORD PTR [r8+8], rcx
  003a3	48 85 c9	 test	 rcx, rcx
  003a6	75 e8		 jne	 SHORT $LL275@Endwrite
  003a8	4c 8b 45 8f	 mov	 r8, QWORD PTR _Str$2[rbp-169]
$LN274@Endwrite:

; 223  : 		_Myproxy->_Myfirstiter = 0;

  003ac	4d 89 68 08	 mov	 QWORD PTR [r8+8], r13

; 224  : 		}

  003b0	48 8d 4d 67	 lea	 rcx, QWORD PTR _Lock$9[rbp-169]
  003b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
  003ba	48 8b 4d 8f	 mov	 rcx, QWORD PTR _Str$2[rbp-169]
$LN276@Endwrite:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 620  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  003be	ba 01 00 00 00	 mov	 edx, 1
  003c3	44 8d 42 0f	 lea	 r8d, QWORD PTR [rdx+15]
  003c7	e8 00 00 00 00	 call	 ?_Deallocate@std@@YAXPEAX_K1@Z ; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 655  : 		_Myproxy() = 0;

  003cc	4c 89 6d 8f	 mov	 QWORD PTR _Str$2[rbp-169], r13
  003d0	48 8d 4d 8f	 lea	 rcx, QWORD PTR _Str$2[rbp-169]
  003d4	e8 00 00 00 00	 call	 ??1_Container_base12@std@@QEAA@XZ ; std::_Container_base12::~_Container_base12
  003d9	90		 npad	 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream

; 678  : 					return (false);	// conversion failed

  003da	0f b6 c3	 movzx	 eax, bl
  003dd	eb 02		 jmp	 SHORT $LN8@Endwrite
$LN9@Endwrite:

; 645  : 			return (true);

  003df	b0 01		 mov	 al, 1
$LN8@Endwrite:

; 680  : 			}
; 681  : 		}

  003e1	48 81 c4 c8 00
	00 00		 add	 rsp, 200		; 000000c8H
  003e8	41 5f		 pop	 r15
  003ea	41 5e		 pop	 r14
  003ec	41 5d		 pop	 r13
  003ee	41 5c		 pop	 r12
  003f0	5f		 pop	 rdi
  003f1	5e		 pop	 rsi
  003f2	5b		 pop	 rbx
  003f3	5d		 pop	 rbp
  003f4	c3		 ret	 0
?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
_Lock$1 = 48
_Str$2 = 56
$T3 = 96
$T4 = 96
_Dest$5 = 120
$T6 = 128
$T7 = 152
$T8 = 176
_Lock$9 = 272
_Lock$10 = 272
this$ = 272
_Lock$11 = 280
_Lock$12 = 288
$T13 = 296
?dtor$0@?0??_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::_Endwrite'::`1'::dtor$0
  00000	48 8d 8a 38 00
	00 00		 lea	 rcx, QWORD PTR _Str$2[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::_Endwrite'::`1'::dtor$0
_Lock$1 = 48
_Str$2 = 56
$T3 = 96
$T4 = 96
_Dest$5 = 120
$T6 = 128
$T7 = 152
$T8 = 176
_Lock$9 = 272
_Lock$10 = 272
this$ = 272
_Lock$11 = 280
_Lock$12 = 288
$T13 = 296
?dtor$1@?0??_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::_Endwrite'::`1'::dtor$1
  0000c	48 8d 8a 98 00
	00 00		 lea	 rcx, QWORD PTR $T7[rdx]
  00013	e9 00 00 00 00	 jmp	 ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@XZ
?dtor$1@?0??_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::_Endwrite'::`1'::dtor$1
_Lock$1 = 48
_Str$2 = 56
$T3 = 96
$T4 = 96
_Dest$5 = 120
$T6 = 128
$T7 = 152
$T8 = 176
_Lock$9 = 272
_Lock$10 = 272
this$ = 272
_Lock$11 = 280
_Lock$12 = 288
$T13 = 296
?dtor$2@?0??_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::_Endwrite'::`1'::dtor$2
  00018	48 8d 8a 80 00
	00 00		 lea	 rcx, QWORD PTR $T6[rdx]
  0001f	e9 00 00 00 00	 jmp	 ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@XZ
?dtor$2@?0??_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::_Endwrite'::`1'::dtor$2
_Lock$1 = 48
_Str$2 = 56
$T3 = 96
$T4 = 96
_Dest$5 = 120
$T6 = 128
$T7 = 152
$T8 = 176
_Lock$9 = 272
_Lock$10 = 272
this$ = 272
_Lock$11 = 280
_Lock$12 = 288
$T13 = 296
?dtor$15@?0??_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::_Endwrite'::`1'::dtor$15
  00024	e9 00 00 00 00	 jmp	 __std_terminate
?dtor$15@?0??_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::_Endwrite'::`1'::dtor$15
_Lock$1 = 48
_Str$2 = 56
$T3 = 96
$T4 = 96
_Dest$5 = 120
$T6 = 128
$T7 = 152
$T8 = 176
_Lock$9 = 272
_Lock$10 = 272
this$ = 272
_Lock$11 = 280
_Lock$12 = 288
$T13 = 296
?dtor$19@?0??_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::_Endwrite'::`1'::dtor$19
  00029	e9 00 00 00 00	 jmp	 __std_terminate
?dtor$19@?0??_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::_Endwrite'::`1'::dtor$19
_Lock$1 = 48
_Str$2 = 56
$T3 = 96
$T4 = 96
_Dest$5 = 120
$T6 = 128
$T7 = 152
$T8 = 176
_Lock$9 = 272
_Lock$10 = 272
this$ = 272
_Lock$11 = 280
_Lock$12 = 288
$T13 = 296
?dtor$3@?0??_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::_Endwrite'::`1'::dtor$3
  0002e	48 8d 8a 60 00
	00 00		 lea	 rcx, QWORD PTR $T4[rdx]
  00035	e9 00 00 00 00	 jmp	 ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@XZ
?dtor$3@?0??_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::_Endwrite'::`1'::dtor$3
_Lock$1 = 48
_Str$2 = 56
$T3 = 96
$T4 = 96
_Dest$5 = 120
$T6 = 128
$T7 = 152
$T8 = 176
_Lock$9 = 272
_Lock$10 = 272
this$ = 272
_Lock$11 = 280
_Lock$12 = 288
$T13 = 296
?dtor$23@?0??_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::_Endwrite'::`1'::dtor$23
  0003a	e9 00 00 00 00	 jmp	 __std_terminate
?dtor$23@?0??_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::_Endwrite'::`1'::dtor$23
_Lock$1 = 48
_Str$2 = 56
$T3 = 96
$T4 = 96
_Dest$5 = 120
$T6 = 128
$T7 = 152
$T8 = 176
_Lock$9 = 272
_Lock$10 = 272
this$ = 272
_Lock$11 = 280
_Lock$12 = 288
$T13 = 296
?dtor$4@?0??_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::_Endwrite'::`1'::dtor$4
  0003f	40 55		 push	 rbp
  00041	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00045	48 8b ea	 mov	 rbp, rdx
  00048	8b 85 28 01 00
	00		 mov	 eax, DWORD PTR $T13[rbp]
  0004e	83 e0 01	 and	 eax, 1
  00051	85 c0		 test	 eax, eax
  00053	74 10		 je	 SHORT $LN26@dtor$4
  00055	83 a5 28 01 00
	00 fe		 and	 DWORD PTR $T13[rbp], -2
  0005c	48 8d 4d 60	 lea	 rcx, QWORD PTR $T3[rbp]
  00060	e8 00 00 00 00	 call	 ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@XZ
$LN26@dtor$4:
  00065	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00069	5d		 pop	 rbp
  0006a	c3		 ret	 0
?dtor$4@?0??_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::_Endwrite'::`1'::dtor$4
_Lock$1 = 48
_Str$2 = 56
$T3 = 96
$T4 = 96
_Dest$5 = 120
$T6 = 128
$T7 = 152
$T8 = 176
_Lock$9 = 272
_Lock$10 = 272
this$ = 272
_Lock$11 = 280
_Lock$12 = 288
$T13 = 296
?dtor$27@?0??_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::_Endwrite'::`1'::dtor$27
  0006b	e9 00 00 00 00	 jmp	 __std_terminate
?dtor$27@?0??_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::_Endwrite'::`1'::dtor$27
_Lock$1 = 48
_Str$2 = 56
$T3 = 96
$T4 = 96
_Dest$5 = 120
$T6 = 128
$T7 = 152
$T8 = 176
_Lock$9 = 272
_Lock$10 = 272
this$ = 272
_Lock$11 = 280
_Lock$12 = 288
$T13 = 296
?dtor$61@?0??_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::_Endwrite'::`1'::dtor$61
  00070	e9 00 00 00 00	 jmp	 __std_terminate
?dtor$61@?0??_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::_Endwrite'::`1'::dtor$61
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Lock$1 = 48
_Str$2 = 56
$T3 = 96
$T4 = 96
_Dest$5 = 120
$T6 = 128
$T7 = 152
$T8 = 176
_Lock$9 = 272
_Lock$10 = 272
this$ = 272
_Lock$11 = 280
_Lock$12 = 288
$T13 = 296
?dtor$0@?0??_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::_Endwrite'::`1'::dtor$0
  00000	48 8d 8a 38 00
	00 00		 lea	 rcx, QWORD PTR _Str$2[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::_Endwrite'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Lock$1 = 48
_Str$2 = 56
$T3 = 96
$T4 = 96
_Dest$5 = 120
$T6 = 128
$T7 = 152
$T8 = 176
_Lock$9 = 272
_Lock$10 = 272
this$ = 272
_Lock$11 = 280
_Lock$12 = 288
$T13 = 296
?dtor$1@?0??_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::_Endwrite'::`1'::dtor$1
  0000c	48 8d 8a 98 00
	00 00		 lea	 rcx, QWORD PTR $T7[rdx]
  00013	e9 00 00 00 00	 jmp	 ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@XZ
?dtor$1@?0??_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::_Endwrite'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Lock$1 = 48
_Str$2 = 56
$T3 = 96
$T4 = 96
_Dest$5 = 120
$T6 = 128
$T7 = 152
$T8 = 176
_Lock$9 = 272
_Lock$10 = 272
this$ = 272
_Lock$11 = 280
_Lock$12 = 288
$T13 = 296
?dtor$2@?0??_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::_Endwrite'::`1'::dtor$2
  00018	48 8d 8a 80 00
	00 00		 lea	 rcx, QWORD PTR $T6[rdx]
  0001f	e9 00 00 00 00	 jmp	 ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@XZ
?dtor$2@?0??_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::_Endwrite'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Lock$1 = 48
_Str$2 = 56
$T3 = 96
$T4 = 96
_Dest$5 = 120
$T6 = 128
$T7 = 152
$T8 = 176
_Lock$9 = 272
_Lock$10 = 272
this$ = 272
_Lock$11 = 280
_Lock$12 = 288
$T13 = 296
?dtor$15@?0??_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::_Endwrite'::`1'::dtor$15
  00024	e9 00 00 00 00	 jmp	 __std_terminate
?dtor$15@?0??_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::_Endwrite'::`1'::dtor$15
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Lock$1 = 48
_Str$2 = 56
$T3 = 96
$T4 = 96
_Dest$5 = 120
$T6 = 128
$T7 = 152
$T8 = 176
_Lock$9 = 272
_Lock$10 = 272
this$ = 272
_Lock$11 = 280
_Lock$12 = 288
$T13 = 296
?dtor$19@?0??_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::_Endwrite'::`1'::dtor$19
  00029	e9 00 00 00 00	 jmp	 __std_terminate
?dtor$19@?0??_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::_Endwrite'::`1'::dtor$19
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Lock$1 = 48
_Str$2 = 56
$T3 = 96
$T4 = 96
_Dest$5 = 120
$T6 = 128
$T7 = 152
$T8 = 176
_Lock$9 = 272
_Lock$10 = 272
this$ = 272
_Lock$11 = 280
_Lock$12 = 288
$T13 = 296
?dtor$3@?0??_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::_Endwrite'::`1'::dtor$3
  0002e	48 8d 8a 60 00
	00 00		 lea	 rcx, QWORD PTR $T4[rdx]
  00035	e9 00 00 00 00	 jmp	 ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@XZ
?dtor$3@?0??_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::_Endwrite'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Lock$1 = 48
_Str$2 = 56
$T3 = 96
$T4 = 96
_Dest$5 = 120
$T6 = 128
$T7 = 152
$T8 = 176
_Lock$9 = 272
_Lock$10 = 272
this$ = 272
_Lock$11 = 280
_Lock$12 = 288
$T13 = 296
?dtor$23@?0??_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::_Endwrite'::`1'::dtor$23
  0003a	e9 00 00 00 00	 jmp	 __std_terminate
?dtor$23@?0??_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::_Endwrite'::`1'::dtor$23
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Lock$1 = 48
_Str$2 = 56
$T3 = 96
$T4 = 96
_Dest$5 = 120
$T6 = 128
$T7 = 152
$T8 = 176
_Lock$9 = 272
_Lock$10 = 272
this$ = 272
_Lock$11 = 280
_Lock$12 = 288
$T13 = 296
?dtor$4@?0??_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::_Endwrite'::`1'::dtor$4
  0003f	40 55		 push	 rbp
  00041	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00045	48 8b ea	 mov	 rbp, rdx
  00048	8b 85 28 01 00
	00		 mov	 eax, DWORD PTR $T13[rbp]
  0004e	83 e0 01	 and	 eax, 1
  00051	85 c0		 test	 eax, eax
  00053	74 10		 je	 SHORT $LN26@dtor$4
  00055	83 a5 28 01 00
	00 fe		 and	 DWORD PTR $T13[rbp], -2
  0005c	48 8d 4d 60	 lea	 rcx, QWORD PTR $T3[rbp]
  00060	e8 00 00 00 00	 call	 ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@XZ
$LN26@dtor$4:
  00065	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00069	5d		 pop	 rbp
  0006a	c3		 ret	 0
?dtor$4@?0??_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::_Endwrite'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Lock$1 = 48
_Str$2 = 56
$T3 = 96
$T4 = 96
_Dest$5 = 120
$T6 = 128
$T7 = 152
$T8 = 176
_Lock$9 = 272
_Lock$10 = 272
this$ = 272
_Lock$11 = 280
_Lock$12 = 288
$T13 = 296
?dtor$27@?0??_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::_Endwrite'::`1'::dtor$27
  0006b	e9 00 00 00 00	 jmp	 __std_terminate
?dtor$27@?0??_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::_Endwrite'::`1'::dtor$27
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Lock$1 = 48
_Str$2 = 56
$T3 = 96
$T4 = 96
_Dest$5 = 120
$T6 = 128
$T7 = 152
$T8 = 176
_Lock$9 = 272
_Lock$10 = 272
this$ = 272
_Lock$11 = 280
_Lock$12 = 288
$T13 = 296
?dtor$61@?0??_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::_Endwrite'::`1'::dtor$61
  00070	e9 00 00 00 00	 jmp	 __std_terminate
?dtor$61@?0??_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::_Endwrite'::`1'::dtor$61
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
;	COMDAT ?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@12@@Z
_TEXT	SEGMENT
_Pb$1 = 64
this$ = 64
_Pn$2 = 72
_File$ = 72
_Which$ = 80
_Nr$3 = 88
?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@12@@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Init, COMDAT

; 604  : 		{	// initialize to C stream _File after {new, open, close}

$LN13:
  00000	40 53		 push	 rbx
  00002	56		 push	 rsi
  00003	57		 push	 rdi
  00004	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 605  : 		__PURE_APPDOMAIN_GLOBAL static _Myst _Stinit;	// initial state
; 606  : 
; 607  : 		_Closef = _Which == _Openfl;

  00008	41 83 f8 01	 cmp	 r8d, 1

; 608  : 		_Wrotesome = false;

  0000c	c6 41 71 00	 mov	 BYTE PTR [rcx+113], 0
  00010	48 8b fa	 mov	 rdi, rdx
  00013	48 8b d9	 mov	 rbx, rcx
  00016	0f 94 c0	 sete	 al
  00019	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 609  : 
; 610  : 		_Mysb::_Init();	// initialize stream buffer base object

  0001c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXXZ

; 611  : 
; 612  :  #ifndef _IORCNT
; 613  :   #define _IORCNT	_IOCNT	/* read and write counts are the same */
; 614  :   #define _IOWCNT _IOCNT
; 615  :  #endif /* _IORCNT */
; 616  : 
; 617  :   #pragma warning(push)
; 618  :   #pragma warning(disable: 6240)	/* prefast noise VSW 489858 */
; 619  : 		if (_File != 0 && sizeof (_Elem) == 1)

  00022	33 f6		 xor	 esi, esi
  00024	48 85 ff	 test	 rdi, rdi
  00027	74 4e		 je	 SHORT $LN2@Init

; 620  :   #pragma warning(pop)
; 621  : 
; 622  : 			{	// point inside C stream with [first, first + count) buffer
; 623  : 			_Elem **_Pb = 0;
; 624  : 			_Elem **_Pn = 0;
; 625  : 			int *_Nr = 0;
; 626  : 
; 627  : 			::_get_stream_buffer_pointers(

  00029	4c 8d 4c 24 58	 lea	 r9, QWORD PTR _Nr$3[rsp]
  0002e	48 89 74 24 40	 mov	 QWORD PTR _Pb$1[rsp], rsi
  00033	4c 8d 44 24 48	 lea	 r8, QWORD PTR _Pn$2[rsp]
  00038	48 89 74 24 48	 mov	 QWORD PTR _Pn$2[rsp], rsi
  0003d	48 8d 54 24 40	 lea	 rdx, QWORD PTR _Pb$1[rsp]
  00042	48 89 74 24 58	 mov	 QWORD PTR _Nr$3[rsp], rsi
  00047	48 8b cf	 mov	 rcx, rdi
  0004a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__get_stream_buffer_pointers
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 332  : 		_IGfirst = _Gf;

  00050	48 8b 44 24 40	 mov	 rax, QWORD PTR _Pb$1[rsp]
  00055	48 89 43 18	 mov	 QWORD PTR [rbx+24], rax

; 333  : 		_IPfirst = _Pf;

  00059	48 89 43 20	 mov	 QWORD PTR [rbx+32], rax

; 334  : 		_IGnext = _Gn;

  0005d	48 8b 44 24 48	 mov	 rax, QWORD PTR _Pn$2[rsp]
  00062	48 89 43 38	 mov	 QWORD PTR [rbx+56], rax

; 335  : 		_IPnext = _Pn;

  00066	48 89 43 40	 mov	 QWORD PTR [rbx+64], rax

; 336  : 		_IGcount = _Gc;

  0006a	48 8b 44 24 58	 mov	 rax, QWORD PTR _Nr$3[rsp]
  0006f	48 89 43 50	 mov	 QWORD PTR [rbx+80], rax

; 337  : 		_IPcount = _Pc;

  00073	48 89 43 58	 mov	 QWORD PTR [rbx+88], rax
$LN2@Init:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream

; 637  : 		_Myfile = _File;

  00077	48 89 bb 80 00
	00 00		 mov	 QWORD PTR [rbx+128], rdi

; 638  : 		_State = _Stinit;

  0007e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit
  00085	48 89 43 74	 mov	 QWORD PTR [rbx+116], rax

; 639  : 		_Pcvt = 0;	// pointer to codecvt facet

  00089	48 89 73 68	 mov	 QWORD PTR [rbx+104], rsi

; 640  : 		}

  0008d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00091	5f		 pop	 rdi
  00092	5e		 pop	 rsi
  00093	5b		 pop	 rbx
  00094	c3		 ret	 0
?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@12@@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Init
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
;	COMDAT ?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAXAEBVlocale@2@@Z
_TEXT	SEGMENT
this$ = 48
_Loc$ = 56
?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAXAEBVlocale@2@@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::imbue, COMDAT

; 599  : 		{	// set locale to argument (capture nontrivial codecvt facet)

$LN14:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b d9	 mov	 rbx, rcx

; 600  : 		_Initcvt(&_USE(_Loc, _Cvt));

  0000d	48 8b ca	 mov	 rcx, rdx
  00010	e8 00 00 00 00	 call	 ??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z ; std::use_facet<std::codecvt<char,char,_Mbstatet> >

; 685  : 		if (_Newpcvt->always_noconv())

  00015	48 8b c8	 mov	 rcx, rax

; 600  : 		_Initcvt(&_USE(_Loc, _Cvt));

  00018	48 8b f8	 mov	 rdi, rax

; 685  : 		if (_Newpcvt->always_noconv())

  0001b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?always_noconv@codecvt_base@std@@QEBA_NXZ
  00021	84 c0		 test	 al, al
  00023	74 13		 je	 SHORT $LN4@imbue

; 686  : 			_Pcvt = 0;	// nothing to do

  00025	48 c7 43 68 00
	00 00 00	 mov	 QWORD PTR [rbx+104], 0

; 601  : 		}

  0002d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00032	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00036	5f		 pop	 rdi
  00037	c3		 ret	 0
$LN4@imbue:

; 690  : 			_Mysb::_Init();	// reset any buffering

  00038	48 8b cb	 mov	 rcx, rbx
  0003b	48 89 7b 68	 mov	 QWORD PTR [rbx+104], rdi

; 601  : 		}

  0003f	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00044	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00048	5f		 pop	 rdi

; 690  : 			_Mysb::_Init();	// reset any buffering

  00049	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXXZ
?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAXAEBVlocale@2@@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::imbue
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
;	COMDAT ?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
_TEXT	SEGMENT
this$ = 48
?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::sync, COMDAT

; 592  : 		{	// synchronize C stream with external file

$LN15:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 593  : 		return (_Myfile == 0

  00006	48 83 b9 80 00
	00 00 00	 cmp	 QWORD PTR [rcx+128], 0
  0000e	48 8b d9	 mov	 rbx, rcx
  00011	74 28		 je	 SHORT $LN3@sync
  00013	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00016	83 ca ff	 or	 edx, -1
  00019	ff 50 18	 call	 QWORD PTR [rax+24]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 595  : 		return (_Left == _Right);

  0001c	83 f8 ff	 cmp	 eax, -1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream

; 593  : 		return (_Myfile == 0

  0001f	74 1a		 je	 SHORT $LN3@sync
  00021	48 8b 8b 80 00
	00 00		 mov	 rcx, QWORD PTR [rbx+128]
  00028	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fflush
  0002e	85 c0		 test	 eax, eax
  00030	79 09		 jns	 SHORT $LN3@sync
  00032	83 c8 ff	 or	 eax, -1

; 594  : 			|| _Traits::eq_int_type(_Traits::eof(), overflow())
; 595  : 			|| 0 <= fflush(_Myfile) ? 0 : -1);
; 596  : 		}

  00035	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00039	5b		 pop	 rbx
  0003a	c3		 ret	 0
$LN3@sync:

; 593  : 		return (_Myfile == 0

  0003b	33 c0		 xor	 eax, eax

; 594  : 			|| _Traits::eq_int_type(_Traits::eof(), overflow())
; 595  : 			|| 0 <= fflush(_Myfile) ? 0 : -1);
; 596  : 		}

  0003d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00041	5b		 pop	 rbx
  00042	c3		 ret	 0
?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::sync
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
;	COMDAT ?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z
_TEXT	SEGMENT
_Nr$1 = 32
_Pb$2 = 64
this$ = 64
_Buffer$ = 72
_Count$ = 80
_Pn$3 = 88
?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::setbuf, COMDAT

; 579  : 		{	// offer _Buffer to C stream

$LN20:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	56		 push	 rsi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b d9	 mov	 rbx, rcx
  0000d	4d 8b c8	 mov	 r9, r8

; 580  : 		if (_Myfile == 0 || setvbuf(_Myfile, (char *)_Buffer,

  00010	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  00017	48 85 c9	 test	 rcx, rcx
  0001a	0f 84 ba 00 00
	00		 je	 $LN4@setbuf
  00020	33 f6		 xor	 esi, esi
  00022	48 85 d2	 test	 rdx, rdx
  00025	75 09		 jne	 SHORT $LN6@setbuf
  00027	4d 85 c0	 test	 r8, r8
  0002a	44 8d 46 04	 lea	 r8d, QWORD PTR [rsi+4]
  0002e	74 03		 je	 SHORT $LN7@setbuf
$LN6@setbuf:
  00030	44 8b c6	 mov	 r8d, esi
$LN7@setbuf:
  00033	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_setvbuf
  00039	85 c0		 test	 eax, eax
  0003b	0f 85 99 00 00
	00		 jne	 $LN4@setbuf
  00041	48 89 7c 24 48	 mov	 QWORD PTR [rsp+72], rdi

; 610  : 		_Mysb::_Init();	// initialize stream buffer base object

  00046	48 8b cb	 mov	 rcx, rbx

; 584  : 		else
; 585  : 			{	// new buffer, reinitialize pointers
; 586  : 			_Init(_Myfile, _Openfl);

  00049	48 8b bb 80 00
	00 00		 mov	 rdi, QWORD PTR [rbx+128]

; 607  : 		_Closef = _Which == _Openfl;

  00050	c6 43 7c 01	 mov	 BYTE PTR [rbx+124], 1

; 608  : 		_Wrotesome = false;

  00054	40 88 73 71	 mov	 BYTE PTR [rbx+113], sil

; 609  : 
; 610  : 		_Mysb::_Init();	// initialize stream buffer base object

  00058	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXXZ

; 611  : 
; 612  :  #ifndef _IORCNT
; 613  :   #define _IORCNT	_IOCNT	/* read and write counts are the same */
; 614  :   #define _IOWCNT _IOCNT
; 615  :  #endif /* _IORCNT */
; 616  : 
; 617  :   #pragma warning(push)
; 618  :   #pragma warning(disable: 6240)	/* prefast noise VSW 489858 */
; 619  : 		if (_File != 0 && sizeof (_Elem) == 1)

  0005e	48 85 ff	 test	 rdi, rdi
  00061	74 4e		 je	 SHORT $LN9@setbuf

; 620  :   #pragma warning(pop)
; 621  : 
; 622  : 			{	// point inside C stream with [first, first + count) buffer
; 623  : 			_Elem **_Pb = 0;
; 624  : 			_Elem **_Pn = 0;
; 625  : 			int *_Nr = 0;
; 626  : 
; 627  : 			::_get_stream_buffer_pointers(

  00063	4c 8d 4c 24 20	 lea	 r9, QWORD PTR _Nr$1[rsp]
  00068	48 89 74 24 40	 mov	 QWORD PTR _Pb$2[rsp], rsi
  0006d	4c 8d 44 24 58	 lea	 r8, QWORD PTR _Pn$3[rsp]
  00072	48 89 74 24 58	 mov	 QWORD PTR _Pn$3[rsp], rsi
  00077	48 8d 54 24 40	 lea	 rdx, QWORD PTR _Pb$2[rsp]
  0007c	48 89 74 24 20	 mov	 QWORD PTR _Nr$1[rsp], rsi
  00081	48 8b cf	 mov	 rcx, rdi
  00084	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__get_stream_buffer_pointers
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 332  : 		_IGfirst = _Gf;

  0008a	48 8b 44 24 40	 mov	 rax, QWORD PTR _Pb$2[rsp]
  0008f	48 89 43 18	 mov	 QWORD PTR [rbx+24], rax

; 333  : 		_IPfirst = _Pf;

  00093	48 89 43 20	 mov	 QWORD PTR [rbx+32], rax

; 334  : 		_IGnext = _Gn;

  00097	48 8b 44 24 58	 mov	 rax, QWORD PTR _Pn$3[rsp]
  0009c	48 89 43 38	 mov	 QWORD PTR [rbx+56], rax

; 335  : 		_IPnext = _Pn;

  000a0	48 89 43 40	 mov	 QWORD PTR [rbx+64], rax

; 336  : 		_IGcount = _Gc;

  000a4	48 8b 44 24 20	 mov	 rax, QWORD PTR _Nr$1[rsp]
  000a9	48 89 43 50	 mov	 QWORD PTR [rbx+80], rax

; 337  : 		_IPcount = _Pc;

  000ad	48 89 43 58	 mov	 QWORD PTR [rbx+88], rax
$LN9@setbuf:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream

; 637  : 		_Myfile = _File;

  000b1	48 89 bb 80 00
	00 00		 mov	 QWORD PTR [rbx+128], rdi

; 638  : 		_State = _Stinit;

  000b8	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit
  000bf	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  000c4	48 89 43 74	 mov	 QWORD PTR [rbx+116], rax

; 587  : 			return (this);

  000c8	48 8b c3	 mov	 rax, rbx

; 639  : 		_Pcvt = 0;	// pointer to codecvt facet

  000cb	48 89 73 68	 mov	 QWORD PTR [rbx+104], rsi

; 588  : 			}
; 589  : 		}

  000cf	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  000d4	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000d8	5e		 pop	 rsi
  000d9	c3		 ret	 0
$LN4@setbuf:

; 581  : 			_Buffer == 0 && _Count == 0 ? _IONBF : _IOFBF,
; 582  : 			(size_t)_Count * sizeof (_Elem)) != 0)
; 583  : 			return (0);	// failed

  000da	33 c0		 xor	 eax, eax

; 588  : 			}
; 589  : 		}

  000dc	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  000e1	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000e5	5e		 pop	 rsi
  000e6	c3		 ret	 0
?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::setbuf
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
;	COMDAT ?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
_TEXT	SEGMENT
_Fileposition$ = 48
this$ = 48
__$ReturnUdt$ = 56
_Pos$ = 64
__formal$ = 72
?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::seekpos, COMDAT

; 561  : 		{	// change position to _Pos

$LN18:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  0000f	41 56		 push	 r14
  00011	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 562  : 		fpos_t _Fileposition = _POS_TYPE_TO_FPOS_T(_Pos);
; 563  : 		off_type _Off = (off_type)_Pos - (off_type)_FPOSOFF(_Fileposition);
; 564  : 
; 565  : 		if (_Myfile == 0 || !_Endwrite()
; 566  : 			|| fsetpos(_Myfile, &_Fileposition) != 0
; 567  : 			|| (_Off != 0 && _FSEEK_OFF(_Myfile, _Off, SEEK_CUR) != 0)
; 568  : 			|| fgetpos(_Myfile, &_Fileposition) != 0)

  00015	48 83 b9 80 00
	00 00 00	 cmp	 QWORD PTR [rcx+128], 0
  0001d	4d 8b f0	 mov	 r14, r8
  00020	49 8b 40 08	 mov	 rax, QWORD PTR [r8+8]
  00024	48 8b da	 mov	 rbx, rdx
  00027	49 8b 30	 mov	 rsi, QWORD PTR [r8]
  0002a	48 8b f9	 mov	 rdi, rcx
  0002d	48 89 44 24 30	 mov	 QWORD PTR _Fileposition$[rsp], rax
  00032	74 78		 je	 SHORT $LN3@seekpos
  00034	e8 00 00 00 00	 call	 ?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite
  00039	84 c0		 test	 al, al
  0003b	74 6f		 je	 SHORT $LN3@seekpos
  0003d	48 8b 8f 80 00
	00 00		 mov	 rcx, QWORD PTR [rdi+128]
  00044	48 8d 54 24 30	 lea	 rdx, QWORD PTR _Fileposition$[rsp]
  00049	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fsetpos
  0004f	85 c0		 test	 eax, eax
  00051	75 59		 jne	 SHORT $LN3@seekpos
  00053	48 85 f6	 test	 rsi, rsi
  00056	74 18		 je	 SHORT $LN4@seekpos
  00058	48 8b 8f 80 00
	00 00		 mov	 rcx, QWORD PTR [rdi+128]
  0005f	44 8d 40 01	 lea	 r8d, QWORD PTR [rax+1]
  00063	48 8b d6	 mov	 rdx, rsi
  00066	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__fseeki64
  0006c	85 c0		 test	 eax, eax
  0006e	75 3c		 jne	 SHORT $LN3@seekpos
$LN4@seekpos:
  00070	48 8b 8f 80 00
	00 00		 mov	 rcx, QWORD PTR [rdi+128]
  00077	48 8d 54 24 30	 lea	 rdx, QWORD PTR _Fileposition$[rsp]
  0007c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fgetpos
  00082	85 c0		 test	 eax, eax
  00084	75 26		 jne	 SHORT $LN3@seekpos

; 570  : 
; 571  : 		_State = _POS_TYPE_TO_STATE(_Pos);

  00086	49 8b 46 10	 mov	 rax, QWORD PTR [r14+16]

; 572  : 
; 573  : 		_Reset_back();	// revert from _Mychar buffer, discarding any putback

  0008a	48 8b cf	 mov	 rcx, rdi
  0008d	48 89 47 74	 mov	 QWORD PTR [rdi+116], rax
  00091	e8 00 00 00 00	 call	 ?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Reset_back

; 574  : 		return (_POS_TYPE_FROM_STATE(pos_type, _State,

  00096	48 8b 47 74	 mov	 rax, QWORD PTR [rdi+116]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 47   : 		: _Myoff(0), _Fpos(_Fileposition), _Mystate(_State)

  0009a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _Fileposition$[rsp]
  0009f	48 89 4b 08	 mov	 QWORD PTR [rbx+8], rcx
  000a3	48 c7 03 00 00
	00 00		 mov	 QWORD PTR [rbx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream

; 574  : 		return (_POS_TYPE_FROM_STATE(pos_type, _State,

  000aa	eb 17		 jmp	 SHORT $LN16@seekpos
$LN3@seekpos:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 42   : 		: _Myoff(_Off), _Fpos(_Fpz), _Mystate()

  000ac	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_?_BADOFF@std@@3_JB
  000b3	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000b6	33 c0		 xor	 eax, eax
  000b8	48 89 0b	 mov	 QWORD PTR [rbx], rcx
  000bb	48 c7 43 08 00
	00 00 00	 mov	 QWORD PTR [rbx+8], 0
$LN16@seekpos:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream

; 576  : 		}

  000c3	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000c8	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 42   : 		: _Myoff(_Off), _Fpos(_Fpz), _Mystate()

  000cd	48 89 43 10	 mov	 QWORD PTR [rbx+16], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream

; 569  : 			return (pos_type(_BADOFF));	// report failure

  000d1	48 8b c3	 mov	 rax, rbx

; 576  : 		}

  000d4	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  000d9	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000dd	41 5e		 pop	 r14
  000df	c3		 ret	 0
?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::seekpos
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
;	COMDAT ?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
_TEXT	SEGMENT
_Fileposition$ = 48
this$ = 48
__$ReturnUdt$ = 56
_Off$ = 64
_Way$ = 72
__formal$ = 80
?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::seekoff, COMDAT

; 539  : 		{	// change position by _Off

$LN16:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 227  : 		return (*_IGnext);

  00014	4c 8b 51 38	 mov	 r10, QWORD PTR [rcx+56]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream

; 544  : 			&& _Pcvt == 0)	// not converting

  00018	48 8d 41 70	 lea	 rax, QWORD PTR [rcx+112]
  0001c	41 8b e9	 mov	 ebp, r9d
  0001f	49 8b f0	 mov	 rsi, r8
  00022	48 8b fa	 mov	 rdi, rdx
  00025	48 8b d9	 mov	 rbx, rcx
  00028	49 39 02	 cmp	 QWORD PTR [r10], rax
  0002b	75 10		 jne	 SHORT $LN2@seekoff
  0002d	41 83 f9 01	 cmp	 r9d, 1
  00031	75 0a		 jne	 SHORT $LN2@seekoff
  00033	48 83 79 68 00	 cmp	 QWORD PTR [rcx+104], 0
  00038	75 03		 jne	 SHORT $LN2@seekoff

; 545  : 			_Off -= (off_type)sizeof (_Elem);	// back up over _Elem bytes

  0003a	48 ff ce	 dec	 rsi
$LN2@seekoff:

; 546  : 
; 547  : 		if (_Myfile == 0 || !_Endwrite()
; 548  : 			|| ((_Off != 0 || _Way != ios_base::cur)
; 549  : 				&& _FSEEK_OFF(_Myfile, _Off, _Way) != 0)
; 550  : 			|| fgetpos(_Myfile, &_Fileposition) != 0)

  0003d	48 83 b9 80 00
	00 00 00	 cmp	 QWORD PTR [rcx+128], 0
  00045	74 5e		 je	 SHORT $LN4@seekoff
  00047	e8 00 00 00 00	 call	 ?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite
  0004c	84 c0		 test	 al, al
  0004e	74 55		 je	 SHORT $LN4@seekoff
  00050	48 85 f6	 test	 rsi, rsi
  00053	75 05		 jne	 SHORT $LN6@seekoff
  00055	83 fd 01	 cmp	 ebp, 1
  00058	74 17		 je	 SHORT $LN5@seekoff
$LN6@seekoff:
  0005a	48 8b 8b 80 00
	00 00		 mov	 rcx, QWORD PTR [rbx+128]
  00061	44 8b c5	 mov	 r8d, ebp
  00064	48 8b d6	 mov	 rdx, rsi
  00067	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__fseeki64
  0006d	85 c0		 test	 eax, eax
  0006f	75 34		 jne	 SHORT $LN4@seekoff
$LN5@seekoff:
  00071	48 8b 8b 80 00
	00 00		 mov	 rcx, QWORD PTR [rbx+128]
  00078	48 8d 54 24 30	 lea	 rdx, QWORD PTR _Fileposition$[rsp]
  0007d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fgetpos
  00083	85 c0		 test	 eax, eax
  00085	75 1e		 jne	 SHORT $LN4@seekoff

; 552  : 
; 553  : 		_Reset_back();	// revert from _Mychar buffer, discarding any putback

  00087	48 8b cb	 mov	 rcx, rbx
  0008a	e8 00 00 00 00	 call	 ?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Reset_back

; 554  : 		return (_POS_TYPE_FROM_STATE(pos_type, _State,

  0008f	48 8b 43 74	 mov	 rax, QWORD PTR [rbx+116]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 47   : 		: _Myoff(0), _Fpos(_Fileposition), _Mystate(_State)

  00093	48 8b 4c 24 30	 mov	 rcx, QWORD PTR _Fileposition$[rsp]
  00098	48 89 4f 08	 mov	 QWORD PTR [rdi+8], rcx
  0009c	48 c7 07 00 00
	00 00		 mov	 QWORD PTR [rdi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream

; 554  : 		return (_POS_TYPE_FROM_STATE(pos_type, _State,

  000a3	eb 17		 jmp	 SHORT $LN14@seekoff
$LN4@seekoff:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 42   : 		: _Myoff(_Off), _Fpos(_Fpz), _Mystate()

  000a5	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_?_BADOFF@std@@3_JB
  000ac	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000af	33 c0		 xor	 eax, eax
  000b1	48 89 0f	 mov	 QWORD PTR [rdi], rcx
  000b4	48 c7 47 08 00
	00 00 00	 mov	 QWORD PTR [rdi+8], 0
$LN14@seekoff:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream

; 556  : 		}

  000bc	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  000c1	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  000c6	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 42   : 		: _Myoff(_Off), _Fpos(_Fpz), _Mystate()

  000cb	48 89 47 10	 mov	 QWORD PTR [rdi+16], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream

; 551  : 			return (pos_type(_BADOFF));	// report failure

  000cf	48 8b c7	 mov	 rax, rdi

; 556  : 		}

  000d2	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000d6	5f		 pop	 rdi
  000d7	c3		 ret	 0
?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::seekoff
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_memcpy_s.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
;	COMDAT ?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
_TEXT	SEGMENT
_Ch$1 = 64
_Str$2 = 72
$T3 = 112
$T4 = 112
$T5 = 112
_Dest$6 = 136
$T7 = 144
$T8 = 168
$T9 = 192
_Lock$10 = 272
_Lock$11 = 272
_Lock$12 = 272
_Lock$13 = 272
this$ = 272
_Lock$14 = 280
_Lock$15 = 288
_Src$16 = 296
?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::uflow, COMDAT

; 472  : 		{	// get an element from stream, point past it

$LN995:
  00000	40 55		 push	 rbp
  00002	53		 push	 rbx
  00003	56		 push	 rsi
  00004	57		 push	 rdi
  00005	41 54		 push	 r12
  00007	41 56		 push	 r14
  00009	41 57		 push	 r15
  0000b	48 8d 6c 24 d9	 lea	 rbp, QWORD PTR [rsp-39]
  00010	48 81 ec d0 00
	00 00		 sub	 rsp, 208		; 000000d0H
  00017	48 c7 45 17 fe
	ff ff ff	 mov	 QWORD PTR $T9[rbp-169], -2
  0001f	4c 8b f1	 mov	 r14, rcx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 227  : 		return (*_IGnext);

  00022	48 8b 41 38	 mov	 rax, QWORD PTR [rcx+56]
  00026	48 8b 08	 mov	 rcx, QWORD PTR [rax]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream

; 474  : 			&& _Mysb::gptr() < _Mysb::egptr())

  00029	48 85 c9	 test	 rcx, rcx
  0002c	74 2c		 je	 SHORT $LN10@uflow
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 242  : 		return (*_IGnext + *_IGcount);

  0002e	49 8b 56 50	 mov	 rdx, QWORD PTR [r14+80]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream

; 474  : 			&& _Mysb::gptr() < _Mysb::egptr())

  00032	4c 63 02	 movsxd	 r8, DWORD PTR [rdx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 242  : 		return (*_IGnext + *_IGcount);

  00035	4a 8d 04 01	 lea	 rax, QWORD PTR [rcx+r8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream

; 474  : 			&& _Mysb::gptr() < _Mysb::egptr())

  00039	48 3b c8	 cmp	 rcx, rax
  0003c	73 1c		 jae	 SHORT $LN10@uflow
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 271  : 		--*_IGcount;

  0003e	41 8d 40 ff	 lea	 eax, DWORD PTR [r8-1]
  00042	89 02		 mov	 DWORD PTR [rdx], eax

; 272  : 		return ((*_IGnext)++);

  00044	49 8b 4e 38	 mov	 rcx, QWORD PTR [r14+56]
  00048	48 8b 11	 mov	 rdx, QWORD PTR [rcx]
  0004b	48 8d 42 01	 lea	 rax, QWORD PTR [rdx+1]
  0004f	48 89 01	 mov	 QWORD PTR [rcx], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 589  : 		return ((unsigned char)_Ch);

  00052	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream

; 475  : 			return (_Traits::to_int_type(

  00055	e9 b6 05 00 00	 jmp	 $LN14@uflow
$LN10@uflow:

; 476  : 				*_Mysb::_Gninc()));	// return buffered
; 477  : 		else if (_Myfile == 0)

  0005a	49 83 be 80 00
	00 00 00	 cmp	 QWORD PTR [r14+128], 0
  00062	75 09		 jne	 SHORT $LN12@uflow

; 478  : 			return (_Traits::eof());	// no open C stream, fail

  00064	48 83 c8 ff	 or	 rax, -1
  00068	e9 a3 05 00 00	 jmp	 $LN14@uflow
$LN12@uflow:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 222  : 		return (*_IGfirst);

  0006d	4d 8b 46 18	 mov	 r8, QWORD PTR [r14+24]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream

; 704  : 		if (_Mysb::eback() == &_Mychar)

  00071	49 8d 46 70	 lea	 rax, QWORD PTR [r14+112]
  00075	49 39 00	 cmp	 QWORD PTR [r8], rax
  00078	75 20		 jne	 SHORT $LN49@uflow

; 705  : 			_Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

  0007a	49 8b 96 90 00
	00 00		 mov	 rdx, QWORD PTR [r14+144]
  00081	49 8b 8e 88 00
	00 00		 mov	 rcx, QWORD PTR [r14+136]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 253  : 		*_IGfirst = _First;

  00088	49 89 08	 mov	 QWORD PTR [r8], rcx

; 254  : 		*_IGnext = _Next;

  0008b	49 8b 46 38	 mov	 rax, QWORD PTR [r14+56]
  0008f	48 89 08	 mov	 QWORD PTR [rax], rcx

; 255  : 		*_IGcount = (int)(_Last - _Next);

  00092	2b d1		 sub	 edx, ecx
  00094	49 8b 46 50	 mov	 rax, QWORD PTR [r14+80]
  00098	89 10		 mov	 DWORD PTR [rax], edx
$LN49@uflow:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream

; 480  : 		if (_Pcvt == 0)

  0009a	49 83 7e 68 00	 cmp	 QWORD PTR [r14+104], 0
  0009f	75 24		 jne	 SHORT $LN13@uflow

; 39   : 	if ((_Meta = fgetc(_File)) == EOF)

  000a1	49 8b 8e 80 00
	00 00		 mov	 rcx, QWORD PTR [r14+128]
  000a8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fgetc
  000ae	83 f8 ff	 cmp	 eax, -1
  000b1	74 09		 je	 SHORT $LN23@uflow
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 589  : 		return ((unsigned char)_Ch);

  000b3	44 0f b6 f8	 movzx	 r15d, al

; 590  : 		}

  000b7	e9 51 05 00 00	 jmp	 $LN63@uflow
$LN23@uflow:

; 606  : 		return (EOF);

  000bc	49 83 cf ff	 or	 r15, -1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream

; 483  : 			return (_Fgetc(_Ch, _Myfile) ? _Traits::to_int_type(_Ch)

  000c0	e9 48 05 00 00	 jmp	 $LN63@uflow
$LN13@uflow:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 79   : 		: _Myproxy(0)

  000c5	45 33 e4	 xor	 r12d, r12d
  000c8	4c 89 65 9f	 mov	 QWORD PTR _Str$2[rbp-169], r12
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 488  : 		_Mysize = 0;

  000cc	4c 89 65 b7	 mov	 QWORD PTR _Str$2[rbp-145], r12

; 489  : 		_Myres = 0;

  000d0	4c 89 65 bf	 mov	 QWORD PTR _Str$2[rbp-137], r12
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 625  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

  000d4	41 b0 01	 mov	 r8b, 1
  000d7	41 8d 54 24 10	 lea	 edx, QWORD PTR [r12+16]
  000dc	8d 4a f1	 lea	 ecx, QWORD PTR [rdx-15]
  000df	e8 00 00 00 00	 call	 ?_Allocate@std@@YAPEAX_K0_N@Z ; std::_Allocate
  000e4	48 89 45 9f	 mov	 QWORD PTR _Str$2[rbp-169], rax

; 637  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  000e8	48 85 c0	 test	 rax, rax
  000eb	74 0a		 je	 SHORT $LN121@uflow
  000ed	0f 57 c0	 xorps	 xmm0, xmm0
  000f0	0f 11 00	 movups	 XMMWORD PTR [rax], xmm0
  000f3	48 8b 45 9f	 mov	 rax, QWORD PTR _Str$2[rbp-169]
$LN121@uflow:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 645  : 		_Myproxy()->_Mycont = &_Get_data();

  000f7	48 8d 4d 9f	 lea	 rcx, QWORD PTR _Str$2[rbp-169]
  000fb	48 89 08	 mov	 QWORD PTR [rax], rcx

; 2255 : 		this->_Myres() = this->_BUF_SIZE - 1;

  000fe	48 c7 45 bf 0f
	00 00 00	 mov	 QWORD PTR _Str$2[rbp-137], 15

; 2214 : 		_Traits::assign(this->_Myptr()[this->_Mysize() = _Newsize], _Elem());

  00106	4c 89 65 b7	 mov	 QWORD PTR _Str$2[rbp-145], r12
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  0010a	44 88 65 a7	 mov	 BYTE PTR _Str$2[rbp-161], r12b
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream

; 495  : 				int _Meta = fgetc(_Myfile);

  0010e	49 8b 8e 80 00
	00 00		 mov	 rcx, QWORD PTR [r14+128]
  00115	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fgetc

; 496  : 
; 497  : 				if (_Meta == EOF)

  0011b	49 83 cf ff	 or	 r15, -1
$LN994@uflow:
  0011f	83 f8 ff	 cmp	 eax, -1

; 495  : 				int _Meta = fgetc(_Myfile);

  00122	8b f8		 mov	 edi, eax

; 496  : 
; 497  : 				if (_Meta == EOF)

  00124	0f 84 49 04 00
	00		 je	 $LN743@uflow
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1107 : 		if (npos - this->_Mysize() <= _Count)

  0012a	49 8b cf	 mov	 rcx, r15
  0012d	48 8b 55 b7	 mov	 rdx, QWORD PTR _Str$2[rbp-145]
  00131	48 2b ca	 sub	 rcx, rdx
  00134	48 83 f9 01	 cmp	 rcx, 1
  00138	0f 86 22 04 00
	00		 jbe	 $LN952@uflow

; 1108 : 			_Xlen();	// result too long
; 1109 : 
; 1110 : 		const size_type _Num = this->_Mysize() + _Count;

  0013e	48 8d 5a 01	 lea	 rbx, QWORD PTR [rdx+1]

; 2220 : 		if (max_size() < _Newsize)

  00142	48 83 fb fe	 cmp	 rbx, -2
  00146	0f 87 06 04 00
	00		 ja	 $LN953@uflow

; 2221 : 			_Xlen();	// result too long
; 2222 : 		if (this->_Myres() < _Newsize)

  0014c	48 8b 4d bf	 mov	 rcx, QWORD PTR _Str$2[rbp-137]
  00150	48 3b cb	 cmp	 rcx, rbx
  00153	73 11		 jae	 SHORT $LN291@uflow

; 2223 : 			_Copy(_Newsize, this->_Mysize());	// reallocate to grow

  00155	4c 8b c2	 mov	 r8, rdx
  00158	48 8b d3	 mov	 rdx, rbx
  0015b	48 8d 4d 9f	 lea	 rcx, QWORD PTR _Str$2[rbp-169]
  0015f	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  00164	eb 18		 jmp	 SHORT $LN990@uflow
$LN291@uflow:

; 2224 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2225 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2226 : 				_Newsize < this->_Mysize() ? _Newsize : this->_Mysize());
; 2227 : 		else if (_Newsize == 0)

  00166	48 85 db	 test	 rbx, rbx
  00169	75 20		 jne	 SHORT $LN992@uflow

; 2214 : 		_Traits::assign(this->_Myptr()[this->_Mysize() = _Newsize], _Elem());

  0016b	4c 89 65 b7	 mov	 QWORD PTR _Str$2[rbp-145], r12

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  0016f	48 8d 45 a7	 lea	 rax, QWORD PTR _Str$2[rbp-161]
  00173	48 83 f9 10	 cmp	 rcx, 16
  00177	48 0f 43 45 a7	 cmovae	 rax, QWORD PTR _Str$2[rbp-161]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  0017c	88 18		 mov	 BYTE PTR [rax], bl
$LN990@uflow:
  0017e	48 8b 55 b7	 mov	 rdx, QWORD PTR _Str$2[rbp-145]
  00182	48 8b 4d bf	 mov	 rcx, QWORD PTR _Str$2[rbp-137]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2229 : 		return (0 < _Newsize);	// return true only if more work to do

  00186	48 85 db	 test	 rbx, rbx

; 1111 : 		if (0 < _Count && _Grow(_Num))

  00189	74 27		 je	 SHORT $LN592@uflow
$LN992@uflow:

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  0018b	48 8d 45 a7	 lea	 rax, QWORD PTR _Str$2[rbp-161]
  0018f	48 83 f9 10	 cmp	 rcx, 16
  00193	48 0f 43 45 a7	 cmovae	 rax, QWORD PTR _Str$2[rbp-161]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  00198	40 88 3c 02	 mov	 BYTE PTR [rdx+rax], dil
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2214 : 		_Traits::assign(this->_Myptr()[this->_Mysize() = _Newsize], _Elem());

  0019c	48 89 5d b7	 mov	 QWORD PTR _Str$2[rbp-145], rbx

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  001a0	48 8d 45 a7	 lea	 rax, QWORD PTR _Str$2[rbp-161]
  001a4	48 83 7d bf 10	 cmp	 QWORD PTR _Str$2[rbp-137], 16
  001a9	48 0f 43 45 a7	 cmovae	 rax, QWORD PTR _Str$2[rbp-161]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  001ae	c6 04 03 00	 mov	 BYTE PTR [rbx+rax], 0
$LN592@uflow:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream

; 501  : 				switch (_Pcvt->in(_State,

  001b2	48 8d 55 ff	 lea	 rdx, QWORD PTR $T8[rbp-169]
  001b6	48 8d 4d 9f	 lea	 rcx, QWORD PTR _Str$2[rbp-169]
  001ba	e8 00 00 00 00	 call	 ?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
  001bf	48 8b d8	 mov	 rbx, rax
  001c2	48 8d 55 e7	 lea	 rdx, QWORD PTR $T7[rbp-169]
  001c6	48 8d 4d 9f	 lea	 rcx, QWORD PTR _Str$2[rbp-169]
  001ca	e8 00 00 00 00	 call	 ?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
  001cf	48 8b f0	 mov	 rsi, rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 332  : 		return ((reference)**(_Mybase *)this);

  001d2	48 8b cb	 mov	 rcx, rbx
  001d5	e8 00 00 00 00	 call	 ??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAAEBDXZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator*
  001da	48 8b f8	 mov	 rdi, rax

; 1742 : 		return (this->_Mysize());

  001dd	48 8b 5d b7	 mov	 rbx, QWORD PTR _Str$2[rbp-145]

; 332  : 		return ((reference)**(_Mybase *)this);

  001e1	48 8b ce	 mov	 rcx, rsi
  001e4	e8 00 00 00 00	 call	 ??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAAEBDXZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator*
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream

; 501  : 				switch (_Pcvt->in(_State,

  001e9	4c 8d 0c 3b	 lea	 r9, QWORD PTR [rbx+rdi]
  001ed	49 8d 56 74	 lea	 rdx, QWORD PTR [r14+116]
  001f1	48 8d 4d df	 lea	 rcx, QWORD PTR _Dest$6[rbp-169]
  001f5	48 89 4c 24 38	 mov	 QWORD PTR [rsp+56], rcx
  001fa	48 8d 4d 98	 lea	 rcx, QWORD PTR _Ch$1[rbp-168]
  001fe	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00203	48 8d 4d 97	 lea	 rcx, QWORD PTR _Ch$1[rbp-169]
  00207	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  0020c	48 8d 4d 7f	 lea	 rcx, QWORD PTR _Src$16[rbp-169]
  00210	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00215	4c 8b c0	 mov	 r8, rax
  00218	49 8b 4e 68	 mov	 rcx, QWORD PTR [r14+104]
  0021c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?in@?$codecvt@DDU_Mbstatet@@@std@@QEBAHAEAU_Mbstatet@@PEBD1AEAPEBDPEAD3AEAPEAD@Z
  00222	8b f8		 mov	 edi, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 142  : 		_Lockit _Lock(_LOCK_DEBUG);

  00224	ba 03 00 00 00	 mov	 edx, 3
  00229	48 8d 4d 67	 lea	 rcx, QWORD PTR _Lock$13[rbp-169]
  0022d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0_Lockit@std@@QEAA@H@Z

; 194  : 		if (_Myproxy != 0)

  00233	48 8b 5d e7	 mov	 rbx, QWORD PTR $T7[rbp-169]
  00237	48 85 db	 test	 rbx, rbx
  0023a	74 55		 je	 SHORT $LN626@uflow

; 195  : 			{	// adopted, remove self from list
; 196  : 			_Iterator_base12 **_Pnext = &_Myproxy->_Myfirstiter;

  0023c	48 83 c3 08	 add	 rbx, 8

; 197  : 			while (*_Pnext != 0 && *_Pnext != this)

  00240	48 83 3b 00	 cmp	 QWORD PTR [rbx], 0
  00244	74 26		 je	 SHORT $LN983@uflow
  00246	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL624@uflow:
  00250	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00253	48 8d 4d e7	 lea	 rcx, QWORD PTR $T7[rbp-169]
  00257	48 3b c1	 cmp	 rax, rcx
  0025a	74 0a		 je	 SHORT $LN625@uflow

; 198  : 				_Pnext = &(*_Pnext)->_Mynextiter;

  0025c	48 8d 58 08	 lea	 rbx, QWORD PTR [rax+8]

; 197  : 			while (*_Pnext != 0 && *_Pnext != this)

  00260	48 83 3b 00	 cmp	 QWORD PTR [rbx], 0
  00264	75 ea		 jne	 SHORT $LL624@uflow
$LN625@uflow:

; 199  : 
; 200  : 			if (*_Pnext == 0)

  00266	48 83 3b 00	 cmp	 QWORD PTR [rbx], 0
  0026a	75 1a		 jne	 SHORT $LN627@uflow
$LN983@uflow:

; 201  : 				_DEBUG_ERROR("ITERATOR LIST CORRUPTED!");

  0026c	41 b8 c9 00 00
	00		 mov	 r8d, 201		; 000000c9H
  00272	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1JA@IJKHNLMB@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  00279	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@
  00280	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Debug_message@std@@YAXPEB_W0I@Z
$LN627@uflow:

; 202  : 			*_Pnext = _Mynextiter;

  00286	48 8b 45 ef	 mov	 rax, QWORD PTR $T7[rbp-161]
  0028a	48 89 03	 mov	 QWORD PTR [rbx], rax

; 203  : 			_Myproxy = 0;

  0028d	4c 89 65 e7	 mov	 QWORD PTR $T7[rbp-169], r12
$LN626@uflow:

; 145  : 		}

  00291	48 8d 4d 67	 lea	 rcx, QWORD PTR _Lock$13[rbp-169]
  00295	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
  0029b	90		 npad	 1

; 142  : 		_Lockit _Lock(_LOCK_DEBUG);

  0029c	ba 03 00 00 00	 mov	 edx, 3
  002a1	48 8d 4d 6f	 lea	 rcx, QWORD PTR _Lock$14[rbp-169]
  002a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0_Lockit@std@@QEAA@H@Z

; 194  : 		if (_Myproxy != 0)

  002ab	48 8b 5d ff	 mov	 rbx, QWORD PTR $T8[rbp-169]
  002af	48 85 db	 test	 rbx, rbx
  002b2	74 4d		 je	 SHORT $LN644@uflow

; 195  : 			{	// adopted, remove self from list
; 196  : 			_Iterator_base12 **_Pnext = &_Myproxy->_Myfirstiter;

  002b4	48 83 c3 08	 add	 rbx, 8

; 197  : 			while (*_Pnext != 0 && *_Pnext != this)

  002b8	48 83 3b 00	 cmp	 QWORD PTR [rbx], 0
  002bc	74 1e		 je	 SHORT $LN984@uflow
  002be	66 90		 npad	 2
$LL642@uflow:
  002c0	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  002c3	48 8d 4d ff	 lea	 rcx, QWORD PTR $T8[rbp-169]
  002c7	48 3b c1	 cmp	 rax, rcx
  002ca	74 0a		 je	 SHORT $LN643@uflow

; 198  : 				_Pnext = &(*_Pnext)->_Mynextiter;

  002cc	48 8d 58 08	 lea	 rbx, QWORD PTR [rax+8]

; 197  : 			while (*_Pnext != 0 && *_Pnext != this)

  002d0	48 83 3b 00	 cmp	 QWORD PTR [rbx], 0
  002d4	75 ea		 jne	 SHORT $LL642@uflow
$LN643@uflow:

; 199  : 
; 200  : 			if (*_Pnext == 0)

  002d6	48 83 3b 00	 cmp	 QWORD PTR [rbx], 0
  002da	75 1a		 jne	 SHORT $LN645@uflow
$LN984@uflow:

; 201  : 				_DEBUG_ERROR("ITERATOR LIST CORRUPTED!");

  002dc	41 b8 c9 00 00
	00		 mov	 r8d, 201		; 000000c9H
  002e2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1JA@IJKHNLMB@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  002e9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@
  002f0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Debug_message@std@@YAXPEB_W0I@Z
$LN645@uflow:

; 202  : 			*_Pnext = _Mynextiter;

  002f6	48 8b 45 07	 mov	 rax, QWORD PTR $T8[rbp-161]
  002fa	48 89 03	 mov	 QWORD PTR [rbx], rax

; 203  : 			_Myproxy = 0;

  002fd	4c 89 65 ff	 mov	 QWORD PTR $T8[rbp-169], r12
$LN644@uflow:

; 145  : 		}

  00301	48 8d 4d 6f	 lea	 rcx, QWORD PTR _Lock$14[rbp-169]
  00305	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
  0030b	90		 npad	 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream

; 501  : 				switch (_Pcvt->in(_State,

  0030c	85 ff		 test	 edi, edi
  0030e	0f 88 5f 02 00
	00		 js	 $LN743@uflow
  00314	83 ff 01	 cmp	 edi, 1
  00317	7e 19		 jle	 SHORT $LN16@uflow
  00319	83 ff 03	 cmp	 edi, 3
  0031c	0f 85 51 02 00
	00		 jne	 $LN743@uflow

; 516  : 							(size_t)(_Src - &*_Str.begin()));
; 517  : 					break;
; 518  : 
; 519  : 				case codecvt_base::noconv:
; 520  : 					if (_Str.size() < sizeof (_Elem))

  00322	48 83 7d b7 01	 cmp	 QWORD PTR _Str$2[rbp-145], 1
  00327	0f 83 c1 00 00
	00		 jae	 $LN20@uflow

; 521  : 						break;	// no conversion, but need more chars

  0032d	e9 aa 00 00 00	 jmp	 $LN694@uflow
$LN16@uflow:

; 502  : 					&*_Str.begin(), &*_Str.begin() + _Str.size(), _Src,
; 503  : 					&_Ch, &_Ch + 1, _Dest))
; 504  : 					{	// test result of converting one element
; 505  : 				case codecvt_base::partial:
; 506  : 				case codecvt_base::ok:
; 507  : 					if (_Dest != &_Ch)

  00332	48 8d 45 97	 lea	 rax, QWORD PTR _Ch$1[rbp-169]

; 515  : 						_Str.erase((size_t)0,	// partial, discard used input

  00336	48 8d 55 c7	 lea	 rdx, QWORD PTR $T4[rbp-169]
  0033a	48 8d 4d 9f	 lea	 rcx, QWORD PTR _Str$2[rbp-169]

; 502  : 					&*_Str.begin(), &*_Str.begin() + _Str.size(), _Src,
; 503  : 					&_Ch, &_Ch + 1, _Dest))
; 504  : 					{	// test result of converting one element
; 505  : 				case codecvt_base::partial:
; 506  : 				case codecvt_base::ok:
; 507  : 					if (_Dest != &_Ch)

  0033e	48 39 45 df	 cmp	 QWORD PTR _Dest$6[rbp-169], rax
  00342	0f 85 59 01 00
	00		 jne	 $LN955@uflow

; 515  : 						_Str.erase((size_t)0,	// partial, discard used input

  00348	e8 00 00 00 00	 call	 ?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
  0034d	90		 npad	 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 332  : 		return ((reference)**(_Mybase *)this);

  0034e	48 8b c8	 mov	 rcx, rax
  00351	e8 00 00 00 00	 call	 ??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAAEBDXZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator*
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream

; 515  : 						_Str.erase((size_t)0,	// partial, discard used input

  00356	4c 8b 45 7f	 mov	 r8, QWORD PTR _Src$16[rbp-169]
  0035a	4c 2b c0	 sub	 r8, rax
  0035d	33 d2		 xor	 edx, edx
  0035f	48 8d 4d 9f	 lea	 rcx, QWORD PTR _Str$2[rbp-169]
  00363	e8 00 00 00 00	 call	 ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
  00368	90		 npad	 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 142  : 		_Lockit _Lock(_LOCK_DEBUG);

  00369	ba 03 00 00 00	 mov	 edx, 3
  0036e	48 8d 4d 77	 lea	 rcx, QWORD PTR _Lock$15[rbp-169]
  00372	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0_Lockit@std@@QEAA@H@Z

; 194  : 		if (_Myproxy != 0)

  00378	48 8b 5d c7	 mov	 rbx, QWORD PTR $T4[rbp-169]
  0037c	48 85 db	 test	 rbx, rbx
  0037f	74 50		 je	 SHORT $LN699@uflow

; 195  : 			{	// adopted, remove self from list
; 196  : 			_Iterator_base12 **_Pnext = &_Myproxy->_Myfirstiter;

  00381	48 83 c3 08	 add	 rbx, 8

; 197  : 			while (*_Pnext != 0 && *_Pnext != this)

  00385	48 83 3b 00	 cmp	 QWORD PTR [rbx], 0
  00389	74 21		 je	 SHORT $LN985@uflow
  0038b	0f 1f 44 00 00	 npad	 5
$LL697@uflow:
  00390	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00393	48 8d 4d c7	 lea	 rcx, QWORD PTR $T4[rbp-169]
  00397	48 3b c1	 cmp	 rax, rcx
  0039a	74 0a		 je	 SHORT $LN698@uflow

; 198  : 				_Pnext = &(*_Pnext)->_Mynextiter;

  0039c	48 8d 58 08	 lea	 rbx, QWORD PTR [rax+8]

; 197  : 			while (*_Pnext != 0 && *_Pnext != this)

  003a0	48 83 3b 00	 cmp	 QWORD PTR [rbx], 0
  003a4	75 ea		 jne	 SHORT $LL697@uflow
$LN698@uflow:

; 199  : 
; 200  : 			if (*_Pnext == 0)

  003a6	48 83 3b 00	 cmp	 QWORD PTR [rbx], 0
  003aa	75 1a		 jne	 SHORT $LN700@uflow
$LN985@uflow:

; 201  : 				_DEBUG_ERROR("ITERATOR LIST CORRUPTED!");

  003ac	41 b8 c9 00 00
	00		 mov	 r8d, 201		; 000000c9H
  003b2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1JA@IJKHNLMB@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  003b9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@
  003c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Debug_message@std@@YAXPEB_W0I@Z
$LN700@uflow:

; 202  : 			*_Pnext = _Mynextiter;

  003c6	48 8b 45 cf	 mov	 rax, QWORD PTR $T4[rbp-161]
  003ca	48 89 03	 mov	 QWORD PTR [rbx], rax

; 203  : 			_Myproxy = 0;

  003cd	4c 89 65 c7	 mov	 QWORD PTR $T4[rbp-169], r12
$LN699@uflow:

; 145  : 		}

  003d1	48 8d 4d 77	 lea	 rcx, QWORD PTR _Lock$15[rbp-169]
  003d5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
  003db	90		 npad	 1
$LN694@uflow:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream

; 495  : 				int _Meta = fgetc(_Myfile);

  003dc	49 8b 8e 80 00
	00 00		 mov	 rcx, QWORD PTR [r14+128]
  003e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fgetc

; 496  : 
; 497  : 				if (_Meta == EOF)

  003e9	e9 31 fd ff ff	 jmp	 $LN994@uflow
$LN20@uflow:

; 522  : 
; 523  : 					_CRT_SECURE_MEMCPY(&_Ch, sizeof (_Elem), &*_Str.begin(),

  003ee	48 8d 55 c7	 lea	 rdx, QWORD PTR $T3[rbp-169]
  003f2	48 8d 4d 9f	 lea	 rcx, QWORD PTR _Str$2[rbp-169]
  003f6	e8 00 00 00 00	 call	 ?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
  003fb	90		 npad	 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 332  : 		return ((reference)**(_Mybase *)this);

  003fc	48 8b c8	 mov	 rcx, rax
  003ff	e8 00 00 00 00	 call	 ??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAAEBDXZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator*
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_memcpy_s.h

; 48   :         if (_Source == NULL || _DestinationSize < _SourceSize)

  00404	48 85 c0	 test	 rax, rax
  00407	74 08		 je	 SHORT $LN720@uflow

; 53   :             _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_DestinationSize >= _SourceSize, ERANGE);
; 54   : 
; 55   :             // Unreachable, but required to suppress /analyze warnings:
; 56   :             return EINVAL;
; 57   :         }
; 58   : 
; 59   :         memcpy(_Destination, _Source, _SourceSize);

  00409	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0040c	88 45 97	 mov	 BYTE PTR _Ch$1[rbp-169], al
  0040f	eb 16		 jmp	 SHORT $LN722@uflow
$LN720@uflow:

; 49   :         {
; 50   :             memset(_Destination, 0, _DestinationSize);

  00411	88 45 97	 mov	 BYTE PTR _Ch$1[rbp-169], al

; 51   : 
; 52   :             _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Source != NULL,                 EINVAL);

  00414	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0041a	c7 00 16 00 00
	00		 mov	 DWORD PTR [rax], 22
  00420	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo
  00426	90		 npad	 1
$LN722@uflow:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 142  : 		_Lockit _Lock(_LOCK_DEBUG);

  00427	ba 03 00 00 00	 mov	 edx, 3
  0042c	48 8d 4d 67	 lea	 rcx, QWORD PTR _Lock$11[rbp-169]
  00430	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0_Lockit@std@@QEAA@H@Z

; 194  : 		if (_Myproxy != 0)

  00436	48 8b 5d c7	 mov	 rbx, QWORD PTR $T3[rbp-169]
  0043a	48 85 db	 test	 rbx, rbx
  0043d	74 52		 je	 SHORT $LN739@uflow

; 195  : 			{	// adopted, remove self from list
; 196  : 			_Iterator_base12 **_Pnext = &_Myproxy->_Myfirstiter;

  0043f	48 83 c3 08	 add	 rbx, 8

; 197  : 			while (*_Pnext != 0 && *_Pnext != this)

  00443	48 83 3b 00	 cmp	 QWORD PTR [rbx], 0
  00447	74 23		 je	 SHORT $LN986@uflow
  00449	0f 1f 80 00 00
	00 00		 npad	 7
$LL737@uflow:
  00450	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00453	48 8d 55 c7	 lea	 rdx, QWORD PTR $T3[rbp-169]
  00457	48 3b c2	 cmp	 rax, rdx
  0045a	74 0a		 je	 SHORT $LN738@uflow

; 198  : 				_Pnext = &(*_Pnext)->_Mynextiter;

  0045c	48 8d 58 08	 lea	 rbx, QWORD PTR [rax+8]

; 197  : 			while (*_Pnext != 0 && *_Pnext != this)

  00460	48 83 3b 00	 cmp	 QWORD PTR [rbx], 0
  00464	75 ea		 jne	 SHORT $LL737@uflow
$LN738@uflow:

; 199  : 
; 200  : 			if (*_Pnext == 0)

  00466	48 83 3b 00	 cmp	 QWORD PTR [rbx], 0
  0046a	75 1a		 jne	 SHORT $LN740@uflow
$LN986@uflow:

; 201  : 				_DEBUG_ERROR("ITERATOR LIST CORRUPTED!");

  0046c	41 b8 c9 00 00
	00		 mov	 r8d, 201		; 000000c9H
  00472	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1JA@IJKHNLMB@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  00479	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@
  00480	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Debug_message@std@@YAXPEB_W0I@Z
$LN740@uflow:

; 202  : 			*_Pnext = _Mynextiter;

  00486	48 8b 45 cf	 mov	 rax, QWORD PTR $T3[rbp-161]
  0048a	48 89 03	 mov	 QWORD PTR [rbx], rax

; 203  : 			_Myproxy = 0;

  0048d	4c 89 65 c7	 mov	 QWORD PTR $T3[rbp-169], r12
$LN739@uflow:

; 145  : 		}

  00491	48 8d 4d 67	 lea	 rcx, QWORD PTR _Lock$11[rbp-169]
  00495	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
  0049b	90		 npad	 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 589  : 		return ((unsigned char)_Ch);

  0049c	e9 cd 00 00 00	 jmp	 $LN8@uflow
$LN955@uflow:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream

; 509  : 						_Nleft = (int)(&*_Str.begin() + _Str.size() - _Src);

  004a1	e8 00 00 00 00	 call	 ?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
  004a6	90		 npad	 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 332  : 		return ((reference)**(_Mybase *)this);

  004a7	48 8b c8	 mov	 rcx, rax
  004aa	e8 00 00 00 00	 call	 ??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAAEBDXZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator*
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream

; 509  : 						_Nleft = (int)(&*_Str.begin() + _Str.size() - _Src);

  004af	8b 7d b7	 mov	 edi, DWORD PTR _Str$2[rbp-145]
  004b2	2b 7d 7f	 sub	 edi, DWORD PTR _Src$16[rbp-169]
  004b5	03 f8		 add	 edi, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 142  : 		_Lockit _Lock(_LOCK_DEBUG);

  004b7	ba 03 00 00 00	 mov	 edx, 3
  004bc	48 8d 4d 67	 lea	 rcx, QWORD PTR _Lock$12[rbp-169]
  004c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0_Lockit@std@@QEAA@H@Z

; 194  : 		if (_Myproxy != 0)

  004c6	48 8b 5d c7	 mov	 rbx, QWORD PTR $T5[rbp-169]
  004ca	48 85 db	 test	 rbx, rbx
  004cd	74 52		 je	 SHORT $LN676@uflow

; 195  : 			{	// adopted, remove self from list
; 196  : 			_Iterator_base12 **_Pnext = &_Myproxy->_Myfirstiter;

  004cf	48 83 c3 08	 add	 rbx, 8

; 197  : 			while (*_Pnext != 0 && *_Pnext != this)

  004d3	48 83 3b 00	 cmp	 QWORD PTR [rbx], 0
  004d7	74 23		 je	 SHORT $LN987@uflow
  004d9	0f 1f 80 00 00
	00 00		 npad	 7
$LL674@uflow:
  004e0	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  004e3	48 8d 4d c7	 lea	 rcx, QWORD PTR $T5[rbp-169]
  004e7	48 3b c1	 cmp	 rax, rcx
  004ea	74 0a		 je	 SHORT $LN675@uflow

; 198  : 				_Pnext = &(*_Pnext)->_Mynextiter;

  004ec	48 8d 58 08	 lea	 rbx, QWORD PTR [rax+8]

; 197  : 			while (*_Pnext != 0 && *_Pnext != this)

  004f0	48 83 3b 00	 cmp	 QWORD PTR [rbx], 0
  004f4	75 ea		 jne	 SHORT $LL674@uflow
$LN675@uflow:

; 199  : 
; 200  : 			if (*_Pnext == 0)

  004f6	48 83 3b 00	 cmp	 QWORD PTR [rbx], 0
  004fa	75 1a		 jne	 SHORT $LN677@uflow
$LN987@uflow:

; 201  : 				_DEBUG_ERROR("ITERATOR LIST CORRUPTED!");

  004fc	41 b8 c9 00 00
	00		 mov	 r8d, 201		; 000000c9H
  00502	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1JA@IJKHNLMB@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  00509	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@
  00510	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Debug_message@std@@YAXPEB_W0I@Z
$LN677@uflow:

; 202  : 			*_Pnext = _Mynextiter;

  00516	48 8b 45 cf	 mov	 rax, QWORD PTR $T5[rbp-161]
  0051a	48 89 03	 mov	 QWORD PTR [rbx], rax

; 203  : 			_Myproxy = 0;

  0051d	4c 89 65 c7	 mov	 QWORD PTR $T5[rbp-169], r12
$LN676@uflow:

; 145  : 		}

  00521	48 8d 4d 67	 lea	 rcx, QWORD PTR _Lock$12[rbp-169]
  00525	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
  0052b	90		 npad	 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream

; 509  : 						_Nleft = (int)(&*_Str.begin() + _Str.size() - _Src);

  0052c	48 63 df	 movsxd	 rbx, edi

; 510  : 						for (; 0 < _Nleft; )

  0052f	85 ff		 test	 edi, edi
  00531	7e 3b		 jle	 SHORT $LN8@uflow
$LL7@uflow:

; 511  : 							ungetc(_Src[--_Nleft], _Myfile);

  00533	48 ff cb	 dec	 rbx
  00536	48 8b 45 7f	 mov	 rax, QWORD PTR _Src$16[rbp-169]
  0053a	0f be 0c 03	 movsx	 ecx, BYTE PTR [rbx+rax]
  0053e	49 8b 96 80 00
	00 00		 mov	 rdx, QWORD PTR [r14+128]
  00545	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ungetc

; 510  : 						for (; 0 < _Nleft; )

  0054b	48 85 db	 test	 rbx, rbx
  0054e	7f e3		 jg	 SHORT $LL7@uflow
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 589  : 		return ((unsigned char)_Ch);

  00550	eb 1c		 jmp	 SHORT $LN8@uflow
$LN953@uflow:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2261 : 		_Xlength_error("string too long");

  00552	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00559	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
  0055f	cc		 int	 3
$LN952@uflow:
  00560	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00567	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
  0056d	cc		 int	 3
$LN8@uflow:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 589  : 		return ((unsigned char)_Ch);

  0056e	44 0f b6 7d 97	 movzx	 r15d, BYTE PTR _Ch$1[rbp-169]
$LN743@uflow:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2246 : 		else if (this->_BUF_SIZE <= this->_Myres())

  00573	48 8b 55 bf	 mov	 rdx, QWORD PTR _Str$2[rbp-137]
  00577	48 83 fa 10	 cmp	 rdx, 16
  0057b	72 12		 jb	 SHORT $LN754@uflow

; 2247 : 			{	// copy any leftovers to small buffer and deallocate
; 2248 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2249 : 			this->_Getal().destroy(&this->_Bx()._Ptr);
; 2250 : 			if (0 < _Newsize)
; 2251 : 				_Traits::copy(this->_Bx()._Buf,
; 2252 : 					_STD addressof(*_Ptr), _Newsize);
; 2253 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

  0057d	48 ff c2	 inc	 rdx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 620  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00580	41 b8 01 00 00
	00		 mov	 r8d, 1
  00586	48 8b 4d a7	 mov	 rcx, QWORD PTR _Str$2[rbp-161]
  0058a	e8 00 00 00 00	 call	 ?_Deallocate@std@@YAXPEAX_K1@Z ; std::_Deallocate
$LN754@uflow:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2255 : 		this->_Myres() = this->_BUF_SIZE - 1;

  0058f	48 c7 45 bf 0f
	00 00 00	 mov	 QWORD PTR _Str$2[rbp-137], 15

; 2214 : 		_Traits::assign(this->_Myptr()[this->_Mysize() = _Newsize], _Elem());

  00597	4c 89 65 b7	 mov	 QWORD PTR _Str$2[rbp-145], r12
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  0059b	c6 45 a7 00	 mov	 BYTE PTR _Str$2[rbp-161], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 216  : 	if (_Myproxy != 0)

  0059f	48 8b 4d 9f	 mov	 rcx, QWORD PTR _Str$2[rbp-169]
  005a3	48 85 c9	 test	 rcx, rcx
  005a6	74 56		 je	 SHORT $LN892@uflow

; 217  : 		{	// proxy allocated, drain it
; 218  : 		_Lockit _Lock(_LOCK_DEBUG);

  005a8	ba 03 00 00 00	 mov	 edx, 3
  005ad	48 8d 4d 67	 lea	 rcx, QWORD PTR _Lock$10[rbp-169]
  005b1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0_Lockit@std@@QEAA@H@Z

; 219  : 
; 220  : 		for (_Iterator_base12 **_Pnext = &_Myproxy->_Myfirstiter;

  005b7	4c 8b 4d 9f	 mov	 r9, QWORD PTR _Str$2[rbp-169]

; 221  : 			*_Pnext != 0; *_Pnext = (*_Pnext)->_Mynextiter)

  005bb	49 83 79 08 00	 cmp	 QWORD PTR [r9+8], 0
  005c0	74 2a		 je	 SHORT $LN890@uflow
  005c2	0f 1f 40 00 66
	66 0f 1f 84 00
	00 00 00 00	 npad	 14
$LL891@uflow:

; 222  : 			(*_Pnext)->_Myproxy = 0;

  005d0	49 8b 41 08	 mov	 rax, QWORD PTR [r9+8]
  005d4	4c 89 20	 mov	 QWORD PTR [rax], r12

; 221  : 			*_Pnext != 0; *_Pnext = (*_Pnext)->_Mynextiter)

  005d7	49 8b 41 08	 mov	 rax, QWORD PTR [r9+8]
  005db	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  005df	49 89 49 08	 mov	 QWORD PTR [r9+8], rcx
  005e3	48 85 c9	 test	 rcx, rcx
  005e6	75 e8		 jne	 SHORT $LL891@uflow
  005e8	4c 8b 4d 9f	 mov	 r9, QWORD PTR _Str$2[rbp-169]
$LN890@uflow:

; 223  : 		_Myproxy->_Myfirstiter = 0;

  005ec	4d 89 61 08	 mov	 QWORD PTR [r9+8], r12

; 224  : 		}

  005f0	48 8d 4d 67	 lea	 rcx, QWORD PTR _Lock$10[rbp-169]
  005f4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
  005fa	48 8b 4d 9f	 mov	 rcx, QWORD PTR _Str$2[rbp-169]
$LN892@uflow:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 620  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  005fe	ba 01 00 00 00	 mov	 edx, 1
  00603	44 8d 42 0f	 lea	 r8d, QWORD PTR [rdx+15]
  00607	e8 00 00 00 00	 call	 ?_Deallocate@std@@YAXPEAX_K1@Z ; std::_Deallocate
  0060c	90		 npad	 1
$LN63@uflow:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream

; 529  : 					return (_Traits::eof());	// conversion failed

  0060d	41 8b c7	 mov	 eax, r15d
$LN14@uflow:

; 530  : 					}
; 531  : 				}
; 532  : 			}
; 533  : 		}

  00610	48 81 c4 d0 00
	00 00		 add	 rsp, 208		; 000000d0H
  00617	41 5f		 pop	 r15
  00619	41 5e		 pop	 r14
  0061b	41 5c		 pop	 r12
  0061d	5f		 pop	 rdi
  0061e	5e		 pop	 rsi
  0061f	5b		 pop	 rbx
  00620	5d		 pop	 rbp
  00621	c3		 ret	 0
$LN989@uflow:
?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::uflow
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
_Ch$1 = 64
_Str$2 = 72
$T3 = 112
$T4 = 112
$T5 = 112
_Dest$6 = 136
$T7 = 144
$T8 = 168
$T9 = 192
_Lock$10 = 272
_Lock$11 = 272
_Lock$12 = 272
_Lock$13 = 272
this$ = 272
_Lock$14 = 280
_Lock$15 = 288
_Src$16 = 296
?dtor$10@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::uflow'::`1'::dtor$10
  00000	e9 00 00 00 00	 jmp	 __std_terminate
?dtor$10@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::uflow'::`1'::dtor$10
_Ch$1 = 64
_Str$2 = 72
$T3 = 112
$T4 = 112
$T5 = 112
_Dest$6 = 136
$T7 = 144
$T8 = 168
$T9 = 192
_Lock$10 = 272
_Lock$11 = 272
_Lock$12 = 272
_Lock$13 = 272
this$ = 272
_Lock$14 = 280
_Lock$15 = 288
_Src$16 = 296
?dtor$0@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::uflow'::`1'::dtor$0
  00005	48 8d 8a 48 00
	00 00		 lea	 rcx, QWORD PTR _Str$2[rdx]
  0000c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::uflow'::`1'::dtor$0
_Ch$1 = 64
_Str$2 = 72
$T3 = 112
$T4 = 112
$T5 = 112
_Dest$6 = 136
$T7 = 144
$T8 = 168
$T9 = 192
_Lock$10 = 272
_Lock$11 = 272
_Lock$12 = 272
_Lock$13 = 272
this$ = 272
_Lock$14 = 280
_Lock$15 = 288
_Src$16 = 296
?dtor$1@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::uflow'::`1'::dtor$1
  00011	48 8d 8a a8 00
	00 00		 lea	 rcx, QWORD PTR $T8[rdx]
  00018	e9 00 00 00 00	 jmp	 ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@XZ
?dtor$1@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::uflow'::`1'::dtor$1
_Ch$1 = 64
_Str$2 = 72
$T3 = 112
$T4 = 112
$T5 = 112
_Dest$6 = 136
$T7 = 144
$T8 = 168
$T9 = 192
_Lock$10 = 272
_Lock$11 = 272
_Lock$12 = 272
_Lock$13 = 272
this$ = 272
_Lock$14 = 280
_Lock$15 = 288
_Src$16 = 296
?dtor$2@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::uflow'::`1'::dtor$2
  0001d	48 8d 8a 90 00
	00 00		 lea	 rcx, QWORD PTR $T7[rdx]
  00024	e9 00 00 00 00	 jmp	 ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@XZ
?dtor$2@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::uflow'::`1'::dtor$2
_Ch$1 = 64
_Str$2 = 72
$T3 = 112
$T4 = 112
$T5 = 112
_Dest$6 = 136
$T7 = 144
$T8 = 168
$T9 = 192
_Lock$10 = 272
_Lock$11 = 272
_Lock$12 = 272
_Lock$13 = 272
this$ = 272
_Lock$14 = 280
_Lock$15 = 288
_Src$16 = 296
?dtor$152@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::uflow'::`1'::dtor$152
  00029	e9 00 00 00 00	 jmp	 __std_terminate
?dtor$152@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::uflow'::`1'::dtor$152
_Ch$1 = 64
_Str$2 = 72
$T3 = 112
$T4 = 112
$T5 = 112
_Dest$6 = 136
$T7 = 144
$T8 = 168
$T9 = 192
_Lock$10 = 272
_Lock$11 = 272
_Lock$12 = 272
_Lock$13 = 272
this$ = 272
_Lock$14 = 280
_Lock$15 = 288
_Src$16 = 296
?dtor$156@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::uflow'::`1'::dtor$156
  0002e	e9 00 00 00 00	 jmp	 __std_terminate
?dtor$156@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::uflow'::`1'::dtor$156
_Ch$1 = 64
_Str$2 = 72
$T3 = 112
$T4 = 112
$T5 = 112
_Dest$6 = 136
$T7 = 144
$T8 = 168
$T9 = 192
_Lock$10 = 272
_Lock$11 = 272
_Lock$12 = 272
_Lock$13 = 272
this$ = 272
_Lock$14 = 280
_Lock$15 = 288
_Src$16 = 296
?dtor$3@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::uflow'::`1'::dtor$3
  00033	48 8d 8a 70 00
	00 00		 lea	 rcx, QWORD PTR $T5[rdx]
  0003a	e9 00 00 00 00	 jmp	 ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@XZ
?dtor$3@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::uflow'::`1'::dtor$3
_Ch$1 = 64
_Str$2 = 72
$T3 = 112
$T4 = 112
$T5 = 112
_Dest$6 = 136
$T7 = 144
$T8 = 168
$T9 = 192
_Lock$10 = 272
_Lock$11 = 272
_Lock$12 = 272
_Lock$13 = 272
this$ = 272
_Lock$14 = 280
_Lock$15 = 288
_Src$16 = 296
?dtor$164@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::uflow'::`1'::dtor$164
  0003f	e9 00 00 00 00	 jmp	 __std_terminate
?dtor$164@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::uflow'::`1'::dtor$164
_Ch$1 = 64
_Str$2 = 72
$T3 = 112
$T4 = 112
$T5 = 112
_Dest$6 = 136
$T7 = 144
$T8 = 168
$T9 = 192
_Lock$10 = 272
_Lock$11 = 272
_Lock$12 = 272
_Lock$13 = 272
this$ = 272
_Lock$14 = 280
_Lock$15 = 288
_Src$16 = 296
?dtor$4@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::uflow'::`1'::dtor$4
  00044	48 8d 8a 70 00
	00 00		 lea	 rcx, QWORD PTR $T4[rdx]
  0004b	e9 00 00 00 00	 jmp	 ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@XZ
?dtor$4@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::uflow'::`1'::dtor$4
_Ch$1 = 64
_Str$2 = 72
$T3 = 112
$T4 = 112
$T5 = 112
_Dest$6 = 136
$T7 = 144
$T8 = 168
$T9 = 192
_Lock$10 = 272
_Lock$11 = 272
_Lock$12 = 272
_Lock$13 = 272
this$ = 272
_Lock$14 = 280
_Lock$15 = 288
_Src$16 = 296
?dtor$169@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::uflow'::`1'::dtor$169
  00050	e9 00 00 00 00	 jmp	 __std_terminate
?dtor$169@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::uflow'::`1'::dtor$169
_Ch$1 = 64
_Str$2 = 72
$T3 = 112
$T4 = 112
$T5 = 112
_Dest$6 = 136
$T7 = 144
$T8 = 168
$T9 = 192
_Lock$10 = 272
_Lock$11 = 272
_Lock$12 = 272
_Lock$13 = 272
this$ = 272
_Lock$14 = 280
_Lock$15 = 288
_Src$16 = 296
?dtor$5@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::uflow'::`1'::dtor$5
  00055	48 8d 8a 70 00
	00 00		 lea	 rcx, QWORD PTR $T3[rdx]
  0005c	e9 00 00 00 00	 jmp	 ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@XZ
?dtor$5@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::uflow'::`1'::dtor$5
_Ch$1 = 64
_Str$2 = 72
$T3 = 112
$T4 = 112
$T5 = 112
_Dest$6 = 136
$T7 = 144
$T8 = 168
$T9 = 192
_Lock$10 = 272
_Lock$11 = 272
_Lock$12 = 272
_Lock$13 = 272
this$ = 272
_Lock$14 = 280
_Lock$15 = 288
_Src$16 = 296
?dtor$177@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::uflow'::`1'::dtor$177
  00061	e9 00 00 00 00	 jmp	 __std_terminate
?dtor$177@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::uflow'::`1'::dtor$177
_Ch$1 = 64
_Str$2 = 72
$T3 = 112
$T4 = 112
$T5 = 112
_Dest$6 = 136
$T7 = 144
$T8 = 168
$T9 = 192
_Lock$10 = 272
_Lock$11 = 272
_Lock$12 = 272
_Lock$13 = 272
this$ = 272
_Lock$14 = 280
_Lock$15 = 288
_Src$16 = 296
?dtor$213@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::uflow'::`1'::dtor$213
  00066	e9 00 00 00 00	 jmp	 __std_terminate
?dtor$213@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::uflow'::`1'::dtor$213
_Ch$1 = 64
_Str$2 = 72
$T3 = 112
$T4 = 112
$T5 = 112
_Dest$6 = 136
$T7 = 144
$T8 = 168
$T9 = 192
_Lock$10 = 272
_Lock$11 = 272
_Lock$12 = 272
_Lock$13 = 272
this$ = 272
_Lock$14 = 280
_Lock$15 = 288
_Src$16 = 296
?dtor$230@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::uflow'::`1'::dtor$230
  0006b	e9 00 00 00 00	 jmp	 __std_terminate
?dtor$230@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::uflow'::`1'::dtor$230
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Ch$1 = 64
_Str$2 = 72
$T3 = 112
$T4 = 112
$T5 = 112
_Dest$6 = 136
$T7 = 144
$T8 = 168
$T9 = 192
_Lock$10 = 272
_Lock$11 = 272
_Lock$12 = 272
_Lock$13 = 272
this$ = 272
_Lock$14 = 280
_Lock$15 = 288
_Src$16 = 296
?dtor$10@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::uflow'::`1'::dtor$10
  00000	e9 00 00 00 00	 jmp	 __std_terminate
?dtor$10@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::uflow'::`1'::dtor$10
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Ch$1 = 64
_Str$2 = 72
$T3 = 112
$T4 = 112
$T5 = 112
_Dest$6 = 136
$T7 = 144
$T8 = 168
$T9 = 192
_Lock$10 = 272
_Lock$11 = 272
_Lock$12 = 272
_Lock$13 = 272
this$ = 272
_Lock$14 = 280
_Lock$15 = 288
_Src$16 = 296
?dtor$0@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::uflow'::`1'::dtor$0
  00005	48 8d 8a 48 00
	00 00		 lea	 rcx, QWORD PTR _Str$2[rdx]
  0000c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::uflow'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Ch$1 = 64
_Str$2 = 72
$T3 = 112
$T4 = 112
$T5 = 112
_Dest$6 = 136
$T7 = 144
$T8 = 168
$T9 = 192
_Lock$10 = 272
_Lock$11 = 272
_Lock$12 = 272
_Lock$13 = 272
this$ = 272
_Lock$14 = 280
_Lock$15 = 288
_Src$16 = 296
?dtor$1@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::uflow'::`1'::dtor$1
  00011	48 8d 8a a8 00
	00 00		 lea	 rcx, QWORD PTR $T8[rdx]
  00018	e9 00 00 00 00	 jmp	 ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@XZ
?dtor$1@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::uflow'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Ch$1 = 64
_Str$2 = 72
$T3 = 112
$T4 = 112
$T5 = 112
_Dest$6 = 136
$T7 = 144
$T8 = 168
$T9 = 192
_Lock$10 = 272
_Lock$11 = 272
_Lock$12 = 272
_Lock$13 = 272
this$ = 272
_Lock$14 = 280
_Lock$15 = 288
_Src$16 = 296
?dtor$2@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::uflow'::`1'::dtor$2
  0001d	48 8d 8a 90 00
	00 00		 lea	 rcx, QWORD PTR $T7[rdx]
  00024	e9 00 00 00 00	 jmp	 ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@XZ
?dtor$2@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::uflow'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Ch$1 = 64
_Str$2 = 72
$T3 = 112
$T4 = 112
$T5 = 112
_Dest$6 = 136
$T7 = 144
$T8 = 168
$T9 = 192
_Lock$10 = 272
_Lock$11 = 272
_Lock$12 = 272
_Lock$13 = 272
this$ = 272
_Lock$14 = 280
_Lock$15 = 288
_Src$16 = 296
?dtor$152@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::uflow'::`1'::dtor$152
  00029	e9 00 00 00 00	 jmp	 __std_terminate
?dtor$152@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::uflow'::`1'::dtor$152
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Ch$1 = 64
_Str$2 = 72
$T3 = 112
$T4 = 112
$T5 = 112
_Dest$6 = 136
$T7 = 144
$T8 = 168
$T9 = 192
_Lock$10 = 272
_Lock$11 = 272
_Lock$12 = 272
_Lock$13 = 272
this$ = 272
_Lock$14 = 280
_Lock$15 = 288
_Src$16 = 296
?dtor$156@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::uflow'::`1'::dtor$156
  0002e	e9 00 00 00 00	 jmp	 __std_terminate
?dtor$156@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::uflow'::`1'::dtor$156
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Ch$1 = 64
_Str$2 = 72
$T3 = 112
$T4 = 112
$T5 = 112
_Dest$6 = 136
$T7 = 144
$T8 = 168
$T9 = 192
_Lock$10 = 272
_Lock$11 = 272
_Lock$12 = 272
_Lock$13 = 272
this$ = 272
_Lock$14 = 280
_Lock$15 = 288
_Src$16 = 296
?dtor$3@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::uflow'::`1'::dtor$3
  00033	48 8d 8a 70 00
	00 00		 lea	 rcx, QWORD PTR $T5[rdx]
  0003a	e9 00 00 00 00	 jmp	 ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@XZ
?dtor$3@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::uflow'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Ch$1 = 64
_Str$2 = 72
$T3 = 112
$T4 = 112
$T5 = 112
_Dest$6 = 136
$T7 = 144
$T8 = 168
$T9 = 192
_Lock$10 = 272
_Lock$11 = 272
_Lock$12 = 272
_Lock$13 = 272
this$ = 272
_Lock$14 = 280
_Lock$15 = 288
_Src$16 = 296
?dtor$164@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::uflow'::`1'::dtor$164
  0003f	e9 00 00 00 00	 jmp	 __std_terminate
?dtor$164@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::uflow'::`1'::dtor$164
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Ch$1 = 64
_Str$2 = 72
$T3 = 112
$T4 = 112
$T5 = 112
_Dest$6 = 136
$T7 = 144
$T8 = 168
$T9 = 192
_Lock$10 = 272
_Lock$11 = 272
_Lock$12 = 272
_Lock$13 = 272
this$ = 272
_Lock$14 = 280
_Lock$15 = 288
_Src$16 = 296
?dtor$4@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::uflow'::`1'::dtor$4
  00044	48 8d 8a 70 00
	00 00		 lea	 rcx, QWORD PTR $T4[rdx]
  0004b	e9 00 00 00 00	 jmp	 ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@XZ
?dtor$4@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::uflow'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Ch$1 = 64
_Str$2 = 72
$T3 = 112
$T4 = 112
$T5 = 112
_Dest$6 = 136
$T7 = 144
$T8 = 168
$T9 = 192
_Lock$10 = 272
_Lock$11 = 272
_Lock$12 = 272
_Lock$13 = 272
this$ = 272
_Lock$14 = 280
_Lock$15 = 288
_Src$16 = 296
?dtor$169@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::uflow'::`1'::dtor$169
  00050	e9 00 00 00 00	 jmp	 __std_terminate
?dtor$169@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::uflow'::`1'::dtor$169
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Ch$1 = 64
_Str$2 = 72
$T3 = 112
$T4 = 112
$T5 = 112
_Dest$6 = 136
$T7 = 144
$T8 = 168
$T9 = 192
_Lock$10 = 272
_Lock$11 = 272
_Lock$12 = 272
_Lock$13 = 272
this$ = 272
_Lock$14 = 280
_Lock$15 = 288
_Src$16 = 296
?dtor$5@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::uflow'::`1'::dtor$5
  00055	48 8d 8a 70 00
	00 00		 lea	 rcx, QWORD PTR $T3[rdx]
  0005c	e9 00 00 00 00	 jmp	 ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@XZ
?dtor$5@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::uflow'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Ch$1 = 64
_Str$2 = 72
$T3 = 112
$T4 = 112
$T5 = 112
_Dest$6 = 136
$T7 = 144
$T8 = 168
$T9 = 192
_Lock$10 = 272
_Lock$11 = 272
_Lock$12 = 272
_Lock$13 = 272
this$ = 272
_Lock$14 = 280
_Lock$15 = 288
_Src$16 = 296
?dtor$177@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::uflow'::`1'::dtor$177
  00061	e9 00 00 00 00	 jmp	 __std_terminate
?dtor$177@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::uflow'::`1'::dtor$177
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Ch$1 = 64
_Str$2 = 72
$T3 = 112
$T4 = 112
$T5 = 112
_Dest$6 = 136
$T7 = 144
$T8 = 168
$T9 = 192
_Lock$10 = 272
_Lock$11 = 272
_Lock$12 = 272
_Lock$13 = 272
this$ = 272
_Lock$14 = 280
_Lock$15 = 288
_Src$16 = 296
?dtor$213@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::uflow'::`1'::dtor$213
  00066	e9 00 00 00 00	 jmp	 __std_terminate
?dtor$213@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::uflow'::`1'::dtor$213
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Ch$1 = 64
_Str$2 = 72
$T3 = 112
$T4 = 112
$T5 = 112
_Dest$6 = 136
$T7 = 144
$T8 = 168
$T9 = 192
_Lock$10 = 272
_Lock$11 = 272
_Lock$12 = 272
_Lock$13 = 272
this$ = 272
_Lock$14 = 280
_Lock$15 = 288
_Src$16 = 296
?dtor$230@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::uflow'::`1'::dtor$230
  0006b	e9 00 00 00 00	 jmp	 __std_terminate
?dtor$230@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::uflow'::`1'::dtor$230
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
;	COMDAT ?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
_TEXT	SEGMENT
this$ = 48
?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::underflow, COMDAT

; 457  : 		{	// get an element from stream, but don't point past it

$LN26:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 227  : 		return (*_IGnext);

  00006	48 8b 41 38	 mov	 rax, QWORD PTR [rcx+56]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream

; 457  : 		{	// get an element from stream, but don't point past it

  0000a	48 8b d9	 mov	 rbx, rcx

; 460  : 			&& _Mysb::gptr() < _Mysb::egptr())

  0000d	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00010	48 85 c9	 test	 rcx, rcx
  00013	74 18		 je	 SHORT $LN2@underflow
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 242  : 		return (*_IGnext + *_IGcount);

  00015	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream

; 460  : 			&& _Mysb::gptr() < _Mysb::egptr())

  00019	48 63 10	 movsxd	 rdx, DWORD PTR [rax]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 242  : 		return (*_IGnext + *_IGcount);

  0001c	48 03 d1	 add	 rdx, rcx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream

; 460  : 			&& _Mysb::gptr() < _Mysb::egptr())

  0001f	48 3b ca	 cmp	 rcx, rdx
  00022	73 09		 jae	 SHORT $LN2@underflow
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 589  : 		return ((unsigned char)_Ch);

  00024	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream

; 469  : 		}

  00027	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002b	5b		 pop	 rbx
  0002c	c3		 ret	 0
$LN2@underflow:

; 462  : 		else if (_Traits::eq_int_type(_Traits::eof(), _Meta = uflow()))

  0002d	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00030	48 8b cb	 mov	 rcx, rbx
  00033	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  00038	ff 50 38	 call	 QWORD PTR [rax+56]
  0003b	8b f8		 mov	 edi, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 595  : 		return (_Left == _Right);

  0003d	83 f8 ff	 cmp	 eax, -1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream

; 462  : 		else if (_Traits::eq_int_type(_Traits::eof(), _Meta = uflow()))

  00040	75 0d		 jne	 SHORT $LN4@underflow

; 463  : 			return (_Meta);	// uflow failed, return EOF

  00042	0b c0		 or	 eax, eax
  00044	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 469  : 		}

  00049	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004d	5b		 pop	 rbx
  0004e	c3		 ret	 0
$LN4@underflow:

; 464  : 		else
; 465  : 			{	// get a char, don't point past it
; 466  : 			pbackfail(_Meta);

  0004f	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00052	8b d7		 mov	 edx, edi
  00054	48 8b cb	 mov	 rcx, rbx
  00057	ff 50 20	 call	 QWORD PTR [rax+32]

; 467  : 			return (_Meta);

  0005a	8b c7		 mov	 eax, edi
  0005c	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 469  : 		}

  00061	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00065	5b		 pop	 rbx
  00066	c3		 ret	 0
?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::underflow
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
;	COMDAT ?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z
_TEXT	SEGMENT
this$ = 48
_Meta$ = 56
?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::pbackfail, COMDAT

; 432  : 		{	// put an element back to stream

$LN70:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 227  : 		return (*_IGnext);

  0000a	48 8b 41 38	 mov	 rax, QWORD PTR [rcx+56]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream

; 432  : 		{	// put an element back to stream

  0000e	48 8b f9	 mov	 rdi, rcx
  00011	8b da		 mov	 ebx, edx

; 435  : 			&& (_Traits::eq_int_type(_Traits::eof(), _Meta)

  00013	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00016	48 85 c9	 test	 rcx, rcx
  00019	74 36		 je	 SHORT $LN2@pbackfail
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 222  : 		return (*_IGfirst);

  0001b	48 8b 47 18	 mov	 rax, QWORD PTR [rdi+24]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream

; 435  : 			&& (_Traits::eq_int_type(_Traits::eof(), _Meta)

  0001f	48 39 08	 cmp	 QWORD PTR [rax], rcx
  00022	73 2d		 jae	 SHORT $LN2@pbackfail
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 595  : 		return (_Left == _Right);

  00024	83 fa ff	 cmp	 edx, -1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream

; 435  : 			&& (_Traits::eq_int_type(_Traits::eof(), _Meta)

  00027	74 08		 je	 SHORT $LN4@pbackfail
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 589  : 		return ((unsigned char)_Ch);

  00029	0f b6 41 ff	 movzx	 eax, BYTE PTR [rcx-1]

; 595  : 		return (_Left == _Right);

  0002d	3b c2		 cmp	 eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream

; 435  : 			&& (_Traits::eq_int_type(_Traits::eof(), _Meta)

  0002f	75 20		 jne	 SHORT $LN2@pbackfail
$LN4@pbackfail:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 265  : 		++*_IGcount;

  00031	48 8b 47 50	 mov	 rax, QWORD PTR [rdi+80]
  00035	ff 00		 inc	 DWORD PTR [rax]

; 266  : 		return (--*_IGnext);

  00037	48 8b 47 38	 mov	 rax, QWORD PTR [rdi+56]
  0003b	48 ff 08	 dec	 QWORD PTR [rax]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 601  : 		return (_Meta != eof() ? _Meta : !eof());

  0003e	33 c0		 xor	 eax, eax
  00040	83 fa ff	 cmp	 edx, -1
  00043	0f 45 c2	 cmovne	 eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream

; 454  : 	}

  00046	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0004b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004f	5f		 pop	 rdi
  00050	c3		 ret	 0
$LN2@pbackfail:

; 442  : 		else if (_Myfile == 0 || _Traits::eq_int_type(_Traits::eof(), _Meta))

  00051	48 8b 97 80 00
	00 00		 mov	 rdx, QWORD PTR [rdi+128]
  00058	48 85 d2	 test	 rdx, rdx
  0005b	74 3e		 je	 SHORT $LN7@pbackfail
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 595  : 		return (_Left == _Right);

  0005d	83 fb ff	 cmp	 ebx, -1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream

; 442  : 		else if (_Myfile == 0 || _Traits::eq_int_type(_Traits::eof(), _Meta))

  00060	74 39		 je	 SHORT $LN7@pbackfail

; 444  : 		else if (_Pcvt == 0 && _Ungetc(_Traits::to_char_type(_Meta), _Myfile))

  00062	48 83 7f 68 00	 cmp	 QWORD PTR [rdi+104], 0
  00067	75 0e		 jne	 SHORT $LN8@pbackfail

; 107  : 	return (ungetc((unsigned char)_Byte, _File) != EOF);

  00069	0f b6 cb	 movzx	 ecx, bl
  0006c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ungetc
  00072	83 f8 ff	 cmp	 eax, -1

; 444  : 		else if (_Pcvt == 0 && _Ungetc(_Traits::to_char_type(_Meta), _Myfile))

  00075	75 17		 jne	 SHORT $LN68@pbackfail
$LN8@pbackfail:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 227  : 		return (*_IGnext);

  00077	48 8b 47 38	 mov	 rax, QWORD PTR [rdi+56]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream

; 446  : 		else if (_Mysb::gptr() != &_Mychar)

  0007b	48 8d 4f 70	 lea	 rcx, QWORD PTR [rdi+112]
  0007f	48 39 08	 cmp	 QWORD PTR [rax], rcx
  00082	74 17		 je	 SHORT $LN7@pbackfail

; 447  : 			{	// putback to _Mychar
; 448  : 			_Mychar = _Traits::to_char_type(_Meta);

  00084	88 19		 mov	 BYTE PTR [rcx], bl

; 449  : 			_Set_back();	// switch to _Mychar buffer

  00086	48 8b cf	 mov	 rcx, rdi
  00089	e8 00 00 00 00	 call	 ?_Set_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Set_back
$LN68@pbackfail:

; 450  : 			return (_Meta);

  0008e	8b c3		 mov	 eax, ebx

; 454  : 	}

  00090	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00095	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00099	5f		 pop	 rdi
  0009a	c3		 ret	 0
$LN7@pbackfail:

; 443  : 			return (_Traits::eof());	// no open C stream or EOF, fail

  0009b	83 c8 ff	 or	 eax, -1

; 454  : 	}

  0009e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000a3	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a7	5f		 pop	 rdi
  000a8	c3		 ret	 0
?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::pbackfail
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
;	COMDAT ?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z
_TEXT	SEGMENT
_Ch$1 = 64
$T2 = 68
_Lock$3 = 72
_Str$4 = 80
$T5 = 120
$T6 = 120
_Dest$7 = 144
_Src$8 = 152
$T9 = 160
$T10 = 184
$T11 = 208
this$ = 288
_Lock$12 = 296
_Lock$13 = 296
_Meta$ = 296
_Lock$14 = 304
_Lock$15 = 312
?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::overflow, COMDAT

; 371  : 		{	// put an element to stream

$LN424:
  00000	40 55		 push	 rbp
  00002	56		 push	 rsi
  00003	57		 push	 rdi
  00004	41 54		 push	 r12
  00006	41 55		 push	 r13
  00008	41 56		 push	 r14
  0000a	41 57		 push	 r15
  0000c	48 8d 6c 24 d9	 lea	 rbp, QWORD PTR [rsp-39]
  00011	48 81 ec e0 00
	00 00		 sub	 rsp, 224		; 000000e0H
  00018	48 c7 45 17 fe
	ff ff ff	 mov	 QWORD PTR $T11[rbp-185], -2
  00020	48 89 9c 24 20
	01 00 00	 mov	 QWORD PTR [rsp+288], rbx
  00028	44 8b ea	 mov	 r13d, edx
  0002b	4c 8b f9	 mov	 r15, rcx
  0002e	45 33 f6	 xor	 r14d, r14d
  00031	45 8b e6	 mov	 r12d, r14d
  00034	44 89 75 8b	 mov	 DWORD PTR $T2[rbp-185], r14d
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 595  : 		return (_Left == _Right);

  00038	83 fa ff	 cmp	 edx, -1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream

; 372  : 		if (_Traits::eq_int_type(_Traits::eof(), _Meta))

  0003b	75 0c		 jne	 SHORT $LN7@overflow
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 601  : 		return (_Meta != eof() ? _Meta : !eof());

  0003d	44 0f 45 f2	 cmovne	 r14d, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream

; 373  : 			return (_Traits::not_eof(_Meta));	// EOF, return success code

  00041	41 8b c6	 mov	 eax, r14d
  00044	e9 63 04 00 00	 jmp	 $LN13@overflow
$LN7@overflow:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 237  : 		return (*_IPnext);

  00049	48 8b 41 40	 mov	 rax, QWORD PTR [rcx+64]
  0004d	48 8b 08	 mov	 rcx, QWORD PTR [rax]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream

; 375  : 			&& _Mysb::pptr() < _Mysb::epptr())

  00050	48 85 c9	 test	 rcx, rcx
  00053	74 2f		 je	 SHORT $LN9@overflow
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 260  : 		return (*_IPnext + *_IPcount);

  00055	49 8b 57 58	 mov	 rdx, QWORD PTR [r15+88]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream

; 375  : 			&& _Mysb::pptr() < _Mysb::epptr())

  00059	4c 63 02	 movsxd	 r8, DWORD PTR [rdx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 260  : 		return (*_IPnext + *_IPcount);

  0005c	4a 8d 04 01	 lea	 rax, QWORD PTR [rcx+r8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream

; 375  : 			&& _Mysb::pptr() < _Mysb::epptr())

  00060	48 3b c8	 cmp	 rcx, rax
  00063	73 1f		 jae	 SHORT $LN9@overflow
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 308  : 		--*_IPcount;

  00065	41 8d 40 ff	 lea	 eax, DWORD PTR [r8-1]
  00069	89 02		 mov	 DWORD PTR [rdx], eax

; 309  : 		return ((*_IPnext)++);

  0006b	49 8b 4f 40	 mov	 rcx, QWORD PTR [r15+64]
  0006f	48 8b 11	 mov	 rdx, QWORD PTR [rcx]
  00072	48 8d 42 01	 lea	 rax, QWORD PTR [rdx+1]
  00076	48 89 01	 mov	 QWORD PTR [rcx], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream

; 377  : 			*_Mysb::_Pninc() = _Traits::to_char_type(_Meta);

  00079	44 88 2a	 mov	 BYTE PTR [rdx], r13b

; 378  : 			return (_Meta);

  0007c	41 8b c5	 mov	 eax, r13d
  0007f	e9 28 04 00 00	 jmp	 $LN13@overflow
$LN9@overflow:

; 379  : 			}
; 380  : 		else if (_Myfile == 0)

  00084	4d 39 a7 80 00
	00 00		 cmp	 QWORD PTR [r15+128], r12
  0008b	75 08		 jne	 SHORT $LN11@overflow

; 381  : 			return (_Traits::eof());	// no open C stream, fail

  0008d	83 c8 ff	 or	 eax, -1
  00090	e9 17 04 00 00	 jmp	 $LN13@overflow
$LN11@overflow:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 222  : 		return (*_IGfirst);

  00095	4d 8b 47 18	 mov	 r8, QWORD PTR [r15+24]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream

; 704  : 		if (_Mysb::eback() == &_Mychar)

  00099	49 8d 47 70	 lea	 rax, QWORD PTR [r15+112]
  0009d	49 39 00	 cmp	 QWORD PTR [r8], rax
  000a0	75 20		 jne	 SHORT $LN73@overflow

; 705  : 			_Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

  000a2	49 8b 97 90 00
	00 00		 mov	 rdx, QWORD PTR [r15+144]
  000a9	49 8b 8f 88 00
	00 00		 mov	 rcx, QWORD PTR [r15+136]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 253  : 		*_IGfirst = _First;

  000b0	49 89 08	 mov	 QWORD PTR [r8], rcx

; 254  : 		*_IGnext = _Next;

  000b3	49 8b 47 38	 mov	 rax, QWORD PTR [r15+56]
  000b7	48 89 08	 mov	 QWORD PTR [rax], rcx

; 255  : 		*_IGcount = (int)(_Last - _Next);

  000ba	2b d1		 sub	 edx, ecx
  000bc	49 8b 47 50	 mov	 rax, QWORD PTR [r15+80]
  000c0	89 10		 mov	 DWORD PTR [rax], edx
$LN73@overflow:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream

; 383  : 		if (_Pcvt == 0)

  000c2	4d 39 67 68	 cmp	 QWORD PTR [r15+104], r12
  000c6	75 1f		 jne	 SHORT $LN12@overflow

; 83   : 	return (fputc(_Byte, _File) != EOF);

  000c8	41 0f be cd	 movsx	 ecx, r13b
  000cc	49 8b 97 80 00
	00 00		 mov	 rdx, QWORD PTR [r15+128]
  000d3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fputc

; 384  : 			return (_Fputc(_Traits::to_char_type(_Meta), _Myfile)

  000d9	83 cb ff	 or	 ebx, -1

; 83   : 	return (fputc(_Byte, _File) != EOF);

  000dc	3b c3		 cmp	 eax, ebx

; 384  : 			return (_Fputc(_Traits::to_char_type(_Meta), _Myfile)

  000de	41 0f 45 dd	 cmovne	 ebx, r13d
  000e2	e9 c3 03 00 00	 jmp	 $LN422@overflow
$LN12@overflow:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 583  : 		return ((_Elem)_Meta);

  000e7	44 88 6d 87	 mov	 BYTE PTR _Ch$1[rbp-185], r13b
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream

; 393  : 			string _Str(_STRING_INC, '\0');

  000eb	45 33 c0	 xor	 r8d, r8d
  000ee	41 8d 50 08	 lea	 edx, QWORD PTR [r8+8]
  000f2	48 8d 4d 97	 lea	 rcx, QWORD PTR _Str$4[rbp-185]
  000f6	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  000fb	90		 npad	 1
  000fc	0f 1f 40 00	 npad	 4
$LL2@overflow:

; 395  : 				switch (_Pcvt->out(_State,

  00100	48 8d 55 ff	 lea	 rdx, QWORD PTR $T10[rbp-185]
  00104	48 8d 4d 97	 lea	 rcx, QWORD PTR _Str$4[rbp-185]
  00108	e8 00 00 00 00	 call	 ?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
  0010d	48 8b d8	 mov	 rbx, rax
  00110	48 8d 55 e7	 lea	 rdx, QWORD PTR $T9[rbp-185]
  00114	48 8d 4d 97	 lea	 rcx, QWORD PTR _Str$4[rbp-185]
  00118	e8 00 00 00 00	 call	 ?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
  0011d	48 8b f0	 mov	 rsi, rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 332  : 		return ((reference)**(_Mybase *)this);

  00120	48 8b cb	 mov	 rcx, rbx
  00123	e8 00 00 00 00	 call	 ??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAAEBDXZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator*
  00128	48 8b f8	 mov	 rdi, rax

; 1742 : 		return (this->_Mysize());

  0012b	48 8b 5d af	 mov	 rbx, QWORD PTR _Str$4[rbp-161]

; 332  : 		return ((reference)**(_Mybase *)this);

  0012f	48 8b ce	 mov	 rcx, rsi
  00132	e8 00 00 00 00	 call	 ??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAAEBDXZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator*
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream

; 395  : 				switch (_Pcvt->out(_State,

  00137	48 8d 0c 3b	 lea	 rcx, QWORD PTR [rbx+rdi]
  0013b	48 8d 55 d7	 lea	 rdx, QWORD PTR _Dest$7[rbp-185]
  0013f	48 89 54 24 38	 mov	 QWORD PTR [rsp+56], rdx
  00144	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00149	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0014e	48 8d 45 df	 lea	 rax, QWORD PTR _Src$8[rbp-185]
  00152	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00157	4c 8d 4d 88	 lea	 r9, QWORD PTR _Ch$1[rbp-184]
  0015b	4c 8d 45 87	 lea	 r8, QWORD PTR _Ch$1[rbp-185]
  0015f	49 8d 57 74	 lea	 rdx, QWORD PTR [r15+116]
  00163	49 8b 4f 68	 mov	 rcx, QWORD PTR [r15+104]
  00167	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?out@?$codecvt@DDU_Mbstatet@@@std@@QEBAHAEAU_Mbstatet@@PEBD1AEAPEBDPEAD3AEAPEAD@Z
  0016d	8b f8		 mov	 edi, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 142  : 		_Lockit _Lock(_LOCK_DEBUG);

  0016f	ba 03 00 00 00	 mov	 edx, 3
  00174	48 8d 4d 6f	 lea	 rcx, QWORD PTR _Lock$13[rbp-185]
  00178	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0_Lockit@std@@QEAA@H@Z

; 194  : 		if (_Myproxy != 0)

  0017e	48 8b 5d e7	 mov	 rbx, QWORD PTR $T9[rbp-185]
  00182	48 85 db	 test	 rbx, rbx
  00185	74 4b		 je	 SHORT $LN121@overflow

; 195  : 			{	// adopted, remove self from list
; 196  : 			_Iterator_base12 **_Pnext = &_Myproxy->_Myfirstiter;

  00187	48 83 c3 08	 add	 rbx, 8

; 197  : 			while (*_Pnext != 0 && *_Pnext != this)

  0018b	48 83 3b 00	 cmp	 QWORD PTR [rbx], 0
  0018f	74 1c		 je	 SHORT $LN418@overflow
$LL119@overflow:
  00191	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00194	48 8d 4d e7	 lea	 rcx, QWORD PTR $T9[rbp-185]
  00198	48 3b c1	 cmp	 rax, rcx
  0019b	74 0a		 je	 SHORT $LN120@overflow

; 198  : 				_Pnext = &(*_Pnext)->_Mynextiter;

  0019d	48 8d 58 08	 lea	 rbx, QWORD PTR [rax+8]

; 197  : 			while (*_Pnext != 0 && *_Pnext != this)

  001a1	48 83 3b 00	 cmp	 QWORD PTR [rbx], 0
  001a5	75 ea		 jne	 SHORT $LL119@overflow
$LN120@overflow:

; 199  : 
; 200  : 			if (*_Pnext == 0)

  001a7	48 83 3b 00	 cmp	 QWORD PTR [rbx], 0
  001ab	75 1a		 jne	 SHORT $LN122@overflow
$LN418@overflow:

; 201  : 				_DEBUG_ERROR("ITERATOR LIST CORRUPTED!");

  001ad	41 b8 c9 00 00
	00		 mov	 r8d, 201		; 000000c9H
  001b3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1JA@IJKHNLMB@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  001ba	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@
  001c1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Debug_message@std@@YAXPEB_W0I@Z
$LN122@overflow:

; 202  : 			*_Pnext = _Mynextiter;

  001c7	48 8b 45 ef	 mov	 rax, QWORD PTR $T9[rbp-177]
  001cb	48 89 03	 mov	 QWORD PTR [rbx], rax

; 203  : 			_Myproxy = 0;

  001ce	4c 89 75 e7	 mov	 QWORD PTR $T9[rbp-185], r14
$LN121@overflow:

; 145  : 		}

  001d2	48 8d 4d 6f	 lea	 rcx, QWORD PTR _Lock$13[rbp-185]
  001d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
  001dc	90		 npad	 1

; 142  : 		_Lockit _Lock(_LOCK_DEBUG);

  001dd	ba 03 00 00 00	 mov	 edx, 3
  001e2	48 8d 4d 77	 lea	 rcx, QWORD PTR _Lock$14[rbp-185]
  001e6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0_Lockit@std@@QEAA@H@Z

; 194  : 		if (_Myproxy != 0)

  001ec	48 8b 5d ff	 mov	 rbx, QWORD PTR $T10[rbp-185]
  001f0	48 85 db	 test	 rbx, rbx
  001f3	74 4c		 je	 SHORT $LN139@overflow

; 195  : 			{	// adopted, remove self from list
; 196  : 			_Iterator_base12 **_Pnext = &_Myproxy->_Myfirstiter;

  001f5	48 83 c3 08	 add	 rbx, 8

; 197  : 			while (*_Pnext != 0 && *_Pnext != this)

  001f9	48 83 3b 00	 cmp	 QWORD PTR [rbx], 0
  001fd	74 1d		 je	 SHORT $LN419@overflow
  001ff	90		 npad	 1
$LL137@overflow:
  00200	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00203	48 8d 4d ff	 lea	 rcx, QWORD PTR $T10[rbp-185]
  00207	48 3b c1	 cmp	 rax, rcx
  0020a	74 0a		 je	 SHORT $LN138@overflow

; 198  : 				_Pnext = &(*_Pnext)->_Mynextiter;

  0020c	48 8d 58 08	 lea	 rbx, QWORD PTR [rax+8]

; 197  : 			while (*_Pnext != 0 && *_Pnext != this)

  00210	48 83 3b 00	 cmp	 QWORD PTR [rbx], 0
  00214	75 ea		 jne	 SHORT $LL137@overflow
$LN138@overflow:

; 199  : 
; 200  : 			if (*_Pnext == 0)

  00216	48 83 3b 00	 cmp	 QWORD PTR [rbx], 0
  0021a	75 1a		 jne	 SHORT $LN140@overflow
$LN419@overflow:

; 201  : 				_DEBUG_ERROR("ITERATOR LIST CORRUPTED!");

  0021c	41 b8 c9 00 00
	00		 mov	 r8d, 201		; 000000c9H
  00222	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1JA@IJKHNLMB@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  00229	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@
  00230	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Debug_message@std@@YAXPEB_W0I@Z
$LN140@overflow:

; 202  : 			*_Pnext = _Mynextiter;

  00236	48 8b 45 07	 mov	 rax, QWORD PTR $T10[rbp-177]
  0023a	48 89 03	 mov	 QWORD PTR [rbx], rax

; 203  : 			_Myproxy = 0;

  0023d	4c 89 75 ff	 mov	 QWORD PTR $T10[rbp-185], r14
$LN139@overflow:

; 145  : 		}

  00241	48 8d 4d 77	 lea	 rcx, QWORD PTR _Lock$14[rbp-185]
  00245	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
  0024b	90		 npad	 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream

; 395  : 				switch (_Pcvt->out(_State,

  0024c	85 ff		 test	 edi, edi
  0024e	0f 88 b6 01 00
	00		 js	 $LN22@overflow
  00254	83 ff 01	 cmp	 edi, 1
  00257	0f 8f 8c 01 00
	00		 jg	 $LN398@overflow

; 402  : 					size_t _Count = _Dest - &*_Str.begin();

  0025d	48 8d 55 bf	 lea	 rdx, QWORD PTR $T6[rbp-185]
  00261	48 8d 4d 97	 lea	 rcx, QWORD PTR _Str$4[rbp-185]
  00265	e8 00 00 00 00	 call	 ?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
  0026a	90		 npad	 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 332  : 		return ((reference)**(_Mybase *)this);

  0026b	48 8b c8	 mov	 rcx, rax
  0026e	e8 00 00 00 00	 call	 ??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAAEBDXZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator*
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream

; 402  : 					size_t _Count = _Dest - &*_Str.begin();

  00273	48 8b 7d d7	 mov	 rdi, QWORD PTR _Dest$7[rbp-185]
  00277	48 2b f8	 sub	 rdi, rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 142  : 		_Lockit _Lock(_LOCK_DEBUG);

  0027a	ba 03 00 00 00	 mov	 edx, 3
  0027f	48 8d 4d 7f	 lea	 rcx, QWORD PTR _Lock$15[rbp-185]
  00283	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0_Lockit@std@@QEAA@H@Z

; 194  : 		if (_Myproxy != 0)

  00289	48 8b 5d bf	 mov	 rbx, QWORD PTR $T6[rbp-185]
  0028d	48 85 db	 test	 rbx, rbx
  00290	74 4f		 je	 SHORT $LN159@overflow

; 195  : 			{	// adopted, remove self from list
; 196  : 			_Iterator_base12 **_Pnext = &_Myproxy->_Myfirstiter;

  00292	48 83 c3 08	 add	 rbx, 8

; 197  : 			while (*_Pnext != 0 && *_Pnext != this)

  00296	48 83 3b 00	 cmp	 QWORD PTR [rbx], 0
  0029a	74 20		 je	 SHORT $LN420@overflow
  0029c	0f 1f 40 00	 npad	 4
$LL157@overflow:
  002a0	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  002a3	48 8d 4d bf	 lea	 rcx, QWORD PTR $T6[rbp-185]
  002a7	48 3b c1	 cmp	 rax, rcx
  002aa	74 0a		 je	 SHORT $LN158@overflow

; 198  : 				_Pnext = &(*_Pnext)->_Mynextiter;

  002ac	48 8d 58 08	 lea	 rbx, QWORD PTR [rax+8]

; 197  : 			while (*_Pnext != 0 && *_Pnext != this)

  002b0	48 83 3b 00	 cmp	 QWORD PTR [rbx], 0
  002b4	75 ea		 jne	 SHORT $LL157@overflow
$LN158@overflow:

; 199  : 
; 200  : 			if (*_Pnext == 0)

  002b6	48 83 3b 00	 cmp	 QWORD PTR [rbx], 0
  002ba	75 1a		 jne	 SHORT $LN160@overflow
$LN420@overflow:

; 201  : 				_DEBUG_ERROR("ITERATOR LIST CORRUPTED!");

  002bc	41 b8 c9 00 00
	00		 mov	 r8d, 201		; 000000c9H
  002c2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1JA@IJKHNLMB@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  002c9	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@
  002d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Debug_message@std@@YAXPEB_W0I@Z
$LN160@overflow:

; 202  : 			*_Pnext = _Mynextiter;

  002d6	48 8b 45 c7	 mov	 rax, QWORD PTR $T6[rbp-177]
  002da	48 89 03	 mov	 QWORD PTR [rbx], rax

; 203  : 			_Myproxy = 0;

  002dd	4c 89 75 bf	 mov	 QWORD PTR $T6[rbp-185], r14
$LN159@overflow:

; 145  : 		}

  002e1	48 8d 4d 7f	 lea	 rcx, QWORD PTR _Lock$15[rbp-185]
  002e5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
  002eb	90		 npad	 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream

; 403  : 					if (0 < _Count && _Count !=

  002ec	48 85 ff	 test	 rdi, rdi
  002ef	74 40		 je	 SHORT $LN26@overflow
  002f1	48 8d 55 bf	 lea	 rdx, QWORD PTR $T5[rbp-185]
  002f5	48 8d 4d 97	 lea	 rcx, QWORD PTR _Str$4[rbp-185]
  002f9	e8 00 00 00 00	 call	 ?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
  002fe	90		 npad	 1
  002ff	41 83 cc 01	 or	 r12d, 1
  00303	44 89 65 8b	 mov	 DWORD PTR $T2[rbp-185], r12d
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 332  : 		return ((reference)**(_Mybase *)this);

  00307	48 8b c8	 mov	 rcx, rax
  0030a	e8 00 00 00 00	 call	 ??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAAEBDXZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator*
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream

; 403  : 					if (0 < _Count && _Count !=

  0030f	4d 8b 8f 80 00
	00 00		 mov	 r9, QWORD PTR [r15+128]
  00316	4c 8b c7	 mov	 r8, rdi
  00319	ba 01 00 00 00	 mov	 edx, 1
  0031e	48 8b c8	 mov	 rcx, rax
  00321	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwrite
  00327	48 3b f8	 cmp	 rdi, rax
  0032a	74 05		 je	 SHORT $LN26@overflow
  0032c	40 b6 01	 mov	 sil, 1
  0032f	eb 03		 jmp	 SHORT $LN27@overflow
$LN26@overflow:
  00331	40 32 f6	 xor	 sil, sil
$LN27@overflow:
  00334	41 f6 c4 01	 test	 r12b, 1
  00338	74 72		 je	 SHORT $LN174@overflow
  0033a	41 83 e4 fe	 and	 r12d, -2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 142  : 		_Lockit _Lock(_LOCK_DEBUG);

  0033e	ba 03 00 00 00	 mov	 edx, 3
  00343	48 8d 4d 8f	 lea	 rcx, QWORD PTR _Lock$3[rbp-185]
  00347	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0_Lockit@std@@QEAA@H@Z

; 194  : 		if (_Myproxy != 0)

  0034d	48 8b 5d bf	 mov	 rbx, QWORD PTR $T5[rbp-185]
  00351	48 85 db	 test	 rbx, rbx
  00354	74 4b		 je	 SHORT $LN179@overflow

; 195  : 			{	// adopted, remove self from list
; 196  : 			_Iterator_base12 **_Pnext = &_Myproxy->_Myfirstiter;

  00356	48 83 c3 08	 add	 rbx, 8

; 197  : 			while (*_Pnext != 0 && *_Pnext != this)

  0035a	48 83 3b 00	 cmp	 QWORD PTR [rbx], 0
  0035e	74 1c		 je	 SHORT $LN421@overflow
$LL177@overflow:
  00360	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00363	48 8d 4d bf	 lea	 rcx, QWORD PTR $T5[rbp-185]
  00367	48 3b c1	 cmp	 rax, rcx
  0036a	74 0a		 je	 SHORT $LN178@overflow

; 198  : 				_Pnext = &(*_Pnext)->_Mynextiter;

  0036c	48 8d 58 08	 lea	 rbx, QWORD PTR [rax+8]

; 197  : 			while (*_Pnext != 0 && *_Pnext != this)

  00370	48 83 3b 00	 cmp	 QWORD PTR [rbx], 0
  00374	75 ea		 jne	 SHORT $LL177@overflow
$LN178@overflow:

; 199  : 
; 200  : 			if (*_Pnext == 0)

  00376	48 83 3b 00	 cmp	 QWORD PTR [rbx], 0
  0037a	75 1a		 jne	 SHORT $LN180@overflow
$LN421@overflow:

; 201  : 				_DEBUG_ERROR("ITERATOR LIST CORRUPTED!");

  0037c	41 b8 c9 00 00
	00		 mov	 r8d, 201		; 000000c9H
  00382	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1JA@IJKHNLMB@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  00389	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@
  00390	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Debug_message@std@@YAXPEB_W0I@Z
$LN180@overflow:

; 202  : 			*_Pnext = _Mynextiter;

  00396	48 8b 45 c7	 mov	 rax, QWORD PTR $T5[rbp-177]
  0039a	48 89 03	 mov	 QWORD PTR [rbx], rax

; 203  : 			_Myproxy = 0;

  0039d	4c 89 75 bf	 mov	 QWORD PTR $T5[rbp-185], r14
$LN179@overflow:

; 145  : 		}

  003a1	48 8d 4d 8f	 lea	 rcx, QWORD PTR _Lock$3[rbp-185]
  003a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
  003ab	90		 npad	 1
$LN174@overflow:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream

; 403  : 					if (0 < _Count && _Count !=

  003ac	40 84 f6	 test	 sil, sil
  003af	75 59		 jne	 SHORT $LN22@overflow

; 404  : 						fwrite(&*_Str.begin(), 1, _Count, _Myfile))
; 405  : 						return (_Traits::eof());	// write failed
; 406  : 
; 407  : 					_Wrotesome = true;	// write succeeded

  003b1	41 c6 47 71 01	 mov	 BYTE PTR [r15+113], 1

; 408  : 					if (_Src != &_Ch)

  003b6	48 8d 45 87	 lea	 rax, QWORD PTR _Ch$1[rbp-185]
  003ba	48 39 45 df	 cmp	 QWORD PTR _Src$8[rbp-185], rax
  003be	75 24		 jne	 SHORT $LN400@overflow

; 410  : 
; 411  : 					if (0 < _Count)

  003c0	48 85 ff	 test	 rdi, rdi
  003c3	0f 85 37 fd ff
	ff		 jne	 $LL2@overflow

; 412  : 						;
; 413  : 					else if (_Str.size() < 4 * _STRING_INC)

  003c9	48 83 7d af 20	 cmp	 QWORD PTR _Str$4[rbp-161], 32 ; 00000020H
  003ce	73 3a		 jae	 SHORT $LN22@overflow

; 414  : 						_Str.append(_STRING_INC, '\0');	// try with more space

  003d0	45 33 c0	 xor	 r8d, r8d
  003d3	8d 57 08	 lea	 edx, QWORD PTR [rdi+8]
  003d6	48 8d 4d 97	 lea	 rcx, QWORD PTR _Str$4[rbp-185]
  003da	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 426  : 				}

  003df	e9 1c fd ff ff	 jmp	 $LL2@overflow
$LN400@overflow:

; 409  : 						return (_Meta);	// converted whole element

  003e4	41 8b dd	 mov	 ebx, r13d
  003e7	eb 24		 jmp	 SHORT $LN206@overflow
$LN398@overflow:

; 395  : 				switch (_Pcvt->out(_State,

  003e9	83 ff 03	 cmp	 edi, 3
  003ec	75 1c		 jne	 SHORT $LN22@overflow

; 83   : 	return (fputc(_Byte, _File) != EOF);

  003ee	0f be 4d 87	 movsx	 ecx, BYTE PTR _Ch$1[rbp-185]
  003f2	49 8b 97 80 00
	00 00		 mov	 rdx, QWORD PTR [r15+128]
  003f9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fputc

; 415  : 					else
; 416  : 						return (_Traits::eof());	// conversion failed
; 417  : 					break;
; 418  : 					}
; 419  : 
; 420  : 				case codecvt_base::noconv:
; 421  : 					return (_Fputc(_Ch, _Myfile) ? _Meta

  003ff	83 cb ff	 or	 ebx, -1

; 83   : 	return (fputc(_Byte, _File) != EOF);

  00402	3b c3		 cmp	 eax, ebx

; 415  : 					else
; 416  : 						return (_Traits::eof());	// conversion failed
; 417  : 					break;
; 418  : 					}
; 419  : 
; 420  : 				case codecvt_base::noconv:
; 421  : 					return (_Fputc(_Ch, _Myfile) ? _Meta

  00404	41 0f 45 dd	 cmovne	 ebx, r13d
  00408	eb 03		 jmp	 SHORT $LN206@overflow
$LN22@overflow:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 606  : 		return (EOF);

  0040a	83 cb ff	 or	 ebx, -1
$LN206@overflow:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2246 : 		else if (this->_BUF_SIZE <= this->_Myres())

  0040d	48 8b 55 b7	 mov	 rdx, QWORD PTR _Str$4[rbp-153]
  00411	48 83 fa 10	 cmp	 rdx, 16
  00415	72 12		 jb	 SHORT $LN214@overflow

; 2247 : 			{	// copy any leftovers to small buffer and deallocate
; 2248 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2249 : 			this->_Getal().destroy(&this->_Bx()._Ptr);
; 2250 : 			if (0 < _Newsize)
; 2251 : 				_Traits::copy(this->_Bx()._Buf,
; 2252 : 					_STD addressof(*_Ptr), _Newsize);
; 2253 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

  00417	48 ff c2	 inc	 rdx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 620  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  0041a	41 b8 01 00 00
	00		 mov	 r8d, 1
  00420	48 8b 4d 9f	 mov	 rcx, QWORD PTR _Str$4[rbp-177]
  00424	e8 00 00 00 00	 call	 ?_Deallocate@std@@YAXPEAX_K1@Z ; std::_Deallocate
$LN214@overflow:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2255 : 		this->_Myres() = this->_BUF_SIZE - 1;

  00429	48 c7 45 b7 0f
	00 00 00	 mov	 QWORD PTR _Str$4[rbp-153], 15

; 2214 : 		_Traits::assign(this->_Myptr()[this->_Mysize() = _Newsize], _Elem());

  00431	4c 89 75 af	 mov	 QWORD PTR _Str$4[rbp-161], r14
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  00435	c6 45 9f 00	 mov	 BYTE PTR _Str$4[rbp-177], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 216  : 	if (_Myproxy != 0)

  00439	48 8b 4d 97	 mov	 rcx, QWORD PTR _Str$4[rbp-185]
  0043d	48 85 c9	 test	 rcx, rcx
  00440	74 4c		 je	 SHORT $LN352@overflow

; 217  : 		{	// proxy allocated, drain it
; 218  : 		_Lockit _Lock(_LOCK_DEBUG);

  00442	ba 03 00 00 00	 mov	 edx, 3
  00447	48 8d 4d 6f	 lea	 rcx, QWORD PTR _Lock$12[rbp-185]
  0044b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0_Lockit@std@@QEAA@H@Z

; 219  : 
; 220  : 		for (_Iterator_base12 **_Pnext = &_Myproxy->_Myfirstiter;

  00451	4c 8b 45 97	 mov	 r8, QWORD PTR _Str$4[rbp-185]

; 221  : 			*_Pnext != 0; *_Pnext = (*_Pnext)->_Mynextiter)

  00455	49 83 78 08 00	 cmp	 QWORD PTR [r8+8], 0
  0045a	74 20		 je	 SHORT $LN350@overflow
  0045c	0f 1f 40 00	 npad	 4
$LL351@overflow:

; 222  : 			(*_Pnext)->_Myproxy = 0;

  00460	49 8b 40 08	 mov	 rax, QWORD PTR [r8+8]
  00464	4c 89 30	 mov	 QWORD PTR [rax], r14

; 221  : 			*_Pnext != 0; *_Pnext = (*_Pnext)->_Mynextiter)

  00467	49 8b 40 08	 mov	 rax, QWORD PTR [r8+8]
  0046b	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0046f	49 89 48 08	 mov	 QWORD PTR [r8+8], rcx
  00473	48 85 c9	 test	 rcx, rcx
  00476	75 e8		 jne	 SHORT $LL351@overflow
  00478	4c 8b 45 97	 mov	 r8, QWORD PTR _Str$4[rbp-185]
$LN350@overflow:

; 223  : 		_Myproxy->_Myfirstiter = 0;

  0047c	4d 89 70 08	 mov	 QWORD PTR [r8+8], r14

; 224  : 		}

  00480	48 8d 4d 6f	 lea	 rcx, QWORD PTR _Lock$12[rbp-185]
  00484	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
  0048a	48 8b 4d 97	 mov	 rcx, QWORD PTR _Str$4[rbp-185]
$LN352@overflow:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 620  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  0048e	ba 01 00 00 00	 mov	 edx, 1
  00493	44 8d 42 0f	 lea	 r8d, QWORD PTR [rdx+15]
  00497	e8 00 00 00 00	 call	 ?_Deallocate@std@@YAXPEAX_K1@Z ; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 655  : 		_Myproxy() = 0;

  0049c	4c 89 75 97	 mov	 QWORD PTR _Str$4[rbp-185], r14
  004a0	48 8d 4d 97	 lea	 rcx, QWORD PTR _Str$4[rbp-185]
  004a4	e8 00 00 00 00	 call	 ??1_Container_base12@std@@QEAA@XZ ; std::_Container_base12::~_Container_base12
  004a9	90		 npad	 1
$LN422@overflow:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream

; 425  : 					return (_Traits::eof());	// conversion failed

  004aa	8b c3		 mov	 eax, ebx
$LN13@overflow:

; 427  : 			}
; 428  : 	}

  004ac	48 8b 9c 24 20
	01 00 00	 mov	 rbx, QWORD PTR [rsp+288]
  004b4	48 81 c4 e0 00
	00 00		 add	 rsp, 224		; 000000e0H
  004bb	41 5f		 pop	 r15
  004bd	41 5e		 pop	 r14
  004bf	41 5d		 pop	 r13
  004c1	41 5c		 pop	 r12
  004c3	5f		 pop	 rdi
  004c4	5e		 pop	 rsi
  004c5	5d		 pop	 rbp
  004c6	c3		 ret	 0
?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::overflow
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
_Ch$1 = 64
$T2 = 68
_Lock$3 = 72
_Str$4 = 80
$T5 = 120
$T6 = 120
_Dest$7 = 144
_Src$8 = 152
$T9 = 160
$T10 = 184
$T11 = 208
this$ = 288
_Lock$12 = 296
_Lock$13 = 296
_Meta$ = 296
_Lock$14 = 304
_Lock$15 = 312
?dtor$0@?0??overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::overflow'::`1'::dtor$0
  00000	48 8d 8a 50 00
	00 00		 lea	 rcx, QWORD PTR _Str$4[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::overflow'::`1'::dtor$0
_Ch$1 = 64
$T2 = 68
_Lock$3 = 72
_Str$4 = 80
$T5 = 120
$T6 = 120
_Dest$7 = 144
_Src$8 = 152
$T9 = 160
$T10 = 184
$T11 = 208
this$ = 288
_Lock$12 = 296
_Lock$13 = 296
_Meta$ = 296
_Lock$14 = 304
_Lock$15 = 312
?dtor$1@?0??overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::overflow'::`1'::dtor$1
  0000c	48 8d 8a b8 00
	00 00		 lea	 rcx, QWORD PTR $T10[rdx]
  00013	e9 00 00 00 00	 jmp	 ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@XZ
?dtor$1@?0??overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::overflow'::`1'::dtor$1
_Ch$1 = 64
$T2 = 68
_Lock$3 = 72
_Str$4 = 80
$T5 = 120
$T6 = 120
_Dest$7 = 144
_Src$8 = 152
$T9 = 160
$T10 = 184
$T11 = 208
this$ = 288
_Lock$12 = 296
_Lock$13 = 296
_Meta$ = 296
_Lock$14 = 304
_Lock$15 = 312
?dtor$2@?0??overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::overflow'::`1'::dtor$2
  00018	48 8d 8a a0 00
	00 00		 lea	 rcx, QWORD PTR $T9[rdx]
  0001f	e9 00 00 00 00	 jmp	 ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@XZ
?dtor$2@?0??overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::overflow'::`1'::dtor$2
_Ch$1 = 64
$T2 = 68
_Lock$3 = 72
_Str$4 = 80
$T5 = 120
$T6 = 120
_Dest$7 = 144
_Src$8 = 152
$T9 = 160
$T10 = 184
$T11 = 208
this$ = 288
_Lock$12 = 296
_Lock$13 = 296
_Meta$ = 296
_Lock$14 = 304
_Lock$15 = 312
?dtor$22@?0??overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::overflow'::`1'::dtor$22
  00024	e9 00 00 00 00	 jmp	 __std_terminate
?dtor$22@?0??overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::overflow'::`1'::dtor$22
_Ch$1 = 64
$T2 = 68
_Lock$3 = 72
_Str$4 = 80
$T5 = 120
$T6 = 120
_Dest$7 = 144
_Src$8 = 152
$T9 = 160
$T10 = 184
$T11 = 208
this$ = 288
_Lock$12 = 296
_Lock$13 = 296
_Meta$ = 296
_Lock$14 = 304
_Lock$15 = 312
?dtor$26@?0??overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::overflow'::`1'::dtor$26
  00029	e9 00 00 00 00	 jmp	 __std_terminate
?dtor$26@?0??overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::overflow'::`1'::dtor$26
_Ch$1 = 64
$T2 = 68
_Lock$3 = 72
_Str$4 = 80
$T5 = 120
$T6 = 120
_Dest$7 = 144
_Src$8 = 152
$T9 = 160
$T10 = 184
$T11 = 208
this$ = 288
_Lock$12 = 296
_Lock$13 = 296
_Meta$ = 296
_Lock$14 = 304
_Lock$15 = 312
?dtor$3@?0??overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::overflow'::`1'::dtor$3
  0002e	48 8d 8a 78 00
	00 00		 lea	 rcx, QWORD PTR $T6[rdx]
  00035	e9 00 00 00 00	 jmp	 ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@XZ
?dtor$3@?0??overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::overflow'::`1'::dtor$3
_Ch$1 = 64
$T2 = 68
_Lock$3 = 72
_Str$4 = 80
$T5 = 120
$T6 = 120
_Dest$7 = 144
_Src$8 = 152
$T9 = 160
$T10 = 184
$T11 = 208
this$ = 288
_Lock$12 = 296
_Lock$13 = 296
_Meta$ = 296
_Lock$14 = 304
_Lock$15 = 312
?dtor$30@?0??overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::overflow'::`1'::dtor$30
  0003a	e9 00 00 00 00	 jmp	 __std_terminate
?dtor$30@?0??overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::overflow'::`1'::dtor$30
_Ch$1 = 64
$T2 = 68
_Lock$3 = 72
_Str$4 = 80
$T5 = 120
$T6 = 120
_Dest$7 = 144
_Src$8 = 152
$T9 = 160
$T10 = 184
$T11 = 208
this$ = 288
_Lock$12 = 296
_Lock$13 = 296
_Meta$ = 296
_Lock$14 = 304
_Lock$15 = 312
?dtor$4@?0??overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::overflow'::`1'::dtor$4
  0003f	40 55		 push	 rbp
  00041	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00045	48 8b ea	 mov	 rbp, rdx
  00048	8b 45 44	 mov	 eax, DWORD PTR $T2[rbp]
  0004b	83 e0 01	 and	 eax, 1
  0004e	85 c0		 test	 eax, eax
  00050	74 0d		 je	 SHORT $LN35@dtor$4
  00052	83 65 44 fe	 and	 DWORD PTR $T2[rbp], -2
  00056	48 8d 4d 78	 lea	 rcx, QWORD PTR $T5[rbp]
  0005a	e8 00 00 00 00	 call	 ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@XZ
$LN35@dtor$4:
  0005f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00063	5d		 pop	 rbp
  00064	c3		 ret	 0
?dtor$4@?0??overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::overflow'::`1'::dtor$4
_Ch$1 = 64
$T2 = 68
_Lock$3 = 72
_Str$4 = 80
$T5 = 120
$T6 = 120
_Dest$7 = 144
_Src$8 = 152
$T9 = 160
$T10 = 184
$T11 = 208
this$ = 288
_Lock$12 = 296
_Lock$13 = 296
_Meta$ = 296
_Lock$14 = 304
_Lock$15 = 312
?dtor$34@?0??overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::overflow'::`1'::dtor$34
  00065	e9 00 00 00 00	 jmp	 __std_terminate
?dtor$34@?0??overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::overflow'::`1'::dtor$34
_Ch$1 = 64
$T2 = 68
_Lock$3 = 72
_Str$4 = 80
$T5 = 120
$T6 = 120
_Dest$7 = 144
_Src$8 = 152
$T9 = 160
$T10 = 184
$T11 = 208
this$ = 288
_Lock$12 = 296
_Lock$13 = 296
_Meta$ = 296
_Lock$14 = 304
_Lock$15 = 312
?dtor$76@?0??overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::overflow'::`1'::dtor$76
  0006a	e9 00 00 00 00	 jmp	 __std_terminate
?dtor$76@?0??overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::overflow'::`1'::dtor$76
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Ch$1 = 64
$T2 = 68
_Lock$3 = 72
_Str$4 = 80
$T5 = 120
$T6 = 120
_Dest$7 = 144
_Src$8 = 152
$T9 = 160
$T10 = 184
$T11 = 208
this$ = 288
_Lock$12 = 296
_Lock$13 = 296
_Meta$ = 296
_Lock$14 = 304
_Lock$15 = 312
?dtor$0@?0??overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::overflow'::`1'::dtor$0
  00000	48 8d 8a 50 00
	00 00		 lea	 rcx, QWORD PTR _Str$4[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::overflow'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Ch$1 = 64
$T2 = 68
_Lock$3 = 72
_Str$4 = 80
$T5 = 120
$T6 = 120
_Dest$7 = 144
_Src$8 = 152
$T9 = 160
$T10 = 184
$T11 = 208
this$ = 288
_Lock$12 = 296
_Lock$13 = 296
_Meta$ = 296
_Lock$14 = 304
_Lock$15 = 312
?dtor$1@?0??overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::overflow'::`1'::dtor$1
  0000c	48 8d 8a b8 00
	00 00		 lea	 rcx, QWORD PTR $T10[rdx]
  00013	e9 00 00 00 00	 jmp	 ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@XZ
?dtor$1@?0??overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::overflow'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Ch$1 = 64
$T2 = 68
_Lock$3 = 72
_Str$4 = 80
$T5 = 120
$T6 = 120
_Dest$7 = 144
_Src$8 = 152
$T9 = 160
$T10 = 184
$T11 = 208
this$ = 288
_Lock$12 = 296
_Lock$13 = 296
_Meta$ = 296
_Lock$14 = 304
_Lock$15 = 312
?dtor$2@?0??overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::overflow'::`1'::dtor$2
  00018	48 8d 8a a0 00
	00 00		 lea	 rcx, QWORD PTR $T9[rdx]
  0001f	e9 00 00 00 00	 jmp	 ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@XZ
?dtor$2@?0??overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::overflow'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Ch$1 = 64
$T2 = 68
_Lock$3 = 72
_Str$4 = 80
$T5 = 120
$T6 = 120
_Dest$7 = 144
_Src$8 = 152
$T9 = 160
$T10 = 184
$T11 = 208
this$ = 288
_Lock$12 = 296
_Lock$13 = 296
_Meta$ = 296
_Lock$14 = 304
_Lock$15 = 312
?dtor$22@?0??overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::overflow'::`1'::dtor$22
  00024	e9 00 00 00 00	 jmp	 __std_terminate
?dtor$22@?0??overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::overflow'::`1'::dtor$22
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Ch$1 = 64
$T2 = 68
_Lock$3 = 72
_Str$4 = 80
$T5 = 120
$T6 = 120
_Dest$7 = 144
_Src$8 = 152
$T9 = 160
$T10 = 184
$T11 = 208
this$ = 288
_Lock$12 = 296
_Lock$13 = 296
_Meta$ = 296
_Lock$14 = 304
_Lock$15 = 312
?dtor$26@?0??overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::overflow'::`1'::dtor$26
  00029	e9 00 00 00 00	 jmp	 __std_terminate
?dtor$26@?0??overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::overflow'::`1'::dtor$26
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Ch$1 = 64
$T2 = 68
_Lock$3 = 72
_Str$4 = 80
$T5 = 120
$T6 = 120
_Dest$7 = 144
_Src$8 = 152
$T9 = 160
$T10 = 184
$T11 = 208
this$ = 288
_Lock$12 = 296
_Lock$13 = 296
_Meta$ = 296
_Lock$14 = 304
_Lock$15 = 312
?dtor$3@?0??overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::overflow'::`1'::dtor$3
  0002e	48 8d 8a 78 00
	00 00		 lea	 rcx, QWORD PTR $T6[rdx]
  00035	e9 00 00 00 00	 jmp	 ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@XZ
?dtor$3@?0??overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::overflow'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Ch$1 = 64
$T2 = 68
_Lock$3 = 72
_Str$4 = 80
$T5 = 120
$T6 = 120
_Dest$7 = 144
_Src$8 = 152
$T9 = 160
$T10 = 184
$T11 = 208
this$ = 288
_Lock$12 = 296
_Lock$13 = 296
_Meta$ = 296
_Lock$14 = 304
_Lock$15 = 312
?dtor$30@?0??overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::overflow'::`1'::dtor$30
  0003a	e9 00 00 00 00	 jmp	 __std_terminate
?dtor$30@?0??overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::overflow'::`1'::dtor$30
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Ch$1 = 64
$T2 = 68
_Lock$3 = 72
_Str$4 = 80
$T5 = 120
$T6 = 120
_Dest$7 = 144
_Src$8 = 152
$T9 = 160
$T10 = 184
$T11 = 208
this$ = 288
_Lock$12 = 296
_Lock$13 = 296
_Meta$ = 296
_Lock$14 = 304
_Lock$15 = 312
?dtor$4@?0??overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::overflow'::`1'::dtor$4
  0003f	40 55		 push	 rbp
  00041	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00045	48 8b ea	 mov	 rbp, rdx
  00048	8b 45 44	 mov	 eax, DWORD PTR $T2[rbp]
  0004b	83 e0 01	 and	 eax, 1
  0004e	85 c0		 test	 eax, eax
  00050	74 0d		 je	 SHORT $LN35@dtor$4
  00052	83 65 44 fe	 and	 DWORD PTR $T2[rbp], -2
  00056	48 8d 4d 78	 lea	 rcx, QWORD PTR $T5[rbp]
  0005a	e8 00 00 00 00	 call	 ??1?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@XZ
$LN35@dtor$4:
  0005f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00063	5d		 pop	 rbp
  00064	c3		 ret	 0
?dtor$4@?0??overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::overflow'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Ch$1 = 64
$T2 = 68
_Lock$3 = 72
_Str$4 = 80
$T5 = 120
$T6 = 120
_Dest$7 = 144
_Src$8 = 152
$T9 = 160
$T10 = 184
$T11 = 208
this$ = 288
_Lock$12 = 296
_Lock$13 = 296
_Meta$ = 296
_Lock$14 = 304
_Lock$15 = 312
?dtor$34@?0??overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::overflow'::`1'::dtor$34
  00065	e9 00 00 00 00	 jmp	 __std_terminate
?dtor$34@?0??overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::overflow'::`1'::dtor$34
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Ch$1 = 64
$T2 = 68
_Lock$3 = 72
_Str$4 = 80
$T5 = 120
$T6 = 120
_Dest$7 = 144
_Src$8 = 152
$T9 = 160
$T10 = 184
$T11 = 208
this$ = 288
_Lock$12 = 296
_Lock$13 = 296
_Meta$ = 296
_Lock$14 = 304
_Lock$15 = 312
?dtor$76@?0??overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::overflow'::`1'::dtor$76
  0006a	e9 00 00 00 00	 jmp	 __std_terminate
?dtor$76@?0??overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::overflow'::`1'::dtor$76
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
;	COMDAT ?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Unlock, COMDAT

; 364  : 		if (_Myfile)

  00000	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  00007	48 85 c9	 test	 rcx, rcx
  0000a	74 07		 je	 SHORT $LN2@Unlock

; 365  : 			_CSTD _unlock_file(_Myfile);

  0000c	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp__unlock_file
$LN2@Unlock:

; 366  : 		}

  00013	c3		 ret	 0
?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Unlock
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
;	COMDAT ?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Lock, COMDAT

; 358  : 		if (_Myfile)

  00000	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  00007	48 85 c9	 test	 rcx, rcx
  0000a	74 07		 je	 SHORT $LN2@Lock

; 359  : 			_CSTD _lock_file(_Myfile);

  0000c	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp__lock_file
$LN2@Lock:

; 360  : 		}

  00013	c3		 ret	 0
?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Lock
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
;	COMDAT ?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ
_TEXT	SEGMENT
this$ = 48
?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::close, COMDAT

; 341  : 		{	// close the C stream

$LN19:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 342  : 		_Myt *_Ans = this;
; 343  : 		if (_Myfile == 0)

  0000f	48 83 b9 80 00
	00 00 00	 cmp	 QWORD PTR [rcx+128], 0
  00017	48 8b d9	 mov	 rbx, rcx
  0001a	75 06		 jne	 SHORT $LN2@close

; 344  : 			_Ans = 0;

  0001c	33 ff		 xor	 edi, edi
  0001e	8b f7		 mov	 esi, edi

; 345  : 		else

  00020	eb 23		 jmp	 SHORT $LN5@close
$LN2@close:

; 346  : 			{	// put any homing sequence and close file
; 347  : 			if (!_Endwrite())

  00022	e8 00 00 00 00	 call	 ?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite

; 348  : 				_Ans = 0;
; 349  : 			if (fclose(_Myfile) != 0)

  00027	48 8b 8b 80 00
	00 00		 mov	 rcx, QWORD PTR [rbx+128]
  0002e	33 ff		 xor	 edi, edi
  00030	84 c0		 test	 al, al
  00032	48 8b f3	 mov	 rsi, rbx
  00035	48 0f 44 f7	 cmove	 rsi, rdi
  00039	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fclose
  0003f	85 c0		 test	 eax, eax
  00041	48 0f 45 f7	 cmovne	 rsi, rdi
$LN5@close:

; 610  : 		_Mysb::_Init();	// initialize stream buffer base object

  00045	48 8b cb	 mov	 rcx, rbx
  00048	c6 43 7c 00	 mov	 BYTE PTR [rbx+124], 0
  0004c	c6 43 71 00	 mov	 BYTE PTR [rbx+113], 0
  00050	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXXZ

; 611  : 
; 612  :  #ifndef _IORCNT
; 613  :   #define _IORCNT	_IOCNT	/* read and write counts are the same */
; 614  :   #define _IOWCNT _IOCNT
; 615  :  #endif /* _IORCNT */
; 616  : 
; 617  :   #pragma warning(push)
; 618  :   #pragma warning(disable: 6240)	/* prefast noise VSW 489858 */
; 619  : 		if (_File != 0 && sizeof (_Elem) == 1)
; 620  :   #pragma warning(pop)
; 621  : 
; 622  : 			{	// point inside C stream with [first, first + count) buffer
; 623  : 			_Elem **_Pb = 0;
; 624  : 			_Elem **_Pn = 0;
; 625  : 			int *_Nr = 0;
; 626  : 
; 627  : 			::_get_stream_buffer_pointers(
; 628  : 				_File,
; 629  : 				reinterpret_cast<char***>(&_Pb),
; 630  : 				reinterpret_cast<char***>(&_Pn),
; 631  : 				&_Nr);
; 632  : 			int *_Nw = _Nr;
; 633  : 
; 634  : 			_Mysb::_Init(_Pb, _Pn, _Nr, _Pb, _Pn, _Nw);
; 635  : 			}
; 636  : 
; 637  : 		_Myfile = _File;

  00056	48 89 bb 80 00
	00 00		 mov	 QWORD PTR [rbx+128], rdi

; 350  : 				_Ans = 0;
; 351  : 			}
; 352  : 		_Init(0, _Closefl);
; 353  : 		return (_Ans);

  0005d	48 8b c6	 mov	 rax, rsi

; 638  : 		_State = _Stinit;

  00060	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit

; 354  : 		}

  00067	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]

; 638  : 		_State = _Stinit;

  0006c	48 89 4b 74	 mov	 QWORD PTR [rbx+116], rcx

; 639  : 		_Pcvt = 0;	// pointer to codecvt facet

  00070	48 89 7b 68	 mov	 QWORD PTR [rbx+104], rdi

; 354  : 		}

  00074	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00079	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007d	5f		 pop	 rdi
  0007e	c3		 ret	 0
?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::close
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
;	COMDAT ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z
_TEXT	SEGMENT
_Pn$1 = 32
_Nr$2 = 40
$T3 = 40
$T4 = 56
_Pb$5 = 80
this$ = 80
_Filename$ = 88
_Mode$ = 96
_Prot$ = 104
?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::open, COMDAT

; 265  : 		{	// open a C stream with specified mode

$LN33:
  00000	40 57		 push	 rdi
  00002	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00006	48 c7 44 24 38
	fe ff ff ff	 mov	 QWORD PTR $T4[rsp], -2
  0000f	48 89 5c 24 58	 mov	 QWORD PTR [rsp+88], rbx
  00014	48 89 74 24 60	 mov	 QWORD PTR [rsp+96], rsi
  00019	41 8b c0	 mov	 eax, r8d
  0001c	4c 8b d2	 mov	 r10, rdx
  0001f	48 8b d9	 mov	 rbx, rcx

; 266  : 		_Filet *_File;
; 267  : 		if (_Myfile != 0 || (_File = _Fiopen(_Filename, _Mode, _Prot)) == 0)

  00022	48 83 b9 80 00
	00 00 00	 cmp	 QWORD PTR [rcx+128], 0
  0002a	0f 85 f5 00 00
	00		 jne	 $LN3@open
  00030	45 8b c1	 mov	 r8d, r9d
  00033	8b d0		 mov	 edx, eax
  00035	49 8b ca	 mov	 rcx, r10
  00038	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Fiopen@std@@YAPEAU_iobuf@@PEBDHH@Z
  0003e	48 8b f8	 mov	 rdi, rax
  00041	48 85 c0	 test	 rax, rax
  00044	0f 84 db 00 00
	00		 je	 $LN3@open

; 607  : 		_Closef = _Which == _Openfl;

  0004a	c6 43 7c 01	 mov	 BYTE PTR [rbx+124], 1

; 608  : 		_Wrotesome = false;

  0004e	c6 43 71 00	 mov	 BYTE PTR [rbx+113], 0

; 609  : 
; 610  : 		_Mysb::_Init();	// initialize stream buffer base object

  00052	48 8b cb	 mov	 rcx, rbx
  00055	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXXZ

; 611  : 
; 612  :  #ifndef _IORCNT
; 613  :   #define _IORCNT	_IOCNT	/* read and write counts are the same */
; 614  :   #define _IOWCNT _IOCNT
; 615  :  #endif /* _IORCNT */
; 616  : 
; 617  :   #pragma warning(push)
; 618  :   #pragma warning(disable: 6240)	/* prefast noise VSW 489858 */
; 619  : 		if (_File != 0 && sizeof (_Elem) == 1)
; 620  :   #pragma warning(pop)
; 621  : 
; 622  : 			{	// point inside C stream with [first, first + count) buffer
; 623  : 			_Elem **_Pb = 0;

  0005b	33 f6		 xor	 esi, esi
  0005d	48 89 74 24 50	 mov	 QWORD PTR _Pb$5[rsp], rsi

; 624  : 			_Elem **_Pn = 0;

  00062	48 89 74 24 20	 mov	 QWORD PTR _Pn$1[rsp], rsi

; 625  : 			int *_Nr = 0;

  00067	48 89 74 24 28	 mov	 QWORD PTR _Nr$2[rsp], rsi

; 626  : 
; 627  : 			::_get_stream_buffer_pointers(

  0006c	4c 8d 4c 24 28	 lea	 r9, QWORD PTR _Nr$2[rsp]
  00071	4c 8d 44 24 20	 lea	 r8, QWORD PTR _Pn$1[rsp]
  00076	48 8d 54 24 50	 lea	 rdx, QWORD PTR _Pb$5[rsp]
  0007b	48 8b cf	 mov	 rcx, rdi
  0007e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__get_stream_buffer_pointers
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 332  : 		_IGfirst = _Gf;

  00084	48 8b 44 24 50	 mov	 rax, QWORD PTR _Pb$5[rsp]
  00089	48 89 43 18	 mov	 QWORD PTR [rbx+24], rax

; 333  : 		_IPfirst = _Pf;

  0008d	48 89 43 20	 mov	 QWORD PTR [rbx+32], rax

; 334  : 		_IGnext = _Gn;

  00091	48 8b 44 24 20	 mov	 rax, QWORD PTR _Pn$1[rsp]
  00096	48 89 43 38	 mov	 QWORD PTR [rbx+56], rax

; 335  : 		_IPnext = _Pn;

  0009a	48 89 43 40	 mov	 QWORD PTR [rbx+64], rax

; 336  : 		_IGcount = _Gc;

  0009e	48 8b 44 24 28	 mov	 rax, QWORD PTR _Nr$2[rsp]
  000a3	48 89 43 50	 mov	 QWORD PTR [rbx+80], rax

; 337  : 		_IPcount = _Pc;

  000a7	48 89 43 58	 mov	 QWORD PTR [rbx+88], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream

; 637  : 		_Myfile = _File;

  000ab	48 89 bb 80 00
	00 00		 mov	 QWORD PTR [rbx+128], rdi

; 638  : 		_State = _Stinit;

  000b2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit
  000b9	48 89 43 74	 mov	 QWORD PTR [rbx+116], rax

; 639  : 		_Pcvt = 0;	// pointer to codecvt facet

  000bd	48 89 73 68	 mov	 QWORD PTR [rbx+104], rsi

; 269  : 
; 270  : 		_Init(_File, _Openfl);
; 271  : 		_Initcvt(&_USE(_Mysb::getloc(), _Cvt));

  000c1	48 8d 54 24 28	 lea	 rdx, QWORD PTR $T3[rsp]
  000c6	48 8b cb	 mov	 rcx, rbx
  000c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?getloc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEBA?AVlocale@2@XZ
  000cf	90		 npad	 1
  000d0	48 8b c8	 mov	 rcx, rax
  000d3	e8 00 00 00 00	 call	 ??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z ; std::use_facet<std::codecvt<char,char,_Mbstatet> >
  000d8	48 8b f8	 mov	 rdi, rax

; 685  : 		if (_Newpcvt->always_noconv())

  000db	48 8b c8	 mov	 rcx, rax
  000de	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?always_noconv@codecvt_base@std@@QEBA_NXZ
  000e4	84 c0		 test	 al, al
  000e6	74 06		 je	 SHORT $LN18@open

; 686  : 			_Pcvt = 0;	// nothing to do

  000e8	48 89 73 68	 mov	 QWORD PTR [rbx+104], rsi

; 687  : 		else

  000ec	eb 0e		 jmp	 SHORT $LN19@open
$LN18@open:

; 688  : 			{	// set up for nontrivial codecvt facet
; 689  : 			_Pcvt = _Newpcvt;

  000ee	48 89 7b 68	 mov	 QWORD PTR [rbx+104], rdi

; 690  : 			_Mysb::_Init();	// reset any buffering

  000f2	48 8b cb	 mov	 rcx, rbx
  000f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXXZ
  000fb	90		 npad	 1
$LN19@open:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale

; 431  : 		if (_Ptr != 0)

  000fc	48 8b 4c 24 30	 mov	 rcx, QWORD PTR $T3[rsp+8]
  00101	48 85 c9	 test	 rcx, rcx
  00104	74 1a		 je	 SHORT $LN30@open

; 432  : 			delete _Ptr->_Decref();

  00106	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00109	ff 50 10	 call	 QWORD PTR [rax+16]
  0010c	48 85 c0	 test	 rax, rax
  0010f	74 0f		 je	 SHORT $LN30@open
  00111	4c 8b 00	 mov	 r8, QWORD PTR [rax]
  00114	ba 01 00 00 00	 mov	 edx, 1
  00119	48 8b c8	 mov	 rcx, rax
  0011c	41 ff 10	 call	 QWORD PTR [r8]
  0011f	90		 npad	 1
$LN30@open:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream

; 272  : 		return (this);	// open succeeded

  00120	48 8b c3	 mov	 rax, rbx
  00123	eb 02		 jmp	 SHORT $LN1@open
$LN3@open:

; 268  : 			return (0);	// open failed

  00125	33 c0		 xor	 eax, eax
$LN1@open:

; 273  : 		}

  00127	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  0012c	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  00131	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00135	5f		 pop	 rdi
  00136	c3		 ret	 0
?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::open
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
_Pn$1 = 32
_Nr$2 = 40
$T3 = 40
$T4 = 56
_Pb$5 = 80
this$ = 80
_Filename$ = 88
_Mode$ = 96
_Prot$ = 104
?dtor$0@?0??open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::open'::`1'::dtor$0
  00000	48 8d 8a 28 00
	00 00		 lea	 rcx, QWORD PTR $T3[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1locale@std@@QEAA@XZ	; std::locale::~locale
?dtor$0@?0??open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::open'::`1'::dtor$0
_Pn$1 = 32
_Nr$2 = 40
$T3 = 40
$T4 = 56
_Pb$5 = 80
this$ = 80
_Filename$ = 88
_Mode$ = 96
_Prot$ = 104
?dtor$1@?0??open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::open'::`1'::dtor$1
  0000c	e9 00 00 00 00	 jmp	 __std_terminate
?dtor$1@?0??open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::open'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Pn$1 = 32
_Nr$2 = 40
$T3 = 40
$T4 = 56
_Pb$5 = 80
this$ = 80
_Filename$ = 88
_Mode$ = 96
_Prot$ = 104
?dtor$0@?0??open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::open'::`1'::dtor$0
  00000	48 8d 8a 28 00
	00 00		 lea	 rcx, QWORD PTR $T3[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1locale@std@@QEAA@XZ	; std::locale::~locale
?dtor$0@?0??open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::open'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Pn$1 = 32
_Nr$2 = 40
$T3 = 40
$T4 = 56
_Pb$5 = 80
this$ = 80
_Filename$ = 88
_Mode$ = 96
_Prot$ = 104
?dtor$1@?0??open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::open'::`1'::dtor$1
  0000c	e9 00 00 00 00	 jmp	 __std_terminate
?dtor$1@?0??open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::open'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
;	COMDAT ??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >, COMDAT

; 151  : 		{	// destroy the object

$LN12:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  0000f	48 8b d9	 mov	 rbx, rcx
  00012	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
  00019	48 89 01	 mov	 QWORD PTR [rcx], rax

; 152  : 		if (_Myfile != 0)

  0001c	48 83 b9 80 00
	00 00 00	 cmp	 QWORD PTR [rcx+128], 0
  00024	74 2f		 je	 SHORT $LN6@basic_file
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 222  : 		return (*_IGfirst);

  00026	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream

; 704  : 		if (_Mysb::eback() == &_Mychar)

  0002a	48 8d 43 70	 lea	 rax, QWORD PTR [rbx+112]
  0002e	48 39 01	 cmp	 QWORD PTR [rcx], rax
  00031	75 22		 jne	 SHORT $LN6@basic_file

; 705  : 			_Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

  00033	4c 8b 83 90 00
	00 00		 mov	 r8, QWORD PTR [rbx+144]
  0003a	48 8b 93 88 00
	00 00		 mov	 rdx, QWORD PTR [rbx+136]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 253  : 		*_IGfirst = _First;

  00041	48 89 11	 mov	 QWORD PTR [rcx], rdx

; 254  : 		*_IGnext = _Next;

  00044	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  00048	48 89 10	 mov	 QWORD PTR [rax], rdx

; 255  : 		*_IGcount = (int)(_Last - _Next);

  0004b	44 2b c2	 sub	 r8d, edx
  0004e	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00052	44 89 00	 mov	 DWORD PTR [rax], r8d
$LN6@basic_file:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream

; 154  : 		if (_Closef)

  00055	80 7b 7c 00	 cmp	 BYTE PTR [rbx+124], 0
  00059	74 09		 je	 SHORT $LN3@basic_file

; 155  : 			close();

  0005b	48 8b cb	 mov	 rcx, rbx
  0005e	e8 00 00 00 00	 call	 ?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
  00063	90		 npad	 1
$LN3@basic_file:

; 156  : 		}

  00064	48 8b cb	 mov	 rcx, rbx
  00067	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0006b	5b		 pop	 rbx
  0006c	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
;	COMDAT ??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@PEAU_iobuf@@@Z
_TEXT	SEGMENT
$T1 = 32
_Pb$2 = 80
this$ = 80
_Pn$3 = 88
_File$ = 88
_Nr$4 = 96
??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@PEAU_iobuf@@@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::basic_filebuf<char,std::char_traits<char> >, COMDAT

; 146  : 		{	// construct from pointer to C stream

$LN15:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	53		 push	 rbx
  00006	56		 push	 rsi
  00007	57		 push	 rdi
  00008	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000c	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  00015	48 8b fa	 mov	 rdi, rdx
  00018	48 8b d9	 mov	 rbx, rcx

; 145  : 		: _Mysb()

  0001b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAA@XZ
  00021	90		 npad	 1

; 146  : 		{	// construct from pointer to C stream

  00022	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
  00029	48 89 03	 mov	 QWORD PTR [rbx], rax

; 607  : 		_Closef = _Which == _Openfl;

  0002c	c6 43 7c 00	 mov	 BYTE PTR [rbx+124], 0

; 608  : 		_Wrotesome = false;

  00030	c6 43 71 00	 mov	 BYTE PTR [rbx+113], 0

; 609  : 
; 610  : 		_Mysb::_Init();	// initialize stream buffer base object

  00034	48 8b cb	 mov	 rcx, rbx
  00037	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXXZ

; 611  : 
; 612  :  #ifndef _IORCNT
; 613  :   #define _IORCNT	_IOCNT	/* read and write counts are the same */
; 614  :   #define _IOWCNT _IOCNT
; 615  :  #endif /* _IORCNT */
; 616  : 
; 617  :   #pragma warning(push)
; 618  :   #pragma warning(disable: 6240)	/* prefast noise VSW 489858 */
; 619  : 		if (_File != 0 && sizeof (_Elem) == 1)

  0003d	33 f6		 xor	 esi, esi
  0003f	48 85 ff	 test	 rdi, rdi
  00042	74 4e		 je	 SHORT $LN5@basic_file

; 620  :   #pragma warning(pop)
; 621  : 
; 622  : 			{	// point inside C stream with [first, first + count) buffer
; 623  : 			_Elem **_Pb = 0;

  00044	48 89 74 24 50	 mov	 QWORD PTR _Pb$2[rsp], rsi

; 624  : 			_Elem **_Pn = 0;

  00049	48 89 74 24 58	 mov	 QWORD PTR _Pn$3[rsp], rsi

; 625  : 			int *_Nr = 0;

  0004e	48 89 74 24 60	 mov	 QWORD PTR _Nr$4[rsp], rsi

; 626  : 
; 627  : 			::_get_stream_buffer_pointers(

  00053	4c 8d 4c 24 60	 lea	 r9, QWORD PTR _Nr$4[rsp]
  00058	4c 8d 44 24 58	 lea	 r8, QWORD PTR _Pn$3[rsp]
  0005d	48 8d 54 24 50	 lea	 rdx, QWORD PTR _Pb$2[rsp]
  00062	48 8b cf	 mov	 rcx, rdi
  00065	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__get_stream_buffer_pointers
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 332  : 		_IGfirst = _Gf;

  0006b	48 8b 44 24 50	 mov	 rax, QWORD PTR _Pb$2[rsp]
  00070	48 89 43 18	 mov	 QWORD PTR [rbx+24], rax

; 333  : 		_IPfirst = _Pf;

  00074	48 89 43 20	 mov	 QWORD PTR [rbx+32], rax

; 334  : 		_IGnext = _Gn;

  00078	48 8b 44 24 58	 mov	 rax, QWORD PTR _Pn$3[rsp]
  0007d	48 89 43 38	 mov	 QWORD PTR [rbx+56], rax

; 335  : 		_IPnext = _Pn;

  00081	48 89 43 40	 mov	 QWORD PTR [rbx+64], rax

; 336  : 		_IGcount = _Gc;

  00085	48 8b 44 24 60	 mov	 rax, QWORD PTR _Nr$4[rsp]
  0008a	48 89 43 50	 mov	 QWORD PTR [rbx+80], rax

; 337  : 		_IPcount = _Pc;

  0008e	48 89 43 58	 mov	 QWORD PTR [rbx+88], rax
$LN5@basic_file:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream

; 637  : 		_Myfile = _File;

  00092	48 89 bb 80 00
	00 00		 mov	 QWORD PTR [rbx+128], rdi

; 638  : 		_State = _Stinit;

  00099	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit
  000a0	48 89 43 74	 mov	 QWORD PTR [rbx+116], rax

; 639  : 		_Pcvt = 0;	// pointer to codecvt facet

  000a4	48 89 73 68	 mov	 QWORD PTR [rbx+104], rsi

; 147  : 		_Init(_File, _Newfl);
; 148  : 		}

  000a8	48 8b c3	 mov	 rax, rbx
  000ab	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000af	5f		 pop	 rdi
  000b0	5e		 pop	 rsi
  000b1	5b		 pop	 rbx
  000b2	c3		 ret	 0
??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@PEAU_iobuf@@@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::basic_filebuf<char,std::char_traits<char> >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_Pb$2 = 80
this$ = 80
_Pn$3 = 88
_File$ = 88
_Nr$4 = 96
?dtor$0@?0???0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@PEAU_iobuf@@@Z@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::basic_filebuf<char,std::char_traits<char> >'::`1'::dtor$0
  00000	48 8b 8a 50 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00007	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$0@?0???0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@PEAU_iobuf@@@Z@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::basic_filebuf<char,std::char_traits<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_Pb$2 = 80
this$ = 80
_Pn$3 = 88
_File$ = 88
_Nr$4 = 96
?dtor$0@?0???0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@PEAU_iobuf@@@Z@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::basic_filebuf<char,std::char_traits<char> >'::`1'::dtor$0
  00000	48 8b 8a 50 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00007	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$0@?0???0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@PEAU_iobuf@@@Z@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::basic_filebuf<char,std::char_traits<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
;	COMDAT ?close@?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?close@?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXXZ PROC ; std::basic_fstream<char,std::char_traits<char> >::close, COMDAT

; 1330 : 		{	// close the C stream

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 1331 : 		if (_Filebuffer.close() == 0)

  00009	48 83 c1 18	 add	 rcx, 24
  0000d	e8 00 00 00 00	 call	 ?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
  00012	48 85 c0	 test	 rax, rax
  00015	75 1d		 jne	 SHORT $LN2@close

; 1332 : 			_Myios::setstate(ios_base::failbit);

  00017	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0001a	45 33 c0	 xor	 r8d, r8d
  0001d	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00021	41 8d 50 02	 lea	 edx, QWORD PTR [r8+2]
  00025	48 03 cb	 add	 rcx, rbx

; 1333 : 	}

  00028	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002c	5b		 pop	 rbx

; 1332 : 			_Myios::setstate(ios_base::failbit);

  0002d	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
$LN2@close:

; 1333 : 	}

  00034	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00038	5b		 pop	 rbx
  00039	c3		 ret	 0
?close@?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXXZ ENDP ; std::basic_fstream<char,std::char_traits<char> >::close
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
;	COMDAT ?open@?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXPEBDHH@Z
_TEXT	SEGMENT
this$ = 48
_Filename$ = 56
_Mode$ = 64
_Prot$ = 72
?open@?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXPEBDHH@Z PROC ; std::basic_fstream<char,std::char_traits<char> >::open, COMDAT

; 1308 : 		{	// open a C stream with specified mode

$LN6:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 1309 : 		if (_Filebuffer.open(_Filename, _Mode, _Prot) == 0)

  00009	48 83 c1 18	 add	 rcx, 24
  0000d	e8 00 00 00 00	 call	 ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::open

; 1310 : 			_Myios::setstate(ios_base::failbit);

  00012	45 33 c0	 xor	 r8d, r8d
  00015	48 85 c0	 test	 rax, rax
  00018	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0001b	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  0001f	75 13		 jne	 SHORT $LN2@open
  00021	48 03 cb	 add	 rcx, rbx
  00024	41 8d 50 02	 lea	 edx, QWORD PTR [r8+2]

; 1313 : 		}

  00028	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002c	5b		 pop	 rbx

; 1310 : 			_Myios::setstate(ios_base::failbit);

  0002d	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
$LN2@open:

; 1311 : 		else
; 1312 : 			_Myios::clear();	// added with C++11

  00034	48 03 cb	 add	 rcx, rbx
  00037	33 d2		 xor	 edx, edx

; 1313 : 		}

  00039	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003d	5b		 pop	 rbx

; 1311 : 		else
; 1312 : 			_Myios::clear();	// added with C++11

  0003e	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
?open@?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXPEBDHH@Z ENDP ; std::basic_fstream<char,std::char_traits<char> >::open
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
;	COMDAT ??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UEAA@XZ PROC ; std::basic_fstream<char,std::char_traits<char> >::~basic_fstream<char,std::char_traits<char> >, COMDAT

; 1292 : 		{	// destroy the object

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b 81 48 ff
	ff ff		 mov	 rax, QWORD PTR [rcx-184]
  0000d	48 8b d9	 mov	 rbx, rcx
  00010	48 63 50 04	 movsxd	 rdx, DWORD PTR [rax+4]
  00014	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@
  0001b	48 89 84 0a 48
	ff ff ff	 mov	 QWORD PTR [rdx+rcx-184], rax
  00023	48 8b 81 48 ff
	ff ff		 mov	 rax, QWORD PTR [rcx-184]
  0002a	48 63 50 04	 movsxd	 rdx, DWORD PTR [rax+4]
  0002e	44 8d 82 48 ff
	ff ff		 lea	 r8d, DWORD PTR [rdx-184]
  00035	44 89 84 0a 44
	ff ff ff	 mov	 DWORD PTR [rdx+rcx-188], r8d

; 1293 : 		}

  0003d	48 81 c1 60 ff
	ff ff		 add	 rcx, -160		; ffffffffffffff60H
  00044	e8 00 00 00 00	 call	 ??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
  00049	48 8d 8b 68 ff
	ff ff		 lea	 rcx, QWORD PTR [rbx-152]
  00050	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00054	5b		 pop	 rbx
  00055	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UEAA@XZ
??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UEAA@XZ ENDP ; std::basic_fstream<char,std::char_traits<char> >::~basic_fstream<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
;	COMDAT ??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
$T2 = 72
$initVBases$ = 72
this$ = 80
??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ PROC ; std::basic_fstream<char,std::char_traits<char> >::basic_fstream<char,std::char_traits<char> >, COMDAT

; 1158 : 		{	// construct unopened

$LN22:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  00013	48 89 5c 24 58	 mov	 QWORD PTR [rsp+88], rbx
  00018	48 8b f9	 mov	 rdi, rcx
  0001b	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR $T2[rsp], 0
  00023	85 d2		 test	 edx, edx
  00025	74 2b		 je	 SHORT $LN2@basic_fstr
  00027	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_8?$basic_fstream@DU?$char_traits@D@std@@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@
  0002e	48 89 01	 mov	 QWORD PTR [rcx], rax
  00031	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_8?$basic_fstream@DU?$char_traits@D@std@@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@
  00038	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax
  0003c	48 81 c1 b8 00
	00 00		 add	 rcx, 184		; 000000b8H
  00043	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IEAA@XZ
  00049	90		 npad	 1
  0004a	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR $T2[rsp], 1
$LN2@basic_fstr:

; 640  : 		}
; 641  : 
; 642  : 	bool _Endwrite()
; 643  : 		{	// put shift to initial conversion state, as needed
; 644  : 		if (_Pcvt == 0 || !_Wrotesome)
; 645  : 			return (true);
; 646  : 		else
; 647  : 			{	// may have to put
; 648  : 			const int _STRING_INC = 8;
; 649  : 			char *_Dest;
; 650  : 			if (_Traits::eq_int_type(_Traits::eof(), overflow()))
; 651  : 				return (false);
; 652  : 
; 653  : 			string _Str(_STRING_INC, '\0');
; 654  : 			for (; ; )
; 655  : 				switch (_Pcvt->unshift(_State,
; 656  : 					&*_Str.begin(), &*_Str.begin() + _Str.size(), _Dest))
; 657  : 				{	// test result of homing conversion
; 658  : 				case codecvt_base::ok:
; 659  : 					_Wrotesome = false;	// homed successfully
; 660  : 
; 661  : 				case codecvt_base::partial:	// fall through
; 662  : 					{	// put any generated bytes
; 663  : 					size_t _Count = _Dest - &*_Str.begin();
; 664  : 					if (0 < _Count && _Count !=
; 665  : 						fwrite(&*_Str.begin(), 1, _Count, _Myfile))
; 666  : 						return (false);	// write failed
; 667  : 					if (!_Wrotesome)
; 668  : 						return (true);
; 669  : 					if (_Count == 0)
; 670  : 						_Str.append(_STRING_INC, '\0');	// try with more space
; 671  : 					break;
; 672  : 					}
; 673  : 
; 674  : 				case codecvt_base::noconv:
; 675  : 					return (true);	// nothing to do
; 676  : 
; 677  : 				default:
; 678  : 					return (false);	// conversion failed
; 679  : 				}
; 680  : 			}
; 681  : 		}
; 682  : 
; 683  : 	void _Initcvt(const _Cvt *_Newpcvt)
; 684  : 		{	// initialize codecvt pointer
; 685  : 		if (_Newpcvt->always_noconv())
; 686  : 			_Pcvt = 0;	// nothing to do
; 687  : 		else
; 688  : 			{	// set up for nontrivial codecvt facet
; 689  : 			_Pcvt = _Newpcvt;
; 690  : 			_Mysb::_Init();	// reset any buffering
; 691  : 			}
; 692  : 		}
; 693  : 
; 694  : private:
; 695  : 	const _Cvt *_Pcvt;	// pointer to codecvt facet (may be null)
; 696  : 	_Elem _Mychar;	// putback character, when _Ungetc fails
; 697  : 	bool _Wrotesome;	// true if homing sequence may be needed
; 698  : 	typename _Traits::state_type _State;	// current conversion state
; 699  : 	bool _Closef;	// true if C stream must be closed
; 700  : 	_Filet *_Myfile;	// pointer to C stream
; 701  : 
; 702  : 	void _Reset_back()
; 703  : 		{	// restore buffer after putback
; 704  : 		if (_Mysb::eback() == &_Mychar)
; 705  : 			_Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);
; 706  : 		}
; 707  : 
; 708  : 	void _Set_back()
; 709  : 		{	// set up putback area
; 710  : 		if (_Mysb::eback() != &_Mychar)
; 711  : 			{	// save current get buffer
; 712  : 			_Set_eback = _Mysb::eback();
; 713  : 			_Set_egptr = _Mysb::egptr();
; 714  : 			}
; 715  : 		_Mysb::setg(&_Mychar, &_Mychar, &_Mychar + 1);
; 716  : 		}
; 717  : 
; 718  : 	_Elem *_Set_eback;	// saves eback() during one-element putback
; 719  : 	_Elem *_Set_egptr;	// saves egptr()
; 720  : 	};
; 721  : 
; 722  : 	// basic_filebuf TEMPLATE OPERATORS
; 723  : template<class _Elem,
; 724  : 	class _Traits> inline
; 725  : 	void swap(basic_filebuf<_Elem, _Traits>& _Left,
; 726  : 		basic_filebuf<_Elem, _Traits>& _Right)
; 727  : 	{	// swap _Left and _Right basic_filebufs
; 728  : 	_Left.swap(_Right);
; 729  : 	}
; 730  : 
; 731  : 		// TEMPLATE CLASS basic_ifstream
; 732  : template<class _Elem,
; 733  : 	class _Traits>
; 734  : 	class basic_ifstream
; 735  : 		: public basic_istream<_Elem, _Traits>
; 736  : 	{	// input stream associated with a C stream
; 737  : public:
; 738  : 	typedef basic_ifstream<_Elem, _Traits> _Myt;
; 739  : 	typedef basic_istream<_Elem, _Traits> _Mybase;
; 740  : 	typedef basic_filebuf<_Elem, _Traits> _Myfb;
; 741  : 	typedef basic_ios<_Elem, _Traits> _Myios;
; 742  : 
; 743  : 	basic_ifstream()
; 744  : 		: _Mybase(&_Filebuffer)
; 745  : 		{	// construct unopened
; 746  : 		}
; 747  : 
; 748  : 	explicit basic_ifstream(const char *_Filename,
; 749  : 		ios_base::openmode _Mode = ios_base::in,
; 750  : 		int _Prot = (int)ios_base::_Openprot)
; 751  : 		: _Mybase(&_Filebuffer)
; 752  : 		{	// construct with named file and specified mode
; 753  : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
; 754  : 			_Myios::setstate(ios_base::failbit);
; 755  : 		}
; 756  : 
; 757  : 	explicit basic_ifstream(const string& _Str,
; 758  : 		ios_base::openmode _Mode = ios_base::in,
; 759  : 		int _Prot = (int)ios_base::_Openprot)
; 760  : 		: _Mybase(&_Filebuffer)
; 761  : 		{	// construct with named file and specified mode
; 762  : 		if (_Filebuffer.open(_Str.c_str(), _Mode | ios_base::in, _Prot) == 0)
; 763  : 			_Myios::setstate(ios_base::failbit);
; 764  : 		}
; 765  : 
; 766  : 	explicit basic_ifstream(const wchar_t *_Filename,
; 767  : 		ios_base::openmode _Mode = ios_base::in,
; 768  : 		int _Prot = (int)ios_base::_Openprot)
; 769  : 		: _Mybase(&_Filebuffer)
; 770  : 		{	// construct with wide-named file -- EXTENSION
; 771  : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
; 772  : 			_Myios::setstate(ios_base::failbit);
; 773  : 		}
; 774  : 
; 775  : 	explicit basic_ifstream(const wstring& _Str,
; 776  : 		ios_base::openmode _Mode = ios_base::in,
; 777  : 		int _Prot = (int)ios_base::_Openprot)
; 778  : 		: _Mybase(&_Filebuffer)
; 779  : 		{	// construct with wide-named file -- EXTENSION
; 780  : 		if (_Filebuffer.open(_Str.c_str(), _Mode | ios_base::in, _Prot) == 0)
; 781  : 			_Myios::setstate(ios_base::failbit);
; 782  : 		}
; 783  : 
; 784  :  #ifdef _NATIVE_WCHAR_T_DEFINED
; 785  : 	explicit basic_ifstream(const unsigned short *_Filename,
; 786  : 		ios_base::openmode _Mode = ios_base::in,
; 787  : 		int _Prot = (int)ios_base::_Openprot)
; 788  : 		: _Mybase(&_Filebuffer)
; 789  : 		{	// construct with wide-named file -- EXTENSION
; 790  : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
; 791  : 			_Myios::setstate(ios_base::failbit);
; 792  : 		}
; 793  :  #endif /* _NATIVE_WCHAR_T_DEFINED */
; 794  : 
; 795  : 	explicit basic_ifstream(_Filet *_File)
; 796  : 		: _Mybase(&_Filebuffer),
; 797  : 			_Filebuffer(_File)
; 798  : 		{	// construct with specified C stream
; 799  : 		}
; 800  : 
; 801  : 	basic_ifstream(_Myt&& _Right)
; 802  : 		: _Mybase(&_Filebuffer)
; 803  : 		{	// construct by moving _Right
; 804  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 805  : 		}
; 806  : 
; 807  : 	_Myt& operator=(_Myt&& _Right)
; 808  : 		{	// move from _Right
; 809  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 810  : 		return (*this);
; 811  : 		}
; 812  : 
; 813  : 	void _Assign_rv(_Myt&& _Right)
; 814  : 		{	// assign by moving _Right
; 815  : 		if (this != &_Right)
; 816  : 			{	// different, worth moving
; 817  : 			_Filebuffer.close();
; 818  : 			this->swap(_Right);
; 819  : 			}
; 820  : 		}
; 821  : 
; 822  : 	void swap(_Myt& _Right)
; 823  : 		{	// swap with _Right
; 824  : 		if (this != &_Right)
; 825  : 			{	// different, swap base and buffer
; 826  : 			_Mybase::swap(_Right);
; 827  : 			_Filebuffer.swap(_Right._Filebuffer);
; 828  : 			}
; 829  : 		}
; 830  : 
; 831  : 	basic_ifstream(const _Myt&) = delete;
; 832  : 	_Myt& operator=(const _Myt&) = delete;
; 833  : 
; 834  : 	void open(const wchar_t *_Filename,
; 835  : 		ios_base::openmode _Mode = ios_base::in,
; 836  : 		int _Prot = (int)ios_base::_Openprot)
; 837  : 		{	// open a wide-named C stream -- EXTENSION
; 838  : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
; 839  : 			_Myios::setstate(ios_base::failbit);
; 840  : 		else
; 841  : 			_Myios::clear();	// added with C++11
; 842  : 		}
; 843  : 
; 844  : 	void open(const wstring& _Str,
; 845  : 		ios_base::openmode _Mode = ios_base::in,
; 846  : 		int _Prot = (int)ios_base::_Openprot)
; 847  : 		{	// open a wide-named C stream -- EXTENSION
; 848  : 		open(_Str.c_str(), _Mode, _Prot);
; 849  : 		}
; 850  : 
; 851  :  #if _HAS_OLD_IOSTREAMS_MEMBERS
; 852  : 	void open(const wchar_t *_Filename, ios_base::open_mode _Mode)
; 853  : 		{	// open wide-named file (old style) -- EXTENSION
; 854  : 		open(_Filename, (ios_base::openmode)_Mode);
; 855  : 		}
; 856  :  #endif /* _HAS_OLD_IOSTREAMS_MEMBERS */
; 857  : 
; 858  :  #ifdef _NATIVE_WCHAR_T_DEFINED
; 859  : 	void open(const unsigned short *_Filename,
; 860  : 		ios_base::openmode _Mode = ios_base::in,
; 861  : 		int _Prot = (int)ios_base::_Openprot)
; 862  : 		{	// open a wide-named C stream -- EXTENSION
; 863  : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
; 864  : 			_Myios::setstate(ios_base::failbit);
; 865  : 		else
; 866  : 			_Myios::clear();	// added with C++11
; 867  : 		}
; 868  : 
; 869  :  #if _HAS_OLD_IOSTREAMS_MEMBERS
; 870  : 	void open(const unsigned short *_Filename,
; 871  : 		ios_base::open_mode _Mode)
; 872  : 		{	// open wide-named file (old style) -- EXTENSION
; 873  : 		open(_Filename, (ios_base::openmode)_Mode);
; 874  : 		}
; 875  :  #endif /* _HAS_OLD_IOSTREAMS_MEMBERS */
; 876  :  #endif /* _NATIVE_WCHAR_T_DEFINED */
; 877  : 
; 878  : 	virtual __CLR_OR_THIS_CALL ~basic_ifstream() _NOEXCEPT
; 879  : 		{	// destroy the object
; 880  : 		}
; 881  : 
; 882  : 	_Myfb *rdbuf() const
; 883  : 		{	// return pointer to file buffer
; 884  : 		return ((_Myfb *)&_Filebuffer);
; 885  : 		}
; 886  : 
; 887  : 	bool is_open() const
; 888  : 		{	// test if C stream has been opened
; 889  : 		return (_Filebuffer.is_open());
; 890  : 		}
; 891  : 
; 892  : 	void open(const char *_Filename,
; 893  : 		ios_base::openmode _Mode = ios_base::in,
; 894  : 		int _Prot = (int)ios_base::_Openprot)
; 895  : 		{	// open a C stream with specified mode
; 896  : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
; 897  : 			_Myios::setstate(ios_base::failbit);
; 898  : 		else
; 899  : 			_Myios::clear();	// added with C++11
; 900  : 		}
; 901  : 
; 902  : 	void open(const string& _Str,
; 903  : 		ios_base::openmode _Mode = ios_base::in,
; 904  : 		int _Prot = (int)ios_base::_Openprot)
; 905  : 		{	// open a C stream with specified mode
; 906  : 		open(_Str.c_str(), _Mode, _Prot);
; 907  : 		}
; 908  : 
; 909  :  #if _HAS_OLD_IOSTREAMS_MEMBERS
; 910  : 	void open(const char *_Filename, ios_base::open_mode _Mode)
; 911  : 		{	// open named file with specified mode (old style)
; 912  : 		open(_Filename, (ios_base::openmode)_Mode);
; 913  : 		}
; 914  :  #endif /* _HAS_OLD_IOSTREAMS_MEMBERS */
; 915  : 
; 916  : 	void close()
; 917  : 		{	// close the C stream
; 918  : 		if (_Filebuffer.close() == 0)
; 919  : 			_Myios::setstate(ios_base::failbit);
; 920  : 		}
; 921  : 
; 922  : private:
; 923  : 	_Myfb _Filebuffer;	// the file buffer
; 924  : 	};
; 925  : 
; 926  : 	// basic_ifstream TEMPLATE OPERATORS
; 927  : template<class _Elem,
; 928  : 	class _Traits> inline
; 929  : 	void swap(basic_ifstream<_Elem, _Traits>& _Left,
; 930  : 		basic_ifstream<_Elem, _Traits>& _Right)
; 931  : 	{	// swap _Left and _Right basic_ifstreams
; 932  : 	_Left.swap(_Right);
; 933  : 	}
; 934  : 
; 935  : 		// TEMPLATE CLASS basic_ofstream
; 936  : template<class _Elem,
; 937  : 	class _Traits>
; 938  : 	class basic_ofstream
; 939  : 		: public basic_ostream<_Elem, _Traits>
; 940  : 	{	// output stream associated with a C stream
; 941  : public:
; 942  : 	typedef basic_ofstream<_Elem, _Traits> _Myt;
; 943  : 	typedef basic_ostream<_Elem, _Traits> _Mybase;
; 944  : 	typedef basic_filebuf<_Elem, _Traits> _Myfb;
; 945  : 	typedef basic_ios<_Elem, _Traits> _Myios;
; 946  : 
; 947  : 	basic_ofstream()
; 948  : 		: _Mybase(&_Filebuffer)
; 949  : 		{	// construct unopened
; 950  : 		}
; 951  : 
; 952  : 	explicit basic_ofstream(const char *_Filename,
; 953  : 		ios_base::openmode _Mode = ios_base::out,
; 954  : 		int _Prot = (int)ios_base::_Openprot)
; 955  : 		: _Mybase(&_Filebuffer)
; 956  : 		{	// construct with named file and specified mode
; 957  : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)
; 958  : 			_Myios::setstate(ios_base::failbit);
; 959  : 		}
; 960  : 
; 961  : 	explicit basic_ofstream(const string& _Str,
; 962  : 		ios_base::openmode _Mode = ios_base::out,
; 963  : 		int _Prot = (int)ios_base::_Openprot)
; 964  : 		: _Mybase(&_Filebuffer)
; 965  : 		{	// construct with named file and specified mode
; 966  : 		if (_Filebuffer.open(_Str.c_str(), _Mode | ios_base::out, _Prot) == 0)
; 967  : 			_Myios::setstate(ios_base::failbit);
; 968  : 		}
; 969  : 
; 970  : 	explicit basic_ofstream(const wchar_t *_Filename,
; 971  : 		ios_base::openmode _Mode = ios_base::out,
; 972  : 		int _Prot = (int)ios_base::_Openprot)
; 973  : 		: _Mybase(&_Filebuffer)
; 974  : 		{	// construct with wide-named file -- EXTENSION
; 975  : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)
; 976  : 			_Myios::setstate(ios_base::failbit);
; 977  : 		}
; 978  : 
; 979  : 	explicit basic_ofstream(const wstring& _Str,
; 980  : 		ios_base::openmode _Mode = ios_base::out,
; 981  : 		int _Prot = (int)ios_base::_Openprot)
; 982  : 		: _Mybase(&_Filebuffer)
; 983  : 		{	// construct with wide-named file -- EXTENSION
; 984  : 		if (_Filebuffer.open(_Str.c_str(), _Mode | ios_base::out, _Prot) == 0)
; 985  : 			_Myios::setstate(ios_base::failbit);
; 986  : 		}
; 987  : 
; 988  :  #ifdef _NATIVE_WCHAR_T_DEFINED
; 989  : 	explicit basic_ofstream(const unsigned short *_Filename,
; 990  : 		ios_base::openmode _Mode = ios_base::out,
; 991  : 		int _Prot = (int)ios_base::_Openprot)
; 992  : 		: _Mybase(&_Filebuffer)
; 993  : 		{	// construct with wide-named file -- EXTENSION
; 994  : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)
; 995  : 			_Myios::setstate(ios_base::failbit);
; 996  : 		}
; 997  :  #endif /* _NATIVE_WCHAR_T_DEFINED */
; 998  : 
; 999  : 	explicit basic_ofstream(_Filet *_File)
; 1000 : 		: _Mybase(&_Filebuffer),
; 1001 : 			_Filebuffer(_File)
; 1002 : 		{	// construct with specified C stream
; 1003 : 		}
; 1004 : 
; 1005 : 	basic_ofstream(_Myt&& _Right)
; 1006 : 		: _Mybase(&_Filebuffer)
; 1007 : 		{	// construct by moving _Right
; 1008 : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 1009 : 		}
; 1010 : 
; 1011 : 	_Myt& operator=(_Myt&& _Right)
; 1012 : 		{	// move from _Right
; 1013 : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 1014 : 		return (*this);
; 1015 : 		}
; 1016 : 
; 1017 : 	void _Assign_rv(_Myt&& _Right)
; 1018 : 		{	// assign by moving _Right
; 1019 : 		if (this != &_Right)
; 1020 : 			{	// different, worth moving
; 1021 : 			_Filebuffer.close();
; 1022 : 			this->swap(_Right);
; 1023 : 			}
; 1024 : 		}
; 1025 : 
; 1026 : 	void swap(_Myt& _Right)
; 1027 : 		{	// swap with _Right
; 1028 : 		if (this != &_Right)
; 1029 : 			{	// different, swap base and buffer
; 1030 : 			_Mybase::swap(_Right);
; 1031 : 			_Filebuffer.swap(_Right._Filebuffer);
; 1032 : 			}
; 1033 : 		}
; 1034 : 
; 1035 : 	basic_ofstream(const _Myt&) = delete;
; 1036 : 	_Myt& operator=(const _Myt&) = delete;
; 1037 : 
; 1038 : 	void open(const wchar_t *_Filename,
; 1039 : 		ios_base::openmode _Mode = ios_base::out,
; 1040 : 		int _Prot = (int)ios_base::_Openprot)
; 1041 : 		{	// open a wide-named C stream -- EXTENSION
; 1042 : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)
; 1043 : 			_Myios::setstate(ios_base::failbit);
; 1044 : 		else
; 1045 : 			_Myios::clear();	// added with C++11
; 1046 : 		}
; 1047 : 
; 1048 : 	void open(const wstring& _Str,
; 1049 : 		ios_base::openmode _Mode = ios_base::out,
; 1050 : 		int _Prot = (int)ios_base::_Openprot)
; 1051 : 		{	// open a wide-named C stream -- EXTENSION
; 1052 : 		open(_Str.c_str(), _Mode, _Prot);
; 1053 : 		}
; 1054 : 
; 1055 :  #if _HAS_OLD_IOSTREAMS_MEMBERS
; 1056 : 	void open(const wchar_t *_Filename, ios_base::open_mode _Mode)
; 1057 : 		{	// open a wide-named C stream (old style) -- EXTENSION
; 1058 : 		open(_Filename, (ios_base::openmode)_Mode);
; 1059 : 		}
; 1060 :  #endif /* _HAS_OLD_IOSTREAMS_MEMBERS */
; 1061 : 
; 1062 :  #ifdef _NATIVE_WCHAR_T_DEFINED
; 1063 : 	void open(const unsigned short *_Filename,
; 1064 : 		ios_base::openmode _Mode = ios_base::out,
; 1065 : 		int _Prot = (int)ios_base::_Openprot)
; 1066 : 		{	// open a wide-named C stream -- EXTENSION
; 1067 : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)
; 1068 : 			_Myios::setstate(ios_base::failbit);
; 1069 : 		else
; 1070 : 			_Myios::clear();	// added with C++11
; 1071 : 		}
; 1072 : 
; 1073 :  #if _HAS_OLD_IOSTREAMS_MEMBERS
; 1074 : 	void open(const unsigned short *_Filename,
; 1075 : 		ios_base::open_mode _Mode)
; 1076 : 		{	// open a wide-named C stream (old style) -- EXTENSION
; 1077 : 		open(_Filename, (ios_base::openmode)_Mode);
; 1078 : 		}
; 1079 :  #endif /* _HAS_OLD_IOSTREAMS_MEMBERS */
; 1080 :  #endif /* _NATIVE_WCHAR_T_DEFINED */
; 1081 : 
; 1082 : 	virtual __CLR_OR_THIS_CALL ~basic_ofstream() _NOEXCEPT
; 1083 : 		{	// destroy the object
; 1084 : 		}
; 1085 : 
; 1086 : 	_Myfb *rdbuf() const
; 1087 : 		{	// return pointer to file buffer
; 1088 : 		return ((_Myfb *)&_Filebuffer);
; 1089 : 		}
; 1090 : 
; 1091 : 	bool is_open() const
; 1092 : 		{	// test if C stream has been opened
; 1093 : 		return (_Filebuffer.is_open());
; 1094 : 		}
; 1095 : 
; 1096 : 	void open(const char *_Filename,
; 1097 : 		ios_base::openmode _Mode = ios_base::out,
; 1098 : 		int _Prot = (int)ios_base::_Openprot)
; 1099 : 		{	// open a C stream with specified mode
; 1100 : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)
; 1101 : 			_Myios::setstate(ios_base::failbit);
; 1102 : 		else
; 1103 : 			_Myios::clear();	// added with C++11
; 1104 : 		}
; 1105 : 
; 1106 : 	void open(const string& _Str,
; 1107 : 		ios_base::openmode _Mode = ios_base::out,
; 1108 : 		int _Prot = (int)ios_base::_Openprot)
; 1109 : 		{	// open a C stream with specified mode
; 1110 : 		open(_Str.c_str(), _Mode, _Prot);
; 1111 : 		}
; 1112 : 
; 1113 :  #if _HAS_OLD_IOSTREAMS_MEMBERS
; 1114 : 	void open(const char *_Filename, ios_base::open_mode _Mode)
; 1115 : 		{	// open a C stream with specified mode (old style)
; 1116 : 		open(_Filename, (ios_base::openmode)_Mode);
; 1117 : 		}
; 1118 :  #endif /* _HAS_OLD_IOSTREAMS_MEMBERS */
; 1119 : 
; 1120 : 	void close()
; 1121 : 		{	// close the C stream
; 1122 : 		if (_Filebuffer.close() == 0)
; 1123 : 			_Myios::setstate(ios_base::failbit);
; 1124 : 		}
; 1125 : 
; 1126 : private:
; 1127 : 	_Myfb _Filebuffer;	// the file buffer
; 1128 : 	};
; 1129 : 
; 1130 : 	// basic_ofstream TEMPLATE OPERATORS
; 1131 : template<class _Elem,
; 1132 : 	class _Traits> inline
; 1133 : 	void swap(basic_ofstream<_Elem, _Traits>& _Left,
; 1134 : 		basic_ofstream<_Elem, _Traits>& _Right)
; 1135 : 	{	// swap _Left and _Right basic_ofstreams
; 1136 : 	_Left.swap(_Right);
; 1137 : 	}
; 1138 : 
; 1139 : 		// TEMPLATE CLASS basic_fstream
; 1140 : template<class _Elem,
; 1141 : 	class _Traits>
; 1142 : 	class basic_fstream
; 1143 : 		: public basic_iostream<_Elem, _Traits>
; 1144 : 	{	// input/output stream associated with a C stream
; 1145 : public:
; 1146 : 	typedef basic_fstream<_Elem, _Traits> _Myt;
; 1147 : 	typedef basic_iostream<_Elem, _Traits> _Mybase;
; 1148 : 	typedef basic_filebuf<_Elem, _Traits> _Myfb;
; 1149 : 	typedef basic_ios<_Elem, _Traits> _Myios;
; 1150 : 	typedef _Elem char_type;
; 1151 : 	typedef _Traits traits_type;
; 1152 : 	typedef typename _Traits::int_type int_type;
; 1153 : 	typedef typename _Traits::pos_type pos_type;
; 1154 : 	typedef typename _Traits::off_type off_type;
; 1155 : 
; 1156 : 	basic_fstream()
; 1157 : 		: _Mybase(&_Filebuffer)

  00052	48 8d 5f 18	 lea	 rbx, QWORD PTR [rdi+24]
  00056	45 33 c0	 xor	 r8d, r8d
  00059	48 8b d3	 mov	 rdx, rbx
  0005c	48 8b cf	 mov	 rcx, rdi
  0005f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QEAA@PEAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z
  00065	90		 npad	 1

; 1158 : 		{	// construct unopened

  00066	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  00069	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  0006d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@
  00074	48 89 04 39	 mov	 QWORD PTR [rcx+rdi], rax
  00078	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  0007b	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  0007f	8d 91 48 ff ff
	ff		 lea	 edx, DWORD PTR [rcx-184]
  00085	89 54 39 fc	 mov	 DWORD PTR [rcx+rdi-4], edx
  00089	48 89 5c 24 50	 mov	 QWORD PTR this$[rsp], rbx

; 145  : 		: _Mysb()

  0008e	48 8b cb	 mov	 rcx, rbx
  00091	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAA@XZ
  00097	90		 npad	 1

; 146  : 		{	// construct from pointer to C stream

  00098	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
  0009f	48 89 03	 mov	 QWORD PTR [rbx], rax

; 607  : 		_Closef = _Which == _Openfl;

  000a2	c6 43 7c 00	 mov	 BYTE PTR [rbx+124], 0

; 608  : 		_Wrotesome = false;

  000a6	c6 43 71 00	 mov	 BYTE PTR [rbx+113], 0

; 609  : 
; 610  : 		_Mysb::_Init();	// initialize stream buffer base object

  000aa	48 8b cb	 mov	 rcx, rbx
  000ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXXZ

; 611  : 
; 612  :  #ifndef _IORCNT
; 613  :   #define _IORCNT	_IOCNT	/* read and write counts are the same */
; 614  :   #define _IOWCNT _IOCNT
; 615  :  #endif /* _IORCNT */
; 616  : 
; 617  :   #pragma warning(push)
; 618  :   #pragma warning(disable: 6240)	/* prefast noise VSW 489858 */
; 619  : 		if (_File != 0 && sizeof (_Elem) == 1)
; 620  :   #pragma warning(pop)
; 621  : 
; 622  : 			{	// point inside C stream with [first, first + count) buffer
; 623  : 			_Elem **_Pb = 0;
; 624  : 			_Elem **_Pn = 0;
; 625  : 			int *_Nr = 0;
; 626  : 
; 627  : 			::_get_stream_buffer_pointers(
; 628  : 				_File,
; 629  : 				reinterpret_cast<char***>(&_Pb),
; 630  : 				reinterpret_cast<char***>(&_Pn),
; 631  : 				&_Nr);
; 632  : 			int *_Nw = _Nr;
; 633  : 
; 634  : 			_Mysb::_Init(_Pb, _Pn, _Nr, _Pb, _Pn, _Nw);
; 635  : 			}
; 636  : 
; 637  : 		_Myfile = _File;

  000b3	48 c7 83 80 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rbx+128], 0

; 638  : 		_State = _Stinit;

  000be	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit
  000c5	48 89 43 74	 mov	 QWORD PTR [rbx+116], rax

; 639  : 		_Pcvt = 0;	// pointer to codecvt facet

  000c9	48 c7 43 68 00
	00 00 00	 mov	 QWORD PTR [rbx+104], 0

; 1159 : 		}

  000d1	48 8b c7	 mov	 rax, rdi
  000d4	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  000d9	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000dd	5f		 pop	 rdi
  000de	c3		 ret	 0
??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ ENDP ; std::basic_fstream<char,std::char_traits<char> >::basic_fstream<char,std::char_traits<char> >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
$T2 = 72
$initVBases$ = 72
this$ = 80
?dtor$0@?0???0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA PROC ; `std::basic_fstream<char,std::char_traits<char> >::basic_fstream<char,std::char_traits<char> >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	8b 45 48	 mov	 eax, DWORD PTR $T2[rbp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	85 c0		 test	 eax, eax
  00011	74 15		 je	 SHORT $LN5@dtor$0
  00013	83 65 48 fe	 and	 DWORD PTR $T2[rbp], -2
  00017	48 8b 4d 40	 mov	 rcx, QWORD PTR this$[rbp]
  0001b	48 81 c1 b8 00
	00 00		 add	 rcx, 184		; 000000b8H
  00022	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
$LN5@dtor$0:
  00028	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002c	5d		 pop	 rbp
  0002d	c3		 ret	 0
?dtor$0@?0???0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA ENDP ; `std::basic_fstream<char,std::char_traits<char> >::basic_fstream<char,std::char_traits<char> >'::`1'::dtor$0
$T1 = 32
this$ = 64
$T2 = 72
$initVBases$ = 72
this$ = 80
?dtor$1@?0???0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA PROC ; `std::basic_fstream<char,std::char_traits<char> >::basic_fstream<char,std::char_traits<char> >'::`1'::dtor$1
  0002e	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00035	48 83 c1 20	 add	 rcx, 32			; 00000020H
  00039	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$1@?0???0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA ENDP ; `std::basic_fstream<char,std::char_traits<char> >::basic_fstream<char,std::char_traits<char> >'::`1'::dtor$1
$T1 = 32
this$ = 64
$T2 = 72
$initVBases$ = 72
this$ = 80
?dtor$3@?0???0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA PROC ; `std::basic_fstream<char,std::char_traits<char> >::basic_fstream<char,std::char_traits<char> >'::`1'::dtor$3
  00040	48 8b 8a 50 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00047	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$3@?0???0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA ENDP ; `std::basic_fstream<char,std::char_traits<char> >::basic_fstream<char,std::char_traits<char> >'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
$T2 = 72
$initVBases$ = 72
this$ = 80
?dtor$0@?0???0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA PROC ; `std::basic_fstream<char,std::char_traits<char> >::basic_fstream<char,std::char_traits<char> >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	8b 45 48	 mov	 eax, DWORD PTR $T2[rbp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	85 c0		 test	 eax, eax
  00011	74 15		 je	 SHORT $LN5@dtor$0
  00013	83 65 48 fe	 and	 DWORD PTR $T2[rbp], -2
  00017	48 8b 4d 40	 mov	 rcx, QWORD PTR this$[rbp]
  0001b	48 81 c1 b8 00
	00 00		 add	 rcx, 184		; 000000b8H
  00022	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
$LN5@dtor$0:
  00028	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002c	5d		 pop	 rbp
  0002d	c3		 ret	 0
?dtor$0@?0???0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA ENDP ; `std::basic_fstream<char,std::char_traits<char> >::basic_fstream<char,std::char_traits<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
$T2 = 72
$initVBases$ = 72
this$ = 80
?dtor$1@?0???0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA PROC ; `std::basic_fstream<char,std::char_traits<char> >::basic_fstream<char,std::char_traits<char> >'::`1'::dtor$1
  0002e	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00035	48 83 c1 20	 add	 rcx, 32			; 00000020H
  00039	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$1@?0???0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA ENDP ; `std::basic_fstream<char,std::char_traits<char> >::basic_fstream<char,std::char_traits<char> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
$T2 = 72
$initVBases$ = 72
this$ = 80
?dtor$3@?0???0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA PROC ; `std::basic_fstream<char,std::char_traits<char> >::basic_fstream<char,std::char_traits<char> >'::`1'::dtor$3
  00040	48 8b 8a 50 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00047	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$3@?0???0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA ENDP ; `std::basic_fstream<char,std::char_traits<char> >::basic_fstream<char,std::char_traits<char> >'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\users\coschm\desktop\fall-2016\security\des\des\des\main.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
; File c:\users\coschm\desktop\fall-2016\security\des\des\des\main.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
; File c:\users\coschm\desktop\fall-2016\security\des\des\des\main.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
; File c:\users\coschm\desktop\fall-2016\security\des\des\des\main.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\users\coschm\desktop\fall-2016\security\des\des\des\main.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\time.h
; File c:\users\coschm\desktop\fall-2016\security\des\des\des\main.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
; File c:\users\coschm\desktop\fall-2016\security\des\des\des\main.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
; File c:\users\coschm\desktop\fall-2016\security\des\des\des\main.cpp
_TEXT	SEGMENT
?keys@@3PA_KA$17 = 32
this$ = 32
in$1 = 32
in$2 = 32
?keys@@3PA_KA$16 = 48
a$3 = 48
fSizeOut$4 = 48
?keys@@3PA_KA$15 = 64
a$5 = 64
a$6 = 64
?keys@@3PA_KA$10 = 80
?keys@@3PA_KA$11 = 88
?keys@@3PA_KA$12 = 96
?keys@@3PA_KA$13 = 104
?keys@@3PA_KA$14 = 112
inFile$ = 128
$T7 = 416
outFile$ = 432
$T8 = 720
$T9 = 720
argc$ = 832
argv$ = 840
?keys@@3PA_KA$9 = 848
$T10 = 848
start$1$ = 856
main	PROC

; 579  : {

$LN319:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 50 10	 mov	 QWORD PTR [rax+16], rdx
  00007	55		 push	 rbp
  00008	56		 push	 rsi
  00009	57		 push	 rdi
  0000a	41 54		 push	 r12
  0000c	41 55		 push	 r13
  0000e	41 56		 push	 r14
  00010	41 57		 push	 r15
  00012	48 8d a8 c8 fd
	ff ff		 lea	 rbp, QWORD PTR [rax-568]
  00019	48 81 ec 00 03
	00 00		 sub	 rsp, 768		; 00000300H
  00020	48 c7 85 a0 00
	00 00 fe ff ff
	ff		 mov	 QWORD PTR $T7[rbp-256], -2
  0002b	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  0002f	0f 29 70 b8	 movaps	 XMMWORD PTR [rax-72], xmm6
  00033	48 8b fa	 mov	 rdi, rdx
  00036	8b d9		 mov	 ebx, ecx
  00038	33 f6		 xor	 esi, esi
  0003a	89 b5 50 02 00
	00		 mov	 DWORD PTR $T10[rbp-256], esi

; 580  : 	//start timer here
; 581  : 	clock_t start;
; 582  : 	double duration;
; 583  : 	start = clock();

  00040	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clock
  00046	89 85 58 02 00
	00		 mov	 DWORD PTR start$1$[rbp-256], eax

; 584  : 
; 585  : 	//checks all the arguments (except the in and out files) and exits if there are any issues
; 586  : 	init(argc, argv);

  0004c	48 8b d7	 mov	 rdx, rdi
  0004f	8b cb		 mov	 ecx, ebx
  00051	e8 00 00 00 00	 call	 ?init@@YAXHQEAPEAD@Z	; init

; 587  : 
; 588  : 	//opening the input file and initializing or opening the output file
; 589  : 	char *inFileName = argv[4];

  00056	48 8b 5f 20	 mov	 rbx, QWORD PTR [rdi+32]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream

; 1158 : 		{	// construct unopened

  0005a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_8?$basic_fstream@DU?$char_traits@D@std@@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@
  00061	48 89 45 80	 mov	 QWORD PTR inFile$[rbp-256], rax
  00065	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_8?$basic_fstream@DU?$char_traits@D@std@@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@
  0006c	48 89 45 90	 mov	 QWORD PTR inFile$[rbp-240], rax
  00070	48 8d 4d 38	 lea	 rcx, QWORD PTR inFile$[rbp-72]
  00074	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IEAA@XZ
  0007a	90		 npad	 1
  0007b	c7 85 50 02 00
	00 01 00 00 00	 mov	 DWORD PTR $T10[rbp-256], 1

; 640  : 		}
; 641  : 
; 642  : 	bool _Endwrite()
; 643  : 		{	// put shift to initial conversion state, as needed
; 644  : 		if (_Pcvt == 0 || !_Wrotesome)
; 645  : 			return (true);
; 646  : 		else
; 647  : 			{	// may have to put
; 648  : 			const int _STRING_INC = 8;
; 649  : 			char *_Dest;
; 650  : 			if (_Traits::eq_int_type(_Traits::eof(), overflow()))
; 651  : 				return (false);
; 652  : 
; 653  : 			string _Str(_STRING_INC, '\0');
; 654  : 			for (; ; )
; 655  : 				switch (_Pcvt->unshift(_State,
; 656  : 					&*_Str.begin(), &*_Str.begin() + _Str.size(), _Dest))
; 657  : 				{	// test result of homing conversion
; 658  : 				case codecvt_base::ok:
; 659  : 					_Wrotesome = false;	// homed successfully
; 660  : 
; 661  : 				case codecvt_base::partial:	// fall through
; 662  : 					{	// put any generated bytes
; 663  : 					size_t _Count = _Dest - &*_Str.begin();
; 664  : 					if (0 < _Count && _Count !=
; 665  : 						fwrite(&*_Str.begin(), 1, _Count, _Myfile))
; 666  : 						return (false);	// write failed
; 667  : 					if (!_Wrotesome)
; 668  : 						return (true);
; 669  : 					if (_Count == 0)
; 670  : 						_Str.append(_STRING_INC, '\0');	// try with more space
; 671  : 					break;
; 672  : 					}
; 673  : 
; 674  : 				case codecvt_base::noconv:
; 675  : 					return (true);	// nothing to do
; 676  : 
; 677  : 				default:
; 678  : 					return (false);	// conversion failed
; 679  : 				}
; 680  : 			}
; 681  : 		}
; 682  : 
; 683  : 	void _Initcvt(const _Cvt *_Newpcvt)
; 684  : 		{	// initialize codecvt pointer
; 685  : 		if (_Newpcvt->always_noconv())
; 686  : 			_Pcvt = 0;	// nothing to do
; 687  : 		else
; 688  : 			{	// set up for nontrivial codecvt facet
; 689  : 			_Pcvt = _Newpcvt;
; 690  : 			_Mysb::_Init();	// reset any buffering
; 691  : 			}
; 692  : 		}
; 693  : 
; 694  : private:
; 695  : 	const _Cvt *_Pcvt;	// pointer to codecvt facet (may be null)
; 696  : 	_Elem _Mychar;	// putback character, when _Ungetc fails
; 697  : 	bool _Wrotesome;	// true if homing sequence may be needed
; 698  : 	typename _Traits::state_type _State;	// current conversion state
; 699  : 	bool _Closef;	// true if C stream must be closed
; 700  : 	_Filet *_Myfile;	// pointer to C stream
; 701  : 
; 702  : 	void _Reset_back()
; 703  : 		{	// restore buffer after putback
; 704  : 		if (_Mysb::eback() == &_Mychar)
; 705  : 			_Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);
; 706  : 		}
; 707  : 
; 708  : 	void _Set_back()
; 709  : 		{	// set up putback area
; 710  : 		if (_Mysb::eback() != &_Mychar)
; 711  : 			{	// save current get buffer
; 712  : 			_Set_eback = _Mysb::eback();
; 713  : 			_Set_egptr = _Mysb::egptr();
; 714  : 			}
; 715  : 		_Mysb::setg(&_Mychar, &_Mychar, &_Mychar + 1);
; 716  : 		}
; 717  : 
; 718  : 	_Elem *_Set_eback;	// saves eback() during one-element putback
; 719  : 	_Elem *_Set_egptr;	// saves egptr()
; 720  : 	};
; 721  : 
; 722  : 	// basic_filebuf TEMPLATE OPERATORS
; 723  : template<class _Elem,
; 724  : 	class _Traits> inline
; 725  : 	void swap(basic_filebuf<_Elem, _Traits>& _Left,
; 726  : 		basic_filebuf<_Elem, _Traits>& _Right)
; 727  : 	{	// swap _Left and _Right basic_filebufs
; 728  : 	_Left.swap(_Right);
; 729  : 	}
; 730  : 
; 731  : 		// TEMPLATE CLASS basic_ifstream
; 732  : template<class _Elem,
; 733  : 	class _Traits>
; 734  : 	class basic_ifstream
; 735  : 		: public basic_istream<_Elem, _Traits>
; 736  : 	{	// input stream associated with a C stream
; 737  : public:
; 738  : 	typedef basic_ifstream<_Elem, _Traits> _Myt;
; 739  : 	typedef basic_istream<_Elem, _Traits> _Mybase;
; 740  : 	typedef basic_filebuf<_Elem, _Traits> _Myfb;
; 741  : 	typedef basic_ios<_Elem, _Traits> _Myios;
; 742  : 
; 743  : 	basic_ifstream()
; 744  : 		: _Mybase(&_Filebuffer)
; 745  : 		{	// construct unopened
; 746  : 		}
; 747  : 
; 748  : 	explicit basic_ifstream(const char *_Filename,
; 749  : 		ios_base::openmode _Mode = ios_base::in,
; 750  : 		int _Prot = (int)ios_base::_Openprot)
; 751  : 		: _Mybase(&_Filebuffer)
; 752  : 		{	// construct with named file and specified mode
; 753  : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
; 754  : 			_Myios::setstate(ios_base::failbit);
; 755  : 		}
; 756  : 
; 757  : 	explicit basic_ifstream(const string& _Str,
; 758  : 		ios_base::openmode _Mode = ios_base::in,
; 759  : 		int _Prot = (int)ios_base::_Openprot)
; 760  : 		: _Mybase(&_Filebuffer)
; 761  : 		{	// construct with named file and specified mode
; 762  : 		if (_Filebuffer.open(_Str.c_str(), _Mode | ios_base::in, _Prot) == 0)
; 763  : 			_Myios::setstate(ios_base::failbit);
; 764  : 		}
; 765  : 
; 766  : 	explicit basic_ifstream(const wchar_t *_Filename,
; 767  : 		ios_base::openmode _Mode = ios_base::in,
; 768  : 		int _Prot = (int)ios_base::_Openprot)
; 769  : 		: _Mybase(&_Filebuffer)
; 770  : 		{	// construct with wide-named file -- EXTENSION
; 771  : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
; 772  : 			_Myios::setstate(ios_base::failbit);
; 773  : 		}
; 774  : 
; 775  : 	explicit basic_ifstream(const wstring& _Str,
; 776  : 		ios_base::openmode _Mode = ios_base::in,
; 777  : 		int _Prot = (int)ios_base::_Openprot)
; 778  : 		: _Mybase(&_Filebuffer)
; 779  : 		{	// construct with wide-named file -- EXTENSION
; 780  : 		if (_Filebuffer.open(_Str.c_str(), _Mode | ios_base::in, _Prot) == 0)
; 781  : 			_Myios::setstate(ios_base::failbit);
; 782  : 		}
; 783  : 
; 784  :  #ifdef _NATIVE_WCHAR_T_DEFINED
; 785  : 	explicit basic_ifstream(const unsigned short *_Filename,
; 786  : 		ios_base::openmode _Mode = ios_base::in,
; 787  : 		int _Prot = (int)ios_base::_Openprot)
; 788  : 		: _Mybase(&_Filebuffer)
; 789  : 		{	// construct with wide-named file -- EXTENSION
; 790  : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
; 791  : 			_Myios::setstate(ios_base::failbit);
; 792  : 		}
; 793  :  #endif /* _NATIVE_WCHAR_T_DEFINED */
; 794  : 
; 795  : 	explicit basic_ifstream(_Filet *_File)
; 796  : 		: _Mybase(&_Filebuffer),
; 797  : 			_Filebuffer(_File)
; 798  : 		{	// construct with specified C stream
; 799  : 		}
; 800  : 
; 801  : 	basic_ifstream(_Myt&& _Right)
; 802  : 		: _Mybase(&_Filebuffer)
; 803  : 		{	// construct by moving _Right
; 804  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 805  : 		}
; 806  : 
; 807  : 	_Myt& operator=(_Myt&& _Right)
; 808  : 		{	// move from _Right
; 809  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 810  : 		return (*this);
; 811  : 		}
; 812  : 
; 813  : 	void _Assign_rv(_Myt&& _Right)
; 814  : 		{	// assign by moving _Right
; 815  : 		if (this != &_Right)
; 816  : 			{	// different, worth moving
; 817  : 			_Filebuffer.close();
; 818  : 			this->swap(_Right);
; 819  : 			}
; 820  : 		}
; 821  : 
; 822  : 	void swap(_Myt& _Right)
; 823  : 		{	// swap with _Right
; 824  : 		if (this != &_Right)
; 825  : 			{	// different, swap base and buffer
; 826  : 			_Mybase::swap(_Right);
; 827  : 			_Filebuffer.swap(_Right._Filebuffer);
; 828  : 			}
; 829  : 		}
; 830  : 
; 831  : 	basic_ifstream(const _Myt&) = delete;
; 832  : 	_Myt& operator=(const _Myt&) = delete;
; 833  : 
; 834  : 	void open(const wchar_t *_Filename,
; 835  : 		ios_base::openmode _Mode = ios_base::in,
; 836  : 		int _Prot = (int)ios_base::_Openprot)
; 837  : 		{	// open a wide-named C stream -- EXTENSION
; 838  : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
; 839  : 			_Myios::setstate(ios_base::failbit);
; 840  : 		else
; 841  : 			_Myios::clear();	// added with C++11
; 842  : 		}
; 843  : 
; 844  : 	void open(const wstring& _Str,
; 845  : 		ios_base::openmode _Mode = ios_base::in,
; 846  : 		int _Prot = (int)ios_base::_Openprot)
; 847  : 		{	// open a wide-named C stream -- EXTENSION
; 848  : 		open(_Str.c_str(), _Mode, _Prot);
; 849  : 		}
; 850  : 
; 851  :  #if _HAS_OLD_IOSTREAMS_MEMBERS
; 852  : 	void open(const wchar_t *_Filename, ios_base::open_mode _Mode)
; 853  : 		{	// open wide-named file (old style) -- EXTENSION
; 854  : 		open(_Filename, (ios_base::openmode)_Mode);
; 855  : 		}
; 856  :  #endif /* _HAS_OLD_IOSTREAMS_MEMBERS */
; 857  : 
; 858  :  #ifdef _NATIVE_WCHAR_T_DEFINED
; 859  : 	void open(const unsigned short *_Filename,
; 860  : 		ios_base::openmode _Mode = ios_base::in,
; 861  : 		int _Prot = (int)ios_base::_Openprot)
; 862  : 		{	// open a wide-named C stream -- EXTENSION
; 863  : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
; 864  : 			_Myios::setstate(ios_base::failbit);
; 865  : 		else
; 866  : 			_Myios::clear();	// added with C++11
; 867  : 		}
; 868  : 
; 869  :  #if _HAS_OLD_IOSTREAMS_MEMBERS
; 870  : 	void open(const unsigned short *_Filename,
; 871  : 		ios_base::open_mode _Mode)
; 872  : 		{	// open wide-named file (old style) -- EXTENSION
; 873  : 		open(_Filename, (ios_base::openmode)_Mode);
; 874  : 		}
; 875  :  #endif /* _HAS_OLD_IOSTREAMS_MEMBERS */
; 876  :  #endif /* _NATIVE_WCHAR_T_DEFINED */
; 877  : 
; 878  : 	virtual __CLR_OR_THIS_CALL ~basic_ifstream() _NOEXCEPT
; 879  : 		{	// destroy the object
; 880  : 		}
; 881  : 
; 882  : 	_Myfb *rdbuf() const
; 883  : 		{	// return pointer to file buffer
; 884  : 		return ((_Myfb *)&_Filebuffer);
; 885  : 		}
; 886  : 
; 887  : 	bool is_open() const
; 888  : 		{	// test if C stream has been opened
; 889  : 		return (_Filebuffer.is_open());
; 890  : 		}
; 891  : 
; 892  : 	void open(const char *_Filename,
; 893  : 		ios_base::openmode _Mode = ios_base::in,
; 894  : 		int _Prot = (int)ios_base::_Openprot)
; 895  : 		{	// open a C stream with specified mode
; 896  : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
; 897  : 			_Myios::setstate(ios_base::failbit);
; 898  : 		else
; 899  : 			_Myios::clear();	// added with C++11
; 900  : 		}
; 901  : 
; 902  : 	void open(const string& _Str,
; 903  : 		ios_base::openmode _Mode = ios_base::in,
; 904  : 		int _Prot = (int)ios_base::_Openprot)
; 905  : 		{	// open a C stream with specified mode
; 906  : 		open(_Str.c_str(), _Mode, _Prot);
; 907  : 		}
; 908  : 
; 909  :  #if _HAS_OLD_IOSTREAMS_MEMBERS
; 910  : 	void open(const char *_Filename, ios_base::open_mode _Mode)
; 911  : 		{	// open named file with specified mode (old style)
; 912  : 		open(_Filename, (ios_base::openmode)_Mode);
; 913  : 		}
; 914  :  #endif /* _HAS_OLD_IOSTREAMS_MEMBERS */
; 915  : 
; 916  : 	void close()
; 917  : 		{	// close the C stream
; 918  : 		if (_Filebuffer.close() == 0)
; 919  : 			_Myios::setstate(ios_base::failbit);
; 920  : 		}
; 921  : 
; 922  : private:
; 923  : 	_Myfb _Filebuffer;	// the file buffer
; 924  : 	};
; 925  : 
; 926  : 	// basic_ifstream TEMPLATE OPERATORS
; 927  : template<class _Elem,
; 928  : 	class _Traits> inline
; 929  : 	void swap(basic_ifstream<_Elem, _Traits>& _Left,
; 930  : 		basic_ifstream<_Elem, _Traits>& _Right)
; 931  : 	{	// swap _Left and _Right basic_ifstreams
; 932  : 	_Left.swap(_Right);
; 933  : 	}
; 934  : 
; 935  : 		// TEMPLATE CLASS basic_ofstream
; 936  : template<class _Elem,
; 937  : 	class _Traits>
; 938  : 	class basic_ofstream
; 939  : 		: public basic_ostream<_Elem, _Traits>
; 940  : 	{	// output stream associated with a C stream
; 941  : public:
; 942  : 	typedef basic_ofstream<_Elem, _Traits> _Myt;
; 943  : 	typedef basic_ostream<_Elem, _Traits> _Mybase;
; 944  : 	typedef basic_filebuf<_Elem, _Traits> _Myfb;
; 945  : 	typedef basic_ios<_Elem, _Traits> _Myios;
; 946  : 
; 947  : 	basic_ofstream()
; 948  : 		: _Mybase(&_Filebuffer)
; 949  : 		{	// construct unopened
; 950  : 		}
; 951  : 
; 952  : 	explicit basic_ofstream(const char *_Filename,
; 953  : 		ios_base::openmode _Mode = ios_base::out,
; 954  : 		int _Prot = (int)ios_base::_Openprot)
; 955  : 		: _Mybase(&_Filebuffer)
; 956  : 		{	// construct with named file and specified mode
; 957  : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)
; 958  : 			_Myios::setstate(ios_base::failbit);
; 959  : 		}
; 960  : 
; 961  : 	explicit basic_ofstream(const string& _Str,
; 962  : 		ios_base::openmode _Mode = ios_base::out,
; 963  : 		int _Prot = (int)ios_base::_Openprot)
; 964  : 		: _Mybase(&_Filebuffer)
; 965  : 		{	// construct with named file and specified mode
; 966  : 		if (_Filebuffer.open(_Str.c_str(), _Mode | ios_base::out, _Prot) == 0)
; 967  : 			_Myios::setstate(ios_base::failbit);
; 968  : 		}
; 969  : 
; 970  : 	explicit basic_ofstream(const wchar_t *_Filename,
; 971  : 		ios_base::openmode _Mode = ios_base::out,
; 972  : 		int _Prot = (int)ios_base::_Openprot)
; 973  : 		: _Mybase(&_Filebuffer)
; 974  : 		{	// construct with wide-named file -- EXTENSION
; 975  : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)
; 976  : 			_Myios::setstate(ios_base::failbit);
; 977  : 		}
; 978  : 
; 979  : 	explicit basic_ofstream(const wstring& _Str,
; 980  : 		ios_base::openmode _Mode = ios_base::out,
; 981  : 		int _Prot = (int)ios_base::_Openprot)
; 982  : 		: _Mybase(&_Filebuffer)
; 983  : 		{	// construct with wide-named file -- EXTENSION
; 984  : 		if (_Filebuffer.open(_Str.c_str(), _Mode | ios_base::out, _Prot) == 0)
; 985  : 			_Myios::setstate(ios_base::failbit);
; 986  : 		}
; 987  : 
; 988  :  #ifdef _NATIVE_WCHAR_T_DEFINED
; 989  : 	explicit basic_ofstream(const unsigned short *_Filename,
; 990  : 		ios_base::openmode _Mode = ios_base::out,
; 991  : 		int _Prot = (int)ios_base::_Openprot)
; 992  : 		: _Mybase(&_Filebuffer)
; 993  : 		{	// construct with wide-named file -- EXTENSION
; 994  : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)
; 995  : 			_Myios::setstate(ios_base::failbit);
; 996  : 		}
; 997  :  #endif /* _NATIVE_WCHAR_T_DEFINED */
; 998  : 
; 999  : 	explicit basic_ofstream(_Filet *_File)
; 1000 : 		: _Mybase(&_Filebuffer),
; 1001 : 			_Filebuffer(_File)
; 1002 : 		{	// construct with specified C stream
; 1003 : 		}
; 1004 : 
; 1005 : 	basic_ofstream(_Myt&& _Right)
; 1006 : 		: _Mybase(&_Filebuffer)
; 1007 : 		{	// construct by moving _Right
; 1008 : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 1009 : 		}
; 1010 : 
; 1011 : 	_Myt& operator=(_Myt&& _Right)
; 1012 : 		{	// move from _Right
; 1013 : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 1014 : 		return (*this);
; 1015 : 		}
; 1016 : 
; 1017 : 	void _Assign_rv(_Myt&& _Right)
; 1018 : 		{	// assign by moving _Right
; 1019 : 		if (this != &_Right)
; 1020 : 			{	// different, worth moving
; 1021 : 			_Filebuffer.close();
; 1022 : 			this->swap(_Right);
; 1023 : 			}
; 1024 : 		}
; 1025 : 
; 1026 : 	void swap(_Myt& _Right)
; 1027 : 		{	// swap with _Right
; 1028 : 		if (this != &_Right)
; 1029 : 			{	// different, swap base and buffer
; 1030 : 			_Mybase::swap(_Right);
; 1031 : 			_Filebuffer.swap(_Right._Filebuffer);
; 1032 : 			}
; 1033 : 		}
; 1034 : 
; 1035 : 	basic_ofstream(const _Myt&) = delete;
; 1036 : 	_Myt& operator=(const _Myt&) = delete;
; 1037 : 
; 1038 : 	void open(const wchar_t *_Filename,
; 1039 : 		ios_base::openmode _Mode = ios_base::out,
; 1040 : 		int _Prot = (int)ios_base::_Openprot)
; 1041 : 		{	// open a wide-named C stream -- EXTENSION
; 1042 : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)
; 1043 : 			_Myios::setstate(ios_base::failbit);
; 1044 : 		else
; 1045 : 			_Myios::clear();	// added with C++11
; 1046 : 		}
; 1047 : 
; 1048 : 	void open(const wstring& _Str,
; 1049 : 		ios_base::openmode _Mode = ios_base::out,
; 1050 : 		int _Prot = (int)ios_base::_Openprot)
; 1051 : 		{	// open a wide-named C stream -- EXTENSION
; 1052 : 		open(_Str.c_str(), _Mode, _Prot);
; 1053 : 		}
; 1054 : 
; 1055 :  #if _HAS_OLD_IOSTREAMS_MEMBERS
; 1056 : 	void open(const wchar_t *_Filename, ios_base::open_mode _Mode)
; 1057 : 		{	// open a wide-named C stream (old style) -- EXTENSION
; 1058 : 		open(_Filename, (ios_base::openmode)_Mode);
; 1059 : 		}
; 1060 :  #endif /* _HAS_OLD_IOSTREAMS_MEMBERS */
; 1061 : 
; 1062 :  #ifdef _NATIVE_WCHAR_T_DEFINED
; 1063 : 	void open(const unsigned short *_Filename,
; 1064 : 		ios_base::openmode _Mode = ios_base::out,
; 1065 : 		int _Prot = (int)ios_base::_Openprot)
; 1066 : 		{	// open a wide-named C stream -- EXTENSION
; 1067 : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)
; 1068 : 			_Myios::setstate(ios_base::failbit);
; 1069 : 		else
; 1070 : 			_Myios::clear();	// added with C++11
; 1071 : 		}
; 1072 : 
; 1073 :  #if _HAS_OLD_IOSTREAMS_MEMBERS
; 1074 : 	void open(const unsigned short *_Filename,
; 1075 : 		ios_base::open_mode _Mode)
; 1076 : 		{	// open a wide-named C stream (old style) -- EXTENSION
; 1077 : 		open(_Filename, (ios_base::openmode)_Mode);
; 1078 : 		}
; 1079 :  #endif /* _HAS_OLD_IOSTREAMS_MEMBERS */
; 1080 :  #endif /* _NATIVE_WCHAR_T_DEFINED */
; 1081 : 
; 1082 : 	virtual __CLR_OR_THIS_CALL ~basic_ofstream() _NOEXCEPT
; 1083 : 		{	// destroy the object
; 1084 : 		}
; 1085 : 
; 1086 : 	_Myfb *rdbuf() const
; 1087 : 		{	// return pointer to file buffer
; 1088 : 		return ((_Myfb *)&_Filebuffer);
; 1089 : 		}
; 1090 : 
; 1091 : 	bool is_open() const
; 1092 : 		{	// test if C stream has been opened
; 1093 : 		return (_Filebuffer.is_open());
; 1094 : 		}
; 1095 : 
; 1096 : 	void open(const char *_Filename,
; 1097 : 		ios_base::openmode _Mode = ios_base::out,
; 1098 : 		int _Prot = (int)ios_base::_Openprot)
; 1099 : 		{	// open a C stream with specified mode
; 1100 : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)
; 1101 : 			_Myios::setstate(ios_base::failbit);
; 1102 : 		else
; 1103 : 			_Myios::clear();	// added with C++11
; 1104 : 		}
; 1105 : 
; 1106 : 	void open(const string& _Str,
; 1107 : 		ios_base::openmode _Mode = ios_base::out,
; 1108 : 		int _Prot = (int)ios_base::_Openprot)
; 1109 : 		{	// open a C stream with specified mode
; 1110 : 		open(_Str.c_str(), _Mode, _Prot);
; 1111 : 		}
; 1112 : 
; 1113 :  #if _HAS_OLD_IOSTREAMS_MEMBERS
; 1114 : 	void open(const char *_Filename, ios_base::open_mode _Mode)
; 1115 : 		{	// open a C stream with specified mode (old style)
; 1116 : 		open(_Filename, (ios_base::openmode)_Mode);
; 1117 : 		}
; 1118 :  #endif /* _HAS_OLD_IOSTREAMS_MEMBERS */
; 1119 : 
; 1120 : 	void close()
; 1121 : 		{	// close the C stream
; 1122 : 		if (_Filebuffer.close() == 0)
; 1123 : 			_Myios::setstate(ios_base::failbit);
; 1124 : 		}
; 1125 : 
; 1126 : private:
; 1127 : 	_Myfb _Filebuffer;	// the file buffer
; 1128 : 	};
; 1129 : 
; 1130 : 	// basic_ofstream TEMPLATE OPERATORS
; 1131 : template<class _Elem,
; 1132 : 	class _Traits> inline
; 1133 : 	void swap(basic_ofstream<_Elem, _Traits>& _Left,
; 1134 : 		basic_ofstream<_Elem, _Traits>& _Right)
; 1135 : 	{	// swap _Left and _Right basic_ofstreams
; 1136 : 	_Left.swap(_Right);
; 1137 : 	}
; 1138 : 
; 1139 : 		// TEMPLATE CLASS basic_fstream
; 1140 : template<class _Elem,
; 1141 : 	class _Traits>
; 1142 : 	class basic_fstream
; 1143 : 		: public basic_iostream<_Elem, _Traits>
; 1144 : 	{	// input/output stream associated with a C stream
; 1145 : public:
; 1146 : 	typedef basic_fstream<_Elem, _Traits> _Myt;
; 1147 : 	typedef basic_iostream<_Elem, _Traits> _Mybase;
; 1148 : 	typedef basic_filebuf<_Elem, _Traits> _Myfb;
; 1149 : 	typedef basic_ios<_Elem, _Traits> _Myios;
; 1150 : 	typedef _Elem char_type;
; 1151 : 	typedef _Traits traits_type;
; 1152 : 	typedef typename _Traits::int_type int_type;
; 1153 : 	typedef typename _Traits::pos_type pos_type;
; 1154 : 	typedef typename _Traits::off_type off_type;
; 1155 : 
; 1156 : 	basic_fstream()
; 1157 : 		: _Mybase(&_Filebuffer)

  00085	45 33 c0	 xor	 r8d, r8d
  00088	48 8d 55 98	 lea	 rdx, QWORD PTR inFile$[rbp-232]
  0008c	48 8d 4d 80	 lea	 rcx, QWORD PTR inFile$[rbp-256]
  00090	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QEAA@PEAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z
  00096	90		 npad	 1

; 1158 : 		{	// construct unopened

  00097	48 8b 45 80	 mov	 rax, QWORD PTR inFile$[rbp-256]
  0009b	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  0009f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@
  000a6	48 89 44 0d 80	 mov	 QWORD PTR inFile$[rbp+rcx-256], rax
  000ab	48 8b 45 80	 mov	 rax, QWORD PTR inFile$[rbp-256]
  000af	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  000b3	8d 91 48 ff ff
	ff		 lea	 edx, DWORD PTR [rcx-184]
  000b9	89 54 0c 7c	 mov	 DWORD PTR inFile$[rsp+rcx-4], edx
  000bd	48 8d 45 98	 lea	 rax, QWORD PTR inFile$[rbp-232]
  000c1	48 89 44 24 20	 mov	 QWORD PTR this$[rsp], rax

; 145  : 		: _Mysb()

  000c6	48 8d 4d 98	 lea	 rcx, QWORD PTR inFile$[rbp-232]
  000ca	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAA@XZ
  000d0	90		 npad	 1

; 146  : 		{	// construct from pointer to C stream

  000d1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
  000d8	48 89 45 98	 mov	 QWORD PTR inFile$[rbp-232], rax

; 607  : 		_Closef = _Which == _Openfl;

  000dc	40 88 75 14	 mov	 BYTE PTR inFile$[rbp-108], sil

; 608  : 		_Wrotesome = false;

  000e0	40 88 75 09	 mov	 BYTE PTR inFile$[rbp-119], sil

; 609  : 
; 610  : 		_Mysb::_Init();	// initialize stream buffer base object

  000e4	48 8d 4d 98	 lea	 rcx, QWORD PTR inFile$[rbp-232]
  000e8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXXZ

; 611  : 
; 612  :  #ifndef _IORCNT
; 613  :   #define _IORCNT	_IOCNT	/* read and write counts are the same */
; 614  :   #define _IOWCNT _IOCNT
; 615  :  #endif /* _IORCNT */
; 616  : 
; 617  :   #pragma warning(push)
; 618  :   #pragma warning(disable: 6240)	/* prefast noise VSW 489858 */
; 619  : 		if (_File != 0 && sizeof (_Elem) == 1)
; 620  :   #pragma warning(pop)
; 621  : 
; 622  : 			{	// point inside C stream with [first, first + count) buffer
; 623  : 			_Elem **_Pb = 0;
; 624  : 			_Elem **_Pn = 0;
; 625  : 			int *_Nr = 0;
; 626  : 
; 627  : 			::_get_stream_buffer_pointers(
; 628  : 				_File,
; 629  : 				reinterpret_cast<char***>(&_Pb),
; 630  : 				reinterpret_cast<char***>(&_Pn),
; 631  : 				&_Nr);
; 632  : 			int *_Nw = _Nr;
; 633  : 
; 634  : 			_Mysb::_Init(_Pb, _Pn, _Nr, _Pb, _Pn, _Nw);
; 635  : 			}
; 636  : 
; 637  : 		_Myfile = _File;

  000ee	48 89 75 18	 mov	 QWORD PTR inFile$[rbp-104], rsi

; 638  : 		_State = _Stinit;

  000f2	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit
  000f9	48 89 45 0c	 mov	 QWORD PTR inFile$[rbp-116], rax

; 639  : 		_Pcvt = 0;	// pointer to codecvt facet

  000fd	48 89 75 00	 mov	 QWORD PTR inFile$[rbp-128], rsi

; 1309 : 		if (_Filebuffer.open(_Filename, _Mode, _Prot) == 0)

  00101	44 8d 4e 40	 lea	 r9d, QWORD PTR [rsi+64]
  00105	44 8d 46 21	 lea	 r8d, QWORD PTR [rsi+33]
  00109	48 8b d3	 mov	 rdx, rbx
  0010c	48 8d 4d 98	 lea	 rcx, QWORD PTR inFile$[rbp-232]
  00110	e8 00 00 00 00	 call	 ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::open

; 1310 : 			_Myios::setstate(ios_base::failbit);

  00115	45 33 c0	 xor	 r8d, r8d

; 1309 : 		if (_Filebuffer.open(_Filename, _Mode, _Prot) == 0)

  00118	48 85 c0	 test	 rax, rax

; 1310 : 			_Myios::setstate(ios_base::failbit);

  0011b	48 8b 45 80	 mov	 rax, QWORD PTR inFile$[rbp-256]
  0011f	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00123	48 8d 45 80	 lea	 rax, QWORD PTR inFile$[rbp-256]

; 1309 : 		if (_Filebuffer.open(_Filename, _Mode, _Prot) == 0)

  00127	75 0e		 jne	 SHORT $LN188@main

; 1310 : 			_Myios::setstate(ios_base::failbit);

  00129	48 03 c8	 add	 rcx, rax
  0012c	8d 56 02	 lea	 edx, QWORD PTR [rsi+2]
  0012f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z

; 1311 : 		else

  00135	eb 0b		 jmp	 SHORT $LN189@main
$LN188@main:

; 1312 : 			_Myios::clear();	// added with C++11

  00137	48 03 c8	 add	 rcx, rax
  0013a	33 d2		 xor	 edx, edx
  0013c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
$LN189@main:
; File c:\users\coschm\desktop\fall-2016\security\des\des\des\main.cpp

; 601  : 	if (!inFile) //infile check -> open

  00142	48 8b 45 80	 mov	 rax, QWORD PTR inFile$[rbp-256]
  00146	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 349  : 		return (((int)rdstate()

  0014a	f6 44 0d 90 06	 test	 BYTE PTR inFile$[rbp+rcx-240], 6
; File c:\users\coschm\desktop\fall-2016\security\des\des\des\main.cpp

; 601  : 	if (!inFile) //infile check -> open

  0014f	74 0d		 je	 SHORT $LN8@main

; 602  : 	{
; 603  : 		errorWithMessage("File does not exist.");

  00151	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BF@NMCADOHI@File?5does?5not?5exist?4?$AA@
  00158	e8 00 00 00 00	 call	 ?errorWithMessage@@YAXPEAD@Z ; errorWithMessage
  0015d	cc		 int	 3
$LN8@main:

; 604  : 	}
; 605  : 
; 606  : 	char *outFileName = argv[5];

  0015e	48 8b 5f 28	 mov	 rbx, QWORD PTR [rdi+40]

; 607  : 	fstream outFile;

  00162	ba 01 00 00 00	 mov	 edx, 1
  00167	48 8d 8d b0 00
	00 00		 lea	 rcx, QWORD PTR outFile$[rbp-256]
  0016e	e8 00 00 00 00	 call	 ??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_fstream<char,std::char_traits<char> >::basic_fstream<char,std::char_traits<char> >
  00173	90		 npad	 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream

; 1309 : 		if (_Filebuffer.open(_Filename, _Mode, _Prot) == 0)

  00174	41 b9 40 00 00
	00		 mov	 r9d, 64			; 00000040H
  0017a	45 8d 41 f2	 lea	 r8d, QWORD PTR [r9-14]
  0017e	48 8b d3	 mov	 rdx, rbx
  00181	48 8d 8d c8 00
	00 00		 lea	 rcx, QWORD PTR outFile$[rbp-232]
  00188	e8 00 00 00 00	 call	 ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::open

; 1310 : 			_Myios::setstate(ios_base::failbit);

  0018d	45 33 c0	 xor	 r8d, r8d

; 1309 : 		if (_Filebuffer.open(_Filename, _Mode, _Prot) == 0)

  00190	48 85 c0	 test	 rax, rax

; 1310 : 			_Myios::setstate(ios_base::failbit);

  00193	48 8b 85 b0 00
	00 00		 mov	 rax, QWORD PTR outFile$[rbp-256]
  0019a	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  0019e	48 8d 85 b0 00
	00 00		 lea	 rax, QWORD PTR outFile$[rbp-256]

; 1309 : 		if (_Filebuffer.open(_Filename, _Mode, _Prot) == 0)

  001a5	75 0f		 jne	 SHORT $LN198@main

; 1310 : 			_Myios::setstate(ios_base::failbit);

  001a7	48 03 c8	 add	 rcx, rax
  001aa	41 8d 50 02	 lea	 edx, QWORD PTR [r8+2]
  001ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z

; 1311 : 		else

  001b4	eb 0b		 jmp	 SHORT $LN199@main
$LN198@main:

; 1312 : 			_Myios::clear();	// added with C++11

  001b6	48 03 c8	 add	 rcx, rax
  001b9	33 d2		 xor	 edx, edx
  001bb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
$LN199@main:
; File c:\users\coschm\desktop\fall-2016\security\des\des\des\main.cpp

; 619  : 	if (strlen(argv[2]) == 10)

  001c1	4c 8b 47 10	 mov	 r8, QWORD PTR [rdi+16]
  001c5	48 83 c8 ff	 or	 rax, -1
  001c9	0f 1f 80 00 00
	00 00		 npad	 7
$LL298@main:
  001d0	48 ff c0	 inc	 rax
  001d3	41 80 3c 00 00	 cmp	 BYTE PTR [r8+rax], 0
  001d8	75 f6		 jne	 SHORT $LL298@main
  001da	48 83 f8 0a	 cmp	 rax, 10
  001de	75 73		 jne	 SHORT $LN9@main

; 620  : 	{
; 621  : 		key |= (((uint64_t)argv[2][1] << 56) & 0xFF00000000000000U)

  001e0	49 0f be 40 02	 movsx	 rax, BYTE PTR [r8+2]
  001e5	0f b6 d0	 movzx	 edx, al
  001e8	49 0f be 40 01	 movsx	 rax, BYTE PTR [r8+1]
  001ed	48 c1 e0 08	 shl	 rax, 8
  001f1	48 0b d0	 or	 rdx, rax
  001f4	48 c1 e2 08	 shl	 rdx, 8
  001f8	49 0f be 40 03	 movsx	 rax, BYTE PTR [r8+3]
  001fd	0f b6 c8	 movzx	 ecx, al
  00200	48 0b d1	 or	 rdx, rcx
  00203	48 c1 e2 08	 shl	 rdx, 8
  00207	49 0f be 40 04	 movsx	 rax, BYTE PTR [r8+4]
  0020c	0f b6 c8	 movzx	 ecx, al
  0020f	48 0b d1	 or	 rdx, rcx
  00212	48 c1 e2 08	 shl	 rdx, 8
  00216	49 0f be 40 05	 movsx	 rax, BYTE PTR [r8+5]
  0021b	0f b6 c8	 movzx	 ecx, al
  0021e	48 0b d1	 or	 rdx, rcx
  00221	48 c1 e2 08	 shl	 rdx, 8
  00225	49 0f be 40 06	 movsx	 rax, BYTE PTR [r8+6]
  0022a	0f b6 c8	 movzx	 ecx, al
  0022d	48 0b d1	 or	 rdx, rcx
  00230	48 c1 e2 08	 shl	 rdx, 8
  00234	49 0f be 40 07	 movsx	 rax, BYTE PTR [r8+7]
  00239	0f b6 c8	 movzx	 ecx, al
  0023c	48 0b d1	 or	 rdx, rcx
  0023f	48 c1 e2 08	 shl	 rdx, 8
  00243	49 0f be 40 08	 movsx	 rax, BYTE PTR [r8+8]
  00248	0f b6 c8	 movzx	 ecx, al
  0024b	48 0b d1	 or	 rdx, rcx

; 622  : 			|  (((uint64_t)argv[2][2] << 48) & 0x00FF000000000000U)
; 623  : 			|  (((uint64_t)argv[2][3] << 40) & 0x0000FF0000000000U)
; 624  : 			|  (((uint64_t)argv[2][4] << 32) & 0x000000FF00000000U)
; 625  : 			|  (((uint64_t)argv[2][5] << 24) & 0x00000000FF000000U)
; 626  : 			|  (((uint64_t)argv[2][6] << 16) & 0x0000000000FF0000U)
; 627  : 			|  (((uint64_t)argv[2][7] << 8)  & 0x000000000000FF00U)
; 628  : 			|  (((uint64_t)argv[2][8])		 & 0x00000000000000FFU);
; 629  : 	}
; 630  : 	//if the key comes in as 16 Hex values
; 631  : 	else {

  0024e	e9 f5 03 00 00	 jmp	 $LN10@main
$LN9@main:

; 632  : 		//check to make sure each value is valid hex
; 633  : 		if (argv[2][0] >= 48 && argv[2][0] <= 57)

  00253	41 0f b6 08	 movzx	 ecx, BYTE PTR [r8]
  00257	8d 41 d0	 lea	 eax, DWORD PTR [rcx-48]
  0025a	3c 09		 cmp	 al, 9
  0025c	77 05		 ja	 SHORT $LN11@main

; 634  : 		{
; 635  : 			argv[2][0] -= 48;

  0025e	80 e9 30	 sub	 cl, 48			; 00000030H
  00261	eb 1a		 jmp	 SHORT $LN302@main
$LN11@main:
  00263	8d 41 bf	 lea	 eax, DWORD PTR [rcx-65]
  00266	3c 05		 cmp	 al, 5
  00268	77 05		 ja	 SHORT $LN13@main

; 636  : 		}
; 637  : 		else if (argv[2][0] >= 65 && argv[2][0] <= 70)
; 638  : 		{
; 639  : 			argv[2][0] -= 55;

  0026a	80 e9 37	 sub	 cl, 55			; 00000037H
  0026d	eb 0e		 jmp	 SHORT $LN302@main
$LN13@main:
  0026f	8d 41 9f	 lea	 eax, DWORD PTR [rcx-97]
  00272	3c 05		 cmp	 al, 5
  00274	0f 87 62 19 00
	00		 ja	 $LN15@main

; 640  : 		}
; 641  : 		else if (argv[2][0] >= 97 && argv[2][0] <= 102)
; 642  : 		{
; 643  : 			argv[2][0] -= 87;

  0027a	80 e9 57	 sub	 cl, 87			; 00000057H
$LN302@main:
  0027d	41 88 08	 mov	 BYTE PTR [r8], cl

; 646  : 
; 647  : 		if (argv[2][1] >= 48 && argv[2][1] <= 57)

  00280	48 8b 57 10	 mov	 rdx, QWORD PTR [rdi+16]
  00284	0f b6 4a 01	 movzx	 ecx, BYTE PTR [rdx+1]
  00288	8d 41 d0	 lea	 eax, DWORD PTR [rcx-48]
  0028b	3c 09		 cmp	 al, 9
  0028d	77 05		 ja	 SHORT $LN17@main

; 648  : 		{
; 649  : 			argv[2][1] -= 48;

  0028f	80 e9 30	 sub	 cl, 48			; 00000030H
  00292	eb 1a		 jmp	 SHORT $LN303@main
$LN17@main:
  00294	8d 41 bf	 lea	 eax, DWORD PTR [rcx-65]
  00297	3c 05		 cmp	 al, 5
  00299	77 05		 ja	 SHORT $LN19@main

; 650  : 		}
; 651  : 		else if (argv[2][1] >= 65 && argv[2][1] <= 70)
; 652  : 		{
; 653  : 			argv[2][1] -= 55;

  0029b	80 e9 37	 sub	 cl, 55			; 00000037H
  0029e	eb 0e		 jmp	 SHORT $LN303@main
$LN19@main:
  002a0	8d 41 9f	 lea	 eax, DWORD PTR [rcx-97]
  002a3	3c 05		 cmp	 al, 5
  002a5	0f 87 24 19 00
	00		 ja	 $LN21@main

; 654  : 		}
; 655  : 		else if (argv[2][1] >= 97 && argv[2][1] <= 102)
; 656  : 		{
; 657  : 			argv[2][1] -= 87;

  002ab	80 e9 57	 sub	 cl, 87			; 00000057H
$LN303@main:
  002ae	88 4a 01	 mov	 BYTE PTR [rdx+1], cl

; 660  : 
; 661  : 		if (argv[2][2] >= 48 && argv[2][2] <= 57)

  002b1	48 8b 57 10	 mov	 rdx, QWORD PTR [rdi+16]
  002b5	0f b6 4a 02	 movzx	 ecx, BYTE PTR [rdx+2]
  002b9	8d 41 d0	 lea	 eax, DWORD PTR [rcx-48]
  002bc	3c 09		 cmp	 al, 9
  002be	77 05		 ja	 SHORT $LN23@main

; 662  : 		{
; 663  : 			argv[2][2] -= 48;

  002c0	80 e9 30	 sub	 cl, 48			; 00000030H
  002c3	eb 1a		 jmp	 SHORT $LN304@main
$LN23@main:
  002c5	8d 41 bf	 lea	 eax, DWORD PTR [rcx-65]
  002c8	3c 05		 cmp	 al, 5
  002ca	77 05		 ja	 SHORT $LN25@main

; 664  : 		}
; 665  : 		else if (argv[2][2] >= 65 && argv[2][2] <= 70)
; 666  : 		{
; 667  : 			argv[2][2] -= 55;

  002cc	80 e9 37	 sub	 cl, 55			; 00000037H
  002cf	eb 0e		 jmp	 SHORT $LN304@main
$LN25@main:
  002d1	8d 41 9f	 lea	 eax, DWORD PTR [rcx-97]
  002d4	3c 05		 cmp	 al, 5
  002d6	0f 87 e6 18 00
	00		 ja	 $LN27@main

; 668  : 		}
; 669  : 		else if (argv[2][2] >= 97 && argv[2][2] <= 102)
; 670  : 		{
; 671  : 			argv[2][2] -= 87;

  002dc	80 e9 57	 sub	 cl, 87			; 00000057H
$LN304@main:
  002df	88 4a 02	 mov	 BYTE PTR [rdx+2], cl

; 674  : 
; 675  : 		if (argv[2][3] >= 48 && argv[2][3] <= 57)

  002e2	48 8b 57 10	 mov	 rdx, QWORD PTR [rdi+16]
  002e6	0f b6 4a 03	 movzx	 ecx, BYTE PTR [rdx+3]
  002ea	8d 41 d0	 lea	 eax, DWORD PTR [rcx-48]
  002ed	3c 09		 cmp	 al, 9
  002ef	77 05		 ja	 SHORT $LN29@main

; 676  : 		{
; 677  : 			argv[2][3] -= 48;

  002f1	80 e9 30	 sub	 cl, 48			; 00000030H
  002f4	eb 1a		 jmp	 SHORT $LN305@main
$LN29@main:
  002f6	8d 41 bf	 lea	 eax, DWORD PTR [rcx-65]
  002f9	3c 05		 cmp	 al, 5
  002fb	77 05		 ja	 SHORT $LN31@main

; 678  : 		}
; 679  : 		else if (argv[2][3] >= 65 && argv[2][3] <= 70)
; 680  : 		{
; 681  : 			argv[2][3] -= 55;

  002fd	80 e9 37	 sub	 cl, 55			; 00000037H
  00300	eb 0e		 jmp	 SHORT $LN305@main
$LN31@main:
  00302	8d 41 9f	 lea	 eax, DWORD PTR [rcx-97]
  00305	3c 05		 cmp	 al, 5
  00307	0f 87 a8 18 00
	00		 ja	 $LN33@main

; 682  : 		}
; 683  : 		else if (argv[2][3] >= 97 && argv[2][3] <= 102)
; 684  : 		{
; 685  : 			argv[2][3] -= 87;

  0030d	80 e9 57	 sub	 cl, 87			; 00000057H
$LN305@main:
  00310	88 4a 03	 mov	 BYTE PTR [rdx+3], cl

; 688  : 
; 689  : 		if (argv[2][4] >= 48 && argv[2][4] <= 57)

  00313	48 8b 57 10	 mov	 rdx, QWORD PTR [rdi+16]
  00317	0f b6 4a 04	 movzx	 ecx, BYTE PTR [rdx+4]
  0031b	8d 41 d0	 lea	 eax, DWORD PTR [rcx-48]
  0031e	3c 09		 cmp	 al, 9
  00320	77 05		 ja	 SHORT $LN35@main

; 690  : 		{
; 691  : 			argv[2][4] -= 48;

  00322	80 e9 30	 sub	 cl, 48			; 00000030H
  00325	eb 1a		 jmp	 SHORT $LN306@main
$LN35@main:
  00327	8d 41 bf	 lea	 eax, DWORD PTR [rcx-65]
  0032a	3c 05		 cmp	 al, 5
  0032c	77 05		 ja	 SHORT $LN37@main

; 692  : 		}
; 693  : 		else if (argv[2][4] >= 65 && argv[2][4] <= 70)
; 694  : 		{
; 695  : 			argv[2][4] -= 55;

  0032e	80 e9 37	 sub	 cl, 55			; 00000037H
  00331	eb 0e		 jmp	 SHORT $LN306@main
$LN37@main:
  00333	8d 41 9f	 lea	 eax, DWORD PTR [rcx-97]
  00336	3c 05		 cmp	 al, 5
  00338	0f 87 6a 18 00
	00		 ja	 $LN39@main

; 696  : 		}
; 697  : 		else if (argv[2][4] >= 97 && argv[2][4] <= 102)
; 698  : 		{
; 699  : 			argv[2][4] -= 87;

  0033e	80 e9 57	 sub	 cl, 87			; 00000057H
$LN306@main:
  00341	88 4a 04	 mov	 BYTE PTR [rdx+4], cl

; 702  : 
; 703  : 		if (argv[2][5] >= 48 && argv[2][5] <= 57)

  00344	48 8b 57 10	 mov	 rdx, QWORD PTR [rdi+16]
  00348	0f b6 4a 05	 movzx	 ecx, BYTE PTR [rdx+5]
  0034c	8d 41 d0	 lea	 eax, DWORD PTR [rcx-48]
  0034f	3c 09		 cmp	 al, 9
  00351	77 05		 ja	 SHORT $LN41@main

; 704  : 		{
; 705  : 			argv[2][5] -= 48;

  00353	80 e9 30	 sub	 cl, 48			; 00000030H
  00356	eb 1a		 jmp	 SHORT $LN307@main
$LN41@main:
  00358	8d 41 bf	 lea	 eax, DWORD PTR [rcx-65]
  0035b	3c 05		 cmp	 al, 5
  0035d	77 05		 ja	 SHORT $LN43@main

; 706  : 		}
; 707  : 		else if (argv[2][5] >= 65 && argv[2][5] <= 70)
; 708  : 		{
; 709  : 			argv[2][5] -= 55;

  0035f	80 e9 37	 sub	 cl, 55			; 00000037H
  00362	eb 0e		 jmp	 SHORT $LN307@main
$LN43@main:
  00364	8d 41 9f	 lea	 eax, DWORD PTR [rcx-97]
  00367	3c 05		 cmp	 al, 5
  00369	0f 87 2c 18 00
	00		 ja	 $LN45@main

; 710  : 		}
; 711  : 		else if (argv[2][5] >= 97 && argv[2][5] <= 102)
; 712  : 		{
; 713  : 			argv[2][5] -= 87;

  0036f	80 e9 57	 sub	 cl, 87			; 00000057H
$LN307@main:
  00372	88 4a 05	 mov	 BYTE PTR [rdx+5], cl

; 716  : 
; 717  : 		if (argv[2][6] >= 48 && argv[2][6] <= 57)

  00375	48 8b 57 10	 mov	 rdx, QWORD PTR [rdi+16]
  00379	0f b6 4a 06	 movzx	 ecx, BYTE PTR [rdx+6]
  0037d	8d 41 d0	 lea	 eax, DWORD PTR [rcx-48]
  00380	3c 09		 cmp	 al, 9
  00382	77 05		 ja	 SHORT $LN47@main

; 718  : 		{
; 719  : 			argv[2][6] -= 48;

  00384	80 e9 30	 sub	 cl, 48			; 00000030H
  00387	eb 1a		 jmp	 SHORT $LN308@main
$LN47@main:
  00389	8d 41 bf	 lea	 eax, DWORD PTR [rcx-65]
  0038c	3c 05		 cmp	 al, 5
  0038e	77 05		 ja	 SHORT $LN49@main

; 720  : 		}
; 721  : 		else if (argv[2][6] >= 65 && argv[2][6] <= 70)
; 722  : 		{
; 723  : 			argv[2][6] -= 55;

  00390	80 e9 37	 sub	 cl, 55			; 00000037H
  00393	eb 0e		 jmp	 SHORT $LN308@main
$LN49@main:
  00395	8d 41 9f	 lea	 eax, DWORD PTR [rcx-97]
  00398	3c 05		 cmp	 al, 5
  0039a	0f 87 ee 17 00
	00		 ja	 $LN51@main

; 724  : 		}
; 725  : 		else if (argv[2][6] >= 97 && argv[2][6] <= 102)
; 726  : 		{
; 727  : 			argv[2][6] -= 87;

  003a0	80 e9 57	 sub	 cl, 87			; 00000057H
$LN308@main:
  003a3	88 4a 06	 mov	 BYTE PTR [rdx+6], cl

; 730  : 
; 731  : 		if (argv[2][7] >= 48 && argv[2][7] <= 57)

  003a6	48 8b 57 10	 mov	 rdx, QWORD PTR [rdi+16]
  003aa	0f b6 4a 07	 movzx	 ecx, BYTE PTR [rdx+7]
  003ae	8d 41 d0	 lea	 eax, DWORD PTR [rcx-48]
  003b1	3c 09		 cmp	 al, 9
  003b3	77 05		 ja	 SHORT $LN53@main

; 732  : 		{
; 733  : 			argv[2][7] -= 48;

  003b5	80 e9 30	 sub	 cl, 48			; 00000030H
  003b8	eb 1a		 jmp	 SHORT $LN309@main
$LN53@main:
  003ba	8d 41 bf	 lea	 eax, DWORD PTR [rcx-65]
  003bd	3c 05		 cmp	 al, 5
  003bf	77 05		 ja	 SHORT $LN55@main

; 734  : 		}
; 735  : 		else if (argv[2][7] >= 65 && argv[2][7] <= 70)
; 736  : 		{
; 737  : 			argv[2][7] -= 55;

  003c1	80 e9 37	 sub	 cl, 55			; 00000037H
  003c4	eb 0e		 jmp	 SHORT $LN309@main
$LN55@main:
  003c6	8d 41 9f	 lea	 eax, DWORD PTR [rcx-97]
  003c9	3c 05		 cmp	 al, 5
  003cb	0f 87 b0 17 00
	00		 ja	 $LN57@main

; 738  : 		}
; 739  : 		else if (argv[2][7] >= 97 && argv[2][7] <= 102)
; 740  : 		{
; 741  : 			argv[2][7] -= 87;

  003d1	80 e9 57	 sub	 cl, 87			; 00000057H
$LN309@main:
  003d4	88 4a 07	 mov	 BYTE PTR [rdx+7], cl

; 744  : 
; 745  : 		if (argv[2][8] >= 48 && argv[2][8] <= 57)

  003d7	48 8b 57 10	 mov	 rdx, QWORD PTR [rdi+16]
  003db	0f b6 4a 08	 movzx	 ecx, BYTE PTR [rdx+8]
  003df	8d 41 d0	 lea	 eax, DWORD PTR [rcx-48]
  003e2	3c 09		 cmp	 al, 9
  003e4	77 05		 ja	 SHORT $LN59@main

; 746  : 		{
; 747  : 			argv[2][8] -= 48;

  003e6	80 e9 30	 sub	 cl, 48			; 00000030H
  003e9	eb 1a		 jmp	 SHORT $LN310@main
$LN59@main:
  003eb	8d 41 bf	 lea	 eax, DWORD PTR [rcx-65]
  003ee	3c 05		 cmp	 al, 5
  003f0	77 05		 ja	 SHORT $LN61@main

; 748  : 		}
; 749  : 		else if (argv[2][8] >= 65 && argv[2][8] <= 70)
; 750  : 		{
; 751  : 			argv[2][8] -= 55;

  003f2	80 e9 37	 sub	 cl, 55			; 00000037H
  003f5	eb 0e		 jmp	 SHORT $LN310@main
$LN61@main:
  003f7	8d 41 9f	 lea	 eax, DWORD PTR [rcx-97]
  003fa	3c 05		 cmp	 al, 5
  003fc	0f 87 72 17 00
	00		 ja	 $LN63@main

; 752  : 		}
; 753  : 		else if (argv[2][8] >= 97 && argv[2][8] <= 102)
; 754  : 		{
; 755  : 			argv[2][8] -= 87;

  00402	80 e9 57	 sub	 cl, 87			; 00000057H
$LN310@main:
  00405	88 4a 08	 mov	 BYTE PTR [rdx+8], cl

; 758  : 
; 759  : 		if (argv[2][9] >= 48 && argv[2][9] <= 57)

  00408	48 8b 57 10	 mov	 rdx, QWORD PTR [rdi+16]
  0040c	0f b6 4a 09	 movzx	 ecx, BYTE PTR [rdx+9]
  00410	8d 41 d0	 lea	 eax, DWORD PTR [rcx-48]
  00413	3c 09		 cmp	 al, 9
  00415	77 05		 ja	 SHORT $LN65@main

; 760  : 		{
; 761  : 			argv[2][9] -= 48;

  00417	80 e9 30	 sub	 cl, 48			; 00000030H
  0041a	eb 1a		 jmp	 SHORT $LN311@main
$LN65@main:
  0041c	8d 41 bf	 lea	 eax, DWORD PTR [rcx-65]
  0041f	3c 05		 cmp	 al, 5
  00421	77 05		 ja	 SHORT $LN67@main

; 762  : 		}
; 763  : 		else if (argv[2][9] >= 65 && argv[2][9] <= 70)
; 764  : 		{
; 765  : 			argv[2][9] -= 55;

  00423	80 e9 37	 sub	 cl, 55			; 00000037H
  00426	eb 0e		 jmp	 SHORT $LN311@main
$LN67@main:
  00428	8d 41 9f	 lea	 eax, DWORD PTR [rcx-97]
  0042b	3c 05		 cmp	 al, 5
  0042d	0f 87 34 17 00
	00		 ja	 $LN69@main

; 766  : 		}
; 767  : 		else if (argv[2][9] >= 97 && argv[2][9] <= 102)
; 768  : 		{
; 769  : 			argv[2][9] -= 87;

  00433	80 e9 57	 sub	 cl, 87			; 00000057H
$LN311@main:
  00436	88 4a 09	 mov	 BYTE PTR [rdx+9], cl

; 772  : 
; 773  : 		if (argv[2][10] >= 48 && argv[2][10] <= 57)

  00439	48 8b 57 10	 mov	 rdx, QWORD PTR [rdi+16]
  0043d	0f b6 4a 0a	 movzx	 ecx, BYTE PTR [rdx+10]
  00441	8d 41 d0	 lea	 eax, DWORD PTR [rcx-48]
  00444	3c 09		 cmp	 al, 9
  00446	77 05		 ja	 SHORT $LN71@main

; 774  : 		{
; 775  : 			argv[2][10] -= 48;

  00448	80 e9 30	 sub	 cl, 48			; 00000030H
  0044b	eb 1a		 jmp	 SHORT $LN312@main
$LN71@main:
  0044d	8d 41 bf	 lea	 eax, DWORD PTR [rcx-65]
  00450	3c 05		 cmp	 al, 5
  00452	77 05		 ja	 SHORT $LN73@main

; 776  : 		}
; 777  : 		else if (argv[2][10] >= 65 && argv[2][10] <= 70)
; 778  : 		{
; 779  : 			argv[2][10] -= 55;

  00454	80 e9 37	 sub	 cl, 55			; 00000037H
  00457	eb 0e		 jmp	 SHORT $LN312@main
$LN73@main:
  00459	8d 41 9f	 lea	 eax, DWORD PTR [rcx-97]
  0045c	3c 05		 cmp	 al, 5
  0045e	0f 87 f6 16 00
	00		 ja	 $LN75@main

; 780  : 		}
; 781  : 		else if (argv[2][10] >= 97 && argv[2][10] <= 102)
; 782  : 		{
; 783  : 			argv[2][10] -= 87;

  00464	80 e9 57	 sub	 cl, 87			; 00000057H
$LN312@main:
  00467	88 4a 0a	 mov	 BYTE PTR [rdx+10], cl

; 786  : 
; 787  : 		if (argv[2][11] >= 48 && argv[2][11] <= 57)

  0046a	48 8b 57 10	 mov	 rdx, QWORD PTR [rdi+16]
  0046e	0f b6 4a 0b	 movzx	 ecx, BYTE PTR [rdx+11]
  00472	8d 41 d0	 lea	 eax, DWORD PTR [rcx-48]
  00475	3c 09		 cmp	 al, 9
  00477	77 05		 ja	 SHORT $LN77@main

; 788  : 		{
; 789  : 			argv[2][11] -= 48;

  00479	80 e9 30	 sub	 cl, 48			; 00000030H
  0047c	eb 1a		 jmp	 SHORT $LN313@main
$LN77@main:
  0047e	8d 41 bf	 lea	 eax, DWORD PTR [rcx-65]
  00481	3c 05		 cmp	 al, 5
  00483	77 05		 ja	 SHORT $LN79@main

; 790  : 		}
; 791  : 		else if (argv[2][11] >= 65 && argv[2][11] <= 70)
; 792  : 		{
; 793  : 			argv[2][11] -= 55;

  00485	80 e9 37	 sub	 cl, 55			; 00000037H
  00488	eb 0e		 jmp	 SHORT $LN313@main
$LN79@main:
  0048a	8d 41 9f	 lea	 eax, DWORD PTR [rcx-97]
  0048d	3c 05		 cmp	 al, 5
  0048f	0f 87 b8 16 00
	00		 ja	 $LN81@main

; 794  : 		}
; 795  : 		else if (argv[2][11] >= 97 && argv[2][11] <= 102)
; 796  : 		{
; 797  : 			argv[2][11] -= 87;

  00495	80 e9 57	 sub	 cl, 87			; 00000057H
$LN313@main:
  00498	88 4a 0b	 mov	 BYTE PTR [rdx+11], cl

; 800  : 
; 801  : 		if (argv[2][12] >= 48 && argv[2][12] <= 57)

  0049b	48 8b 57 10	 mov	 rdx, QWORD PTR [rdi+16]
  0049f	0f b6 4a 0c	 movzx	 ecx, BYTE PTR [rdx+12]
  004a3	8d 41 d0	 lea	 eax, DWORD PTR [rcx-48]
  004a6	3c 09		 cmp	 al, 9
  004a8	77 05		 ja	 SHORT $LN83@main

; 802  : 		{
; 803  : 			argv[2][12] -= 48;

  004aa	80 e9 30	 sub	 cl, 48			; 00000030H
  004ad	eb 1a		 jmp	 SHORT $LN314@main
$LN83@main:
  004af	8d 41 bf	 lea	 eax, DWORD PTR [rcx-65]
  004b2	3c 05		 cmp	 al, 5
  004b4	77 05		 ja	 SHORT $LN85@main

; 804  : 		}
; 805  : 		else if (argv[2][12] >= 65 && argv[2][12] <= 70)
; 806  : 		{
; 807  : 			argv[2][12] -= 55;

  004b6	80 e9 37	 sub	 cl, 55			; 00000037H
  004b9	eb 0e		 jmp	 SHORT $LN314@main
$LN85@main:
  004bb	8d 41 9f	 lea	 eax, DWORD PTR [rcx-97]
  004be	3c 05		 cmp	 al, 5
  004c0	0f 87 7a 16 00
	00		 ja	 $LN87@main

; 808  : 		}
; 809  : 		else if (argv[2][12] >= 97 && argv[2][12] <= 102)
; 810  : 		{
; 811  : 			argv[2][12] -= 87;

  004c6	80 e9 57	 sub	 cl, 87			; 00000057H
$LN314@main:
  004c9	88 4a 0c	 mov	 BYTE PTR [rdx+12], cl

; 814  : 
; 815  : 		if (argv[2][13] >= 48 && argv[2][13] <= 57)

  004cc	48 8b 57 10	 mov	 rdx, QWORD PTR [rdi+16]
  004d0	0f b6 4a 0d	 movzx	 ecx, BYTE PTR [rdx+13]
  004d4	8d 41 d0	 lea	 eax, DWORD PTR [rcx-48]
  004d7	3c 09		 cmp	 al, 9
  004d9	77 05		 ja	 SHORT $LN89@main

; 816  : 		{
; 817  : 			argv[2][13] -= 48;

  004db	80 e9 30	 sub	 cl, 48			; 00000030H
  004de	eb 1a		 jmp	 SHORT $LN315@main
$LN89@main:
  004e0	8d 41 bf	 lea	 eax, DWORD PTR [rcx-65]
  004e3	3c 05		 cmp	 al, 5
  004e5	77 05		 ja	 SHORT $LN91@main

; 818  : 		}
; 819  : 		else if (argv[2][13] >= 65 && argv[2][13] <= 70)
; 820  : 		{
; 821  : 			argv[2][13] -= 55;

  004e7	80 e9 37	 sub	 cl, 55			; 00000037H
  004ea	eb 0e		 jmp	 SHORT $LN315@main
$LN91@main:
  004ec	8d 41 9f	 lea	 eax, DWORD PTR [rcx-97]
  004ef	3c 05		 cmp	 al, 5
  004f1	0f 87 3c 16 00
	00		 ja	 $LN93@main

; 822  : 		}
; 823  : 		else if (argv[2][13] >= 97 && argv[2][13] <= 102)
; 824  : 		{
; 825  : 			argv[2][13] -= 87;

  004f7	80 e9 57	 sub	 cl, 87			; 00000057H
$LN315@main:
  004fa	88 4a 0d	 mov	 BYTE PTR [rdx+13], cl

; 828  : 
; 829  : 		if (argv[2][14] >= 48 && argv[2][14] <= 57)

  004fd	48 8b 57 10	 mov	 rdx, QWORD PTR [rdi+16]
  00501	0f b6 4a 0e	 movzx	 ecx, BYTE PTR [rdx+14]
  00505	8d 41 d0	 lea	 eax, DWORD PTR [rcx-48]
  00508	3c 09		 cmp	 al, 9
  0050a	77 05		 ja	 SHORT $LN95@main

; 830  : 		{
; 831  : 			argv[2][14] -= 48;

  0050c	80 e9 30	 sub	 cl, 48			; 00000030H
  0050f	eb 1a		 jmp	 SHORT $LN316@main
$LN95@main:
  00511	8d 41 bf	 lea	 eax, DWORD PTR [rcx-65]
  00514	3c 05		 cmp	 al, 5
  00516	77 05		 ja	 SHORT $LN97@main

; 832  : 		}
; 833  : 		else if (argv[2][14] >= 65 && argv[2][14] <= 70)
; 834  : 		{
; 835  : 			argv[2][14] -= 55;

  00518	80 e9 37	 sub	 cl, 55			; 00000037H
  0051b	eb 0e		 jmp	 SHORT $LN316@main
$LN97@main:
  0051d	8d 41 9f	 lea	 eax, DWORD PTR [rcx-97]
  00520	3c 05		 cmp	 al, 5
  00522	0f 87 fe 15 00
	00		 ja	 $LN99@main

; 836  : 		}
; 837  : 		else if (argv[2][14] >= 97 && argv[2][14] <= 102)
; 838  : 		{
; 839  : 			argv[2][14] -= 87;

  00528	80 e9 57	 sub	 cl, 87			; 00000057H
$LN316@main:
  0052b	88 4a 0e	 mov	 BYTE PTR [rdx+14], cl

; 842  : 
; 843  : 		if (argv[2][15] >= 48 && argv[2][15] <= 57)

  0052e	48 8b 57 10	 mov	 rdx, QWORD PTR [rdi+16]
  00532	0f b6 4a 0f	 movzx	 ecx, BYTE PTR [rdx+15]
  00536	8d 41 d0	 lea	 eax, DWORD PTR [rcx-48]
  00539	3c 09		 cmp	 al, 9
  0053b	77 05		 ja	 SHORT $LN101@main

; 844  : 		{
; 845  : 			argv[2][15] -= 48;

  0053d	80 e9 30	 sub	 cl, 48			; 00000030H
  00540	eb 1a		 jmp	 SHORT $LN317@main
$LN101@main:
  00542	8d 41 bf	 lea	 eax, DWORD PTR [rcx-65]
  00545	3c 05		 cmp	 al, 5
  00547	77 05		 ja	 SHORT $LN103@main

; 846  : 		}
; 847  : 		else if (argv[2][15] >= 65 && argv[2][15] <= 70)
; 848  : 		{
; 849  : 			argv[2][15] -= 55;

  00549	80 e9 37	 sub	 cl, 55			; 00000037H
  0054c	eb 0e		 jmp	 SHORT $LN317@main
$LN103@main:
  0054e	8d 41 9f	 lea	 eax, DWORD PTR [rcx-97]
  00551	3c 05		 cmp	 al, 5
  00553	0f 87 c0 15 00
	00		 ja	 $LN105@main

; 850  : 		}
; 851  : 		else if (argv[2][15] >= 97 && argv[2][15] <= 102)
; 852  : 		{
; 853  : 			argv[2][15] -= 87;

  00559	80 e9 57	 sub	 cl, 87			; 00000057H
$LN317@main:
  0055c	88 4a 0f	 mov	 BYTE PTR [rdx+15], cl

; 856  : 
; 857  : 		//now that we have them all in hex values we will put them into the key
; 858  : 		key |=(((uint64_t)argv[2][0] << 60) & 0xF000000000000000)

  0055f	48 8b 4f 10	 mov	 rcx, QWORD PTR [rdi+16]
  00563	48 0f be 51 01	 movsx	 rdx, BYTE PTR [rcx+1]
  00568	83 e2 0f	 and	 edx, 15
  0056b	48 0f be 01	 movsx	 rax, BYTE PTR [rcx]
  0056f	48 c1 e0 04	 shl	 rax, 4
  00573	48 0b d0	 or	 rdx, rax
  00576	48 c1 e2 04	 shl	 rdx, 4
  0057a	48 0f be 41 02	 movsx	 rax, BYTE PTR [rcx+2]
  0057f	83 e0 0f	 and	 eax, 15
  00582	48 0b d0	 or	 rdx, rax
  00585	48 c1 e2 04	 shl	 rdx, 4
  00589	48 0f be 41 03	 movsx	 rax, BYTE PTR [rcx+3]
  0058e	83 e0 0f	 and	 eax, 15
  00591	48 0b d0	 or	 rdx, rax
  00594	48 c1 e2 04	 shl	 rdx, 4
  00598	48 0f be 41 04	 movsx	 rax, BYTE PTR [rcx+4]
  0059d	83 e0 0f	 and	 eax, 15
  005a0	48 0b d0	 or	 rdx, rax
  005a3	48 c1 e2 04	 shl	 rdx, 4
  005a7	48 0f be 41 05	 movsx	 rax, BYTE PTR [rcx+5]
  005ac	83 e0 0f	 and	 eax, 15
  005af	48 0b d0	 or	 rdx, rax
  005b2	48 c1 e2 04	 shl	 rdx, 4
  005b6	48 0f be 41 06	 movsx	 rax, BYTE PTR [rcx+6]
  005bb	83 e0 0f	 and	 eax, 15
  005be	48 0b d0	 or	 rdx, rax
  005c1	48 c1 e2 04	 shl	 rdx, 4
  005c5	48 0f be 41 07	 movsx	 rax, BYTE PTR [rcx+7]
  005ca	83 e0 0f	 and	 eax, 15
  005cd	48 0b d0	 or	 rdx, rax
  005d0	48 c1 e2 04	 shl	 rdx, 4
  005d4	48 0f be 41 08	 movsx	 rax, BYTE PTR [rcx+8]
  005d9	83 e0 0f	 and	 eax, 15
  005dc	48 0b d0	 or	 rdx, rax
  005df	48 c1 e2 04	 shl	 rdx, 4
  005e3	48 0f be 41 09	 movsx	 rax, BYTE PTR [rcx+9]
  005e8	83 e0 0f	 and	 eax, 15
  005eb	48 0b d0	 or	 rdx, rax
  005ee	48 c1 e2 04	 shl	 rdx, 4
  005f2	48 0f be 41 0a	 movsx	 rax, BYTE PTR [rcx+10]
  005f7	83 e0 0f	 and	 eax, 15
  005fa	48 0b d0	 or	 rdx, rax
  005fd	48 c1 e2 04	 shl	 rdx, 4
  00601	48 0f be 41 0b	 movsx	 rax, BYTE PTR [rcx+11]
  00606	83 e0 0f	 and	 eax, 15
  00609	48 0b d0	 or	 rdx, rax
  0060c	48 c1 e2 04	 shl	 rdx, 4
  00610	48 0f be 41 0c	 movsx	 rax, BYTE PTR [rcx+12]
  00615	83 e0 0f	 and	 eax, 15
  00618	48 0b d0	 or	 rdx, rax
  0061b	48 c1 e2 04	 shl	 rdx, 4
  0061f	48 0f be 41 0d	 movsx	 rax, BYTE PTR [rcx+13]
  00624	83 e0 0f	 and	 eax, 15
  00627	48 0b d0	 or	 rdx, rax
  0062a	48 c1 e2 04	 shl	 rdx, 4
  0062e	48 0f be 41 0e	 movsx	 rax, BYTE PTR [rcx+14]
  00633	83 e0 0f	 and	 eax, 15
  00636	48 0b d0	 or	 rdx, rax
  00639	48 c1 e2 04	 shl	 rdx, 4
  0063d	48 0f be 41 0f	 movsx	 rax, BYTE PTR [rcx+15]
  00642	83 e0 0f	 and	 eax, 15
  00645	48 0b d0	 or	 rdx, rax
$LN10@main:

; 859  : 			| (((uint64_t)argv[2][1] << 56) & 0x0F00000000000000)
; 860  : 			| (((uint64_t)argv[2][2] << 52) & 0x00F0000000000000)
; 861  : 			| (((uint64_t)argv[2][3] << 48) & 0x000F000000000000)
; 862  : 			| (((uint64_t)argv[2][4] << 44) & 0x0000F00000000000)
; 863  : 			| (((uint64_t)argv[2][5] << 40) & 0x00000F0000000000)
; 864  : 			| (((uint64_t)argv[2][6] << 36) & 0x000000F000000000)
; 865  : 			| (((uint64_t)argv[2][7] << 32) & 0x0000000F00000000)
; 866  : 			| (((uint64_t)argv[2][8] << 28) & 0x00000000F0000000)
; 867  : 			| (((uint64_t)argv[2][9] << 24) & 0x000000000F000000)
; 868  : 			| (((uint64_t)argv[2][10]<< 20) & 0x0000000000F00000)
; 869  : 			| (((uint64_t)argv[2][11]<< 16) & 0x00000000000F0000)
; 870  : 			| (((uint64_t)argv[2][12]<< 12) & 0x000000000000F000)
; 871  : 			| (((uint64_t)argv[2][13]<< 8)  & 0x0000000000000F00)
; 872  : 			| (((uint64_t)argv[2][14]<< 4)  & 0x00000000000000F0)
; 873  : 			| (((uint64_t)argv[2][15])		& 0x000000000000000F);
; 874  : 	}
; 875  : 	uint64_t weakKey1 = 0x0000000000000000;
; 876  : 	uint64_t weakKey2 = 0xFFFFFFFFFFFFFFFF;
; 877  : 	uint64_t weakKey3 = 0xFFFFFFFF00000000;
; 878  : 	uint64_t weakKey4 = 0x00000000FFFFFFFF;
; 879  : 	if (key == weakKey1 || key == weakKey2 || key == weakKey3 || key == weakKey4)

  00648	48 85 d2	 test	 rdx, rdx
  0064b	0f 84 bb 14 00
	00		 je	 $LN108@main
  00651	48 83 fa ff	 cmp	 rdx, -1
  00655	0f 84 b1 14 00
	00		 je	 $LN108@main
  0065b	48 b8 00 00 00
	00 ff ff ff ff	 mov	 rax, -4294967296	; ffffffff00000000H
  00665	48 3b d0	 cmp	 rdx, rax
  00668	0f 84 9e 14 00
	00		 je	 $LN108@main
  0066e	b8 ff ff ff ff	 mov	 eax, -1			; ffffffffH
  00673	48 3b d0	 cmp	 rdx, rax
  00676	0f 84 90 14 00
	00		 je	 $LN108@main

; 882  : 	}
; 883  : 
; 884  : 	//17 because k_0 is the first permuted key from the original
; 885  : 	// the remaining 16 are for the 16 rounds
; 886  : 
; 887  : 	//This part compresses the key into k_0
; 888  : 	if (key & (1ULL << 63)) keys[0] |= (1ULL << (56 - 8)); //bit 1

  0067c	48 b8 00 00 00
	00 00 00 00 80	 mov	 rax, -9223372036854775808 ; 8000000000000000H
  00686	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?keys@@3PA_KA
  0068d	48 85 d0	 test	 rdx, rax
  00690	74 14		 je	 SHORT $LN109@main
  00692	48 b8 00 00 00
	00 00 00 01 00	 mov	 rax, 281474976710656	; 0001000000000000H
  0069c	48 0b c8	 or	 rcx, rax
  0069f	48 89 0d 00 00
	00 00		 mov	 QWORD PTR ?keys@@3PA_KA, rcx
$LN109@main:

; 889  : 	if (key & (1ULL << 62)) keys[0] |= (1ULL << (56 - 16));  //bit 2

  006a6	48 b8 00 00 00
	00 00 00 00 40	 mov	 rax, 4611686018427387904 ; 4000000000000000H
  006b0	48 85 d0	 test	 rdx, rax
  006b3	74 14		 je	 SHORT $LN110@main
  006b5	48 b8 00 00 00
	00 00 01 00 00	 mov	 rax, 1099511627776	; 0000010000000000H
  006bf	48 0b c8	 or	 rcx, rax
  006c2	48 89 0d 00 00
	00 00		 mov	 QWORD PTR ?keys@@3PA_KA, rcx
$LN110@main:

; 890  : 	if (key & (1ULL << 61)) keys[0] |= (1ULL << (56 - 24)); //bit 3

  006c9	48 b8 00 00 00
	00 00 00 00 20	 mov	 rax, 2305843009213693952 ; 2000000000000000H
  006d3	48 85 d0	 test	 rdx, rax
  006d6	74 14		 je	 SHORT $LN111@main
  006d8	48 b8 00 00 00
	00 01 00 00 00	 mov	 rax, 4294967296		; 0000000100000000H
  006e2	48 0b c8	 or	 rcx, rax
  006e5	48 89 0d 00 00
	00 00		 mov	 QWORD PTR ?keys@@3PA_KA, rcx
$LN111@main:

; 891  : 	if (key & (1ULL << 60)) keys[0] |= (1ULL << (56 - 56)); //bit 4

  006ec	48 b8 00 00 00
	00 00 00 00 10	 mov	 rax, 1152921504606846976 ; 1000000000000000H
  006f6	48 85 d0	 test	 rdx, rax
  006f9	74 0b		 je	 SHORT $LN112@main
  006fb	48 83 c9 01	 or	 rcx, 1
  006ff	48 89 0d 00 00
	00 00		 mov	 QWORD PTR ?keys@@3PA_KA, rcx
$LN112@main:

; 892  : 	if (key & (1ULL << 59)) keys[0] |= (1ULL << (56 - 52)); //bit 5

  00706	48 b8 00 00 00
	00 00 00 00 08	 mov	 rax, 576460752303423488	; 0800000000000000H
  00710	48 85 d0	 test	 rdx, rax
  00713	74 0b		 je	 SHORT $LN113@main
  00715	48 83 c9 10	 or	 rcx, 16
  00719	48 89 0d 00 00
	00 00		 mov	 QWORD PTR ?keys@@3PA_KA, rcx
$LN113@main:

; 893  : 	if (key & (1ULL << 58)) keys[0] |= (1ULL << (56 - 44)); //bit 6

  00720	48 b8 00 00 00
	00 00 00 00 04	 mov	 rax, 288230376151711744	; 0400000000000000H
  0072a	48 85 d0	 test	 rdx, rax
  0072d	74 0c		 je	 SHORT $LN114@main
  0072f	48 0f ba e9 0c	 bts	 rcx, 12
  00734	48 89 0d 00 00
	00 00		 mov	 QWORD PTR ?keys@@3PA_KA, rcx
$LN114@main:

; 894  : 	if (key & (1ULL << 57)) keys[0] |= (1ULL << (56 - 36)); //bit 7

  0073b	48 b8 00 00 00
	00 00 00 00 02	 mov	 rax, 144115188075855872	; 0200000000000000H
  00745	48 85 d0	 test	 rdx, rax
  00748	74 0c		 je	 SHORT $LN115@main
  0074a	48 0f ba e9 14	 bts	 rcx, 20
  0074f	48 89 0d 00 00
	00 00		 mov	 QWORD PTR ?keys@@3PA_KA, rcx
$LN115@main:

; 895  : 	//if (key & (1ULL << 56)) key |= (1ULL << (56 - 32)); //bit 8
; 896  : 	if (key & (1ULL << 55)) keys[0] |= (1ULL << (56 - 7)); //bit 9

  00756	48 b8 00 00 00
	00 00 00 02 00	 mov	 rax, 562949953421312	; 0002000000000000H
  00760	49 b8 00 00 00
	00 00 00 80 00	 mov	 r8, 36028797018963968	; 0080000000000000H
  0076a	49 85 d0	 test	 rdx, r8
  0076d	74 0a		 je	 SHORT $LN116@main
  0076f	48 0b c8	 or	 rcx, rax
  00772	48 89 0d 00 00
	00 00		 mov	 QWORD PTR ?keys@@3PA_KA, rcx
$LN116@main:

; 897  : 	if (key & (1ULL << 54)) keys[0] |= (1ULL << (56 - 15)); //bit 10

  00779	49 b8 00 00 00
	00 00 00 40 00	 mov	 r8, 18014398509481984	; 0040000000000000H
  00783	49 b9 00 00 00
	00 00 02 00 00	 mov	 r9, 2199023255552	; 0000020000000000H
  0078d	49 85 d0	 test	 rdx, r8
  00790	74 0a		 je	 SHORT $LN117@main
  00792	49 0b c9	 or	 rcx, r9
  00795	48 89 0d 00 00
	00 00		 mov	 QWORD PTR ?keys@@3PA_KA, rcx
$LN117@main:

; 898  : 	if (key & (1ULL << 53)) keys[0] |= (1ULL << (56 - 23)); //bit 11

  0079c	48 bf 00 00 00
	00 02 00 00 00	 mov	 rdi, 8589934592		; 0000000200000000H
  007a6	49 bf 00 00 00
	00 00 00 20 00	 mov	 r15, 9007199254740992	; 0020000000000000H
  007b0	49 85 d7	 test	 rdx, r15
  007b3	74 0a		 je	 SHORT $LN118@main
  007b5	48 0b cf	 or	 rcx, rdi
  007b8	48 89 0d 00 00
	00 00		 mov	 QWORD PTR ?keys@@3PA_KA, rcx
$LN118@main:

; 899  : 	if (key & (1ULL << 52)) keys[0] |= (1ULL << (56 - 55)); //bit 12

  007bf	48 be 00 00 00
	00 00 00 10 00	 mov	 rsi, 4503599627370496	; 0010000000000000H
  007c9	48 85 d6	 test	 rdx, rsi
  007cc	74 0b		 je	 SHORT $LN119@main
  007ce	48 83 c9 02	 or	 rcx, 2
  007d2	48 89 0d 00 00
	00 00		 mov	 QWORD PTR ?keys@@3PA_KA, rcx
$LN119@main:

; 900  : 	if (key & (1ULL << 51)) keys[0] |= (1ULL << (56 - 51)); //bit 13

  007d9	49 ba 00 00 00
	00 00 00 08 00	 mov	 r10, 2251799813685248	; 0008000000000000H
  007e3	49 85 d2	 test	 rdx, r10
  007e6	74 0b		 je	 SHORT $LN120@main
  007e8	48 83 c9 20	 or	 rcx, 32			; 00000020H
  007ec	48 89 0d 00 00
	00 00		 mov	 QWORD PTR ?keys@@3PA_KA, rcx
$LN120@main:

; 901  : 	if (key & (1ULL << 50)) keys[0] |= (1ULL << (56 - 43)); //bit 14

  007f3	49 b8 00 00 00
	00 00 00 04 00	 mov	 r8, 1125899906842624	; 0004000000000000H
  007fd	49 85 d0	 test	 rdx, r8
  00800	74 0c		 je	 SHORT $LN121@main
  00802	48 0f ba e9 0d	 bts	 rcx, 13
  00807	48 89 0d 00 00
	00 00		 mov	 QWORD PTR ?keys@@3PA_KA, rcx
$LN121@main:

; 902  : 	if (key & (1ULL << 49)) keys[0] |= (1ULL << (56 - 35)); //bit 15

  0080e	48 85 d0	 test	 rdx, rax
  00811	74 0c		 je	 SHORT $LN122@main
  00813	48 0f ba e9 15	 bts	 rcx, 21
  00818	48 89 0d 00 00
	00 00		 mov	 QWORD PTR ?keys@@3PA_KA, rcx
$LN122@main:

; 903  : 	//if (key & (1ULL << 48)) key |= (1ULL << (56 - 31)); //bit 16
; 904  : 	if (key & (1ULL << 47)) keys[0] |= (1ULL << (56 - 6)); //bit 17

  0081f	48 b8 00 00 00
	00 00 80 00 00	 mov	 rax, 140737488355328	; 0000800000000000H
  00829	48 85 d0	 test	 rdx, rax
  0082c	74 0a		 je	 SHORT $LN123@main
  0082e	49 0b c8	 or	 rcx, r8
  00831	48 89 0d 00 00
	00 00		 mov	 QWORD PTR ?keys@@3PA_KA, rcx
$LN123@main:

; 905  : 	if (key & (1ULL << 46)) keys[0] |= (1ULL << (56 - 14)); //bit 18

  00838	48 b8 00 00 00
	00 00 04 00 00	 mov	 rax, 4398046511104	; 0000040000000000H
  00842	49 bd 00 00 00
	00 00 40 00 00	 mov	 r13, 70368744177664	; 0000400000000000H
  0084c	49 85 d5	 test	 rdx, r13
  0084f	74 0a		 je	 SHORT $LN124@main
  00851	48 0b c8	 or	 rcx, rax
  00854	48 89 0d 00 00
	00 00		 mov	 QWORD PTR ?keys@@3PA_KA, rcx
$LN124@main:

; 906  : 	if (key & (1ULL << 45)) keys[0] |= (1ULL << (56 - 22)); //bit 19

  0085b	49 be 00 00 00
	00 00 20 00 00	 mov	 r14, 35184372088832	; 0000200000000000H
  00865	49 bb 00 00 00
	00 04 00 00 00	 mov	 r11, 17179869184	; 0000000400000000H
  0086f	49 85 d6	 test	 rdx, r14
  00872	74 0a		 je	 SHORT $LN125@main
  00874	49 0b cb	 or	 rcx, r11
  00877	48 89 0d 00 00
	00 00		 mov	 QWORD PTR ?keys@@3PA_KA, rcx
$LN125@main:

; 907  : 	if (key & (1ULL << 44)) keys[0] |= (1ULL << (56 - 54)); //bit 20

  0087e	48 bb 00 00 00
	00 00 10 00 00	 mov	 rbx, 17592186044416	; 0000100000000000H
  00888	48 85 d3	 test	 rdx, rbx
  0088b	74 0b		 je	 SHORT $LN126@main
  0088d	48 83 c9 04	 or	 rcx, 4
  00891	48 89 0d 00 00
	00 00		 mov	 QWORD PTR ?keys@@3PA_KA, rcx
$LN126@main:

; 908  : 	if (key & (1ULL << 43)) keys[0] |= (1ULL << (56 - 50)); //bit 21

  00898	49 b8 00 00 00
	00 00 08 00 00	 mov	 r8, 8796093022208	; 0000080000000000H
  008a2	49 85 d0	 test	 rdx, r8
  008a5	74 0b		 je	 SHORT $LN127@main
  008a7	48 83 c9 40	 or	 rcx, 64			; 00000040H
  008ab	48 89 0d 00 00
	00 00		 mov	 QWORD PTR ?keys@@3PA_KA, rcx
$LN127@main:

; 909  : 	if (key & (1ULL << 42)) keys[0] |= (1ULL << (56 - 42)); //bit 22

  008b2	48 85 d0	 test	 rdx, rax
  008b5	74 0c		 je	 SHORT $LN128@main
  008b7	48 0f ba e9 0e	 bts	 rcx, 14
  008bc	48 89 0d 00 00
	00 00		 mov	 QWORD PTR ?keys@@3PA_KA, rcx
$LN128@main:

; 910  : 	if (key & (1ULL << 41)) keys[0] |= (1ULL << (56 - 34)); //bit 23

  008c3	49 85 d1	 test	 rdx, r9
  008c6	74 0c		 je	 SHORT $LN129@main
  008c8	48 0f ba e9 16	 bts	 rcx, 22
  008cd	48 89 0d 00 00
	00 00		 mov	 QWORD PTR ?keys@@3PA_KA, rcx
$LN129@main:

; 911  : 	//if (key & (1ULL << 40)) key |= (1ULL << (56 - 30)); //bit 24
; 912  : 	if (key & (1ULL << 39)) keys[0] |= (1ULL << (56 - 5)); //bit 25

  008d4	49 bc 00 00 00
	00 80 00 00 00	 mov	 r12, 549755813888	; 0000008000000000H
  008de	49 85 d4	 test	 rdx, r12
  008e1	74 0a		 je	 SHORT $LN130@main
  008e3	49 0b ca	 or	 rcx, r10
  008e6	48 89 0d 00 00
	00 00		 mov	 QWORD PTR ?keys@@3PA_KA, rcx
$LN130@main:

; 913  : 	if (key & (1ULL << 38)) keys[0] |= (1ULL << (56 - 13)); //bit 26

  008ed	49 ba 00 00 00
	00 40 00 00 00	 mov	 r10, 274877906944	; 0000004000000000H
  008f7	49 85 d2	 test	 rdx, r10
  008fa	74 0a		 je	 SHORT $LN131@main
  008fc	49 0b c8	 or	 rcx, r8
  008ff	48 89 0d 00 00
	00 00		 mov	 QWORD PTR ?keys@@3PA_KA, rcx
$LN131@main:

; 914  : 	if (key & (1ULL << 37)) keys[0] |= (1ULL << (56 - 21)); //bit 27

  00906	48 b8 00 00 00
	00 08 00 00 00	 mov	 rax, 34359738368	; 0000000800000000H
  00910	49 b9 00 00 00
	00 20 00 00 00	 mov	 r9, 137438953472	; 0000002000000000H
  0091a	49 85 d1	 test	 rdx, r9
  0091d	74 0a		 je	 SHORT $LN132@main
  0091f	48 0b c8	 or	 rcx, rax
  00922	48 89 0d 00 00
	00 00		 mov	 QWORD PTR ?keys@@3PA_KA, rcx
$LN132@main:

; 915  : 	if (key & (1ULL << 36)) keys[0] |= (1ULL << (56 - 53)); //bit 28

  00929	49 b8 00 00 00
	00 10 00 00 00	 mov	 r8, 68719476736		; 0000001000000000H
  00933	49 85 d0	 test	 rdx, r8
  00936	74 0b		 je	 SHORT $LN133@main
  00938	48 83 c9 08	 or	 rcx, 8
  0093c	48 89 0d 00 00
	00 00		 mov	 QWORD PTR ?keys@@3PA_KA, rcx
$LN133@main:

; 916  : 	if (key & (1ULL << 35)) keys[0] |= (1ULL << (56 - 49)); //bit 29

  00943	48 85 d0	 test	 rdx, rax
  00946	74 0c		 je	 SHORT $LN134@main
  00948	48 0f ba e9 07	 bts	 rcx, 7
  0094d	48 89 0d 00 00
	00 00		 mov	 QWORD PTR ?keys@@3PA_KA, rcx
$LN134@main:

; 917  : 	if (key & (1ULL << 34)) keys[0] |= (1ULL << (56 - 41)); //bit 30

  00954	49 85 d3	 test	 rdx, r11
  00957	74 0c		 je	 SHORT $LN135@main
  00959	48 0f ba e9 0f	 bts	 rcx, 15
  0095e	48 89 0d 00 00
	00 00		 mov	 QWORD PTR ?keys@@3PA_KA, rcx
$LN135@main:

; 918  : 	if (key & (1ULL << 33)) keys[0] |= (1ULL << (56 - 33)); //bit 31

  00965	48 85 d7	 test	 rdx, rdi
  00968	74 0c		 je	 SHORT $LN136@main
  0096a	48 0f ba e9 17	 bts	 rcx, 23
  0096f	48 89 0d 00 00
	00 00		 mov	 QWORD PTR ?keys@@3PA_KA, rcx
$LN136@main:

; 919  : 	//if (key & (1ULL << 32)) key |= (1ULL << (56 - 29)); //bit 32
; 920  : 	if (key & (1ULL << 31)) keys[0] |= (1ULL << (56 - 4)); //bit 33

  00976	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  0097b	48 85 d0	 test	 rdx, rax
  0097e	74 0a		 je	 SHORT $LN137@main
  00980	48 0b ce	 or	 rcx, rsi
  00983	48 89 0d 00 00
	00 00		 mov	 QWORD PTR ?keys@@3PA_KA, rcx
$LN137@main:

; 921  : 	if (key & (1ULL << 30)) keys[0] |= (1ULL << (56 - 12)); //bit 34

  0098a	48 0f ba e2 1e	 bt	 rdx, 30
  0098f	73 0a		 jae	 SHORT $LN138@main
  00991	48 0b cb	 or	 rcx, rbx
  00994	48 89 0d 00 00
	00 00		 mov	 QWORD PTR ?keys@@3PA_KA, rcx
$LN138@main:

; 922  : 	if (key & (1ULL << 29)) keys[0] |= (1ULL << (56 - 20)); //bit 35

  0099b	48 0f ba e2 1d	 bt	 rdx, 29
  009a0	73 0a		 jae	 SHORT $LN139@main
  009a2	49 0b c8	 or	 rcx, r8
  009a5	48 89 0d 00 00
	00 00		 mov	 QWORD PTR ?keys@@3PA_KA, rcx
$LN139@main:

; 923  : 	if (key & (1ULL << 28)) keys[0] |= (1ULL << (56 - 28)); //bit 36

  009ac	48 0f ba e2 1c	 bt	 rdx, 28
  009b1	73 0c		 jae	 SHORT $LN140@main
  009b3	48 0f ba e9 1c	 bts	 rcx, 28
  009b8	48 89 0d 00 00
	00 00		 mov	 QWORD PTR ?keys@@3PA_KA, rcx
$LN140@main:

; 924  : 	if (key & (1ULL << 27)) keys[0] |= (1ULL << (56 - 48)); //bit 37

  009bf	48 0f ba e2 1b	 bt	 rdx, 27
  009c4	73 0c		 jae	 SHORT $LN141@main
  009c6	48 0f ba e9 08	 bts	 rcx, 8
  009cb	48 89 0d 00 00
	00 00		 mov	 QWORD PTR ?keys@@3PA_KA, rcx
$LN141@main:

; 925  : 	if (key & (1ULL << 26)) keys[0] |= (1ULL << (56 - 40)); //bit 38

  009d2	48 0f ba e2 1a	 bt	 rdx, 26
  009d7	73 0c		 jae	 SHORT $LN142@main
  009d9	48 0f ba e9 10	 bts	 rcx, 16
  009de	48 89 0d 00 00
	00 00		 mov	 QWORD PTR ?keys@@3PA_KA, rcx
$LN142@main:

; 926  : 	if (key & (1ULL << 25)) keys[0] |= (1ULL << (56 - 32)); //bit 39

  009e5	48 0f ba e2 19	 bt	 rdx, 25
  009ea	73 0c		 jae	 SHORT $LN143@main
  009ec	48 0f ba e9 18	 bts	 rcx, 24
  009f1	48 89 0d 00 00
	00 00		 mov	 QWORD PTR ?keys@@3PA_KA, rcx
$LN143@main:

; 927  : 	//if (key & (1ULL << 24)) key |= (1ULL << (56 - 28)); //bit 40
; 928  : 	if (key & (1ULL << 23)) keys[0] |= (1ULL << (56 - 3)); //bit 41

  009f8	48 0f ba e2 17	 bt	 rdx, 23
  009fd	73 0a		 jae	 SHORT $LN144@main
  009ff	49 0b cf	 or	 rcx, r15
  00a02	48 89 0d 00 00
	00 00		 mov	 QWORD PTR ?keys@@3PA_KA, rcx
$LN144@main:

; 929  : 	if (key & (1ULL << 22)) keys[0] |= (1ULL << (56 - 11)); //bit 42

  00a09	48 0f ba e2 16	 bt	 rdx, 22
  00a0e	73 0a		 jae	 SHORT $LN145@main
  00a10	49 0b ce	 or	 rcx, r14
  00a13	48 89 0d 00 00
	00 00		 mov	 QWORD PTR ?keys@@3PA_KA, rcx
$LN145@main:

; 930  : 	if (key & (1ULL << 21)) keys[0] |= (1ULL << (56 - 19)); //bit 43

  00a1a	48 0f ba e2 15	 bt	 rdx, 21
  00a1f	73 0a		 jae	 SHORT $LN146@main
  00a21	49 0b c9	 or	 rcx, r9
  00a24	48 89 0d 00 00
	00 00		 mov	 QWORD PTR ?keys@@3PA_KA, rcx
$LN146@main:

; 931  : 	if (key & (1ULL << 20)) keys[0] |= (1ULL << (56 - 27)); //bit 44

  00a2b	48 0f ba e2 14	 bt	 rdx, 20
  00a30	73 0c		 jae	 SHORT $LN147@main
  00a32	48 0f ba e9 1d	 bts	 rcx, 29
  00a37	48 89 0d 00 00
	00 00		 mov	 QWORD PTR ?keys@@3PA_KA, rcx
$LN147@main:

; 932  : 	if (key & (1ULL << 19)) keys[0] |= (1ULL << (56 - 47)); //bit 45

  00a3e	48 0f ba e2 13	 bt	 rdx, 19
  00a43	73 0c		 jae	 SHORT $LN148@main
  00a45	48 0f ba e9 09	 bts	 rcx, 9
  00a4a	48 89 0d 00 00
	00 00		 mov	 QWORD PTR ?keys@@3PA_KA, rcx
$LN148@main:

; 933  : 	if (key & (1ULL << 18)) keys[0] |= (1ULL << (56 - 39)); //bit 46

  00a51	48 0f ba e2 12	 bt	 rdx, 18
  00a56	73 0c		 jae	 SHORT $LN149@main
  00a58	48 0f ba e9 11	 bts	 rcx, 17
  00a5d	48 89 0d 00 00
	00 00		 mov	 QWORD PTR ?keys@@3PA_KA, rcx
$LN149@main:

; 934  : 	if (key & (1ULL << 17)) keys[0] |= (1ULL << (56 - 31)); //bit 47

  00a64	48 0f ba e2 11	 bt	 rdx, 17
  00a69	73 0c		 jae	 SHORT $LN150@main
  00a6b	48 0f ba e9 19	 bts	 rcx, 25
  00a70	48 89 0d 00 00
	00 00		 mov	 QWORD PTR ?keys@@3PA_KA, rcx
$LN150@main:

; 935  : 	//if (key & (1ULL << 16)) key |= (1ULL << (56 - 27)); //bit 48
; 936  : 	if (key & (1ULL << 15)) keys[0] |= (1ULL << (56 - 2)); //bit 49

  00a77	48 0f ba e2 0f	 bt	 rdx, 15
  00a7c	73 14		 jae	 SHORT $LN151@main
  00a7e	49 b8 00 00 00
	00 00 00 40 00	 mov	 r8, 18014398509481984	; 0040000000000000H
  00a88	49 0b c8	 or	 rcx, r8
  00a8b	48 89 0d 00 00
	00 00		 mov	 QWORD PTR ?keys@@3PA_KA, rcx
$LN151@main:

; 937  : 	if (key & (1ULL << 14)) keys[0] |= (1ULL << (56 - 10)); //bit 50

  00a92	48 0f ba e2 0e	 bt	 rdx, 14
  00a97	73 0a		 jae	 SHORT $LN152@main
  00a99	49 0b cd	 or	 rcx, r13
  00a9c	48 89 0d 00 00
	00 00		 mov	 QWORD PTR ?keys@@3PA_KA, rcx
$LN152@main:

; 938  : 	if (key & (1ULL << 13)) keys[0] |= (1ULL << (56 - 18)); //bit 51

  00aa3	48 0f ba e2 0d	 bt	 rdx, 13
  00aa8	73 0a		 jae	 SHORT $LN153@main
  00aaa	49 0b ca	 or	 rcx, r10
  00aad	48 89 0d 00 00
	00 00		 mov	 QWORD PTR ?keys@@3PA_KA, rcx
$LN153@main:

; 939  : 	if (key & (1ULL << 12)) keys[0] |= (1ULL << (56 - 26)); //bit 52

  00ab4	48 0f ba e2 0c	 bt	 rdx, 12
  00ab9	73 0c		 jae	 SHORT $LN154@main
  00abb	48 0f ba e9 1e	 bts	 rcx, 30
  00ac0	48 89 0d 00 00
	00 00		 mov	 QWORD PTR ?keys@@3PA_KA, rcx
$LN154@main:

; 940  : 	if (key & (1ULL << 11)) keys[0] |= (1ULL << (56 - 46)); //bit 53

  00ac7	48 0f ba e2 0b	 bt	 rdx, 11
  00acc	73 0c		 jae	 SHORT $LN155@main
  00ace	48 0f ba e9 0a	 bts	 rcx, 10
  00ad3	48 89 0d 00 00
	00 00		 mov	 QWORD PTR ?keys@@3PA_KA, rcx
$LN155@main:

; 941  : 	if (key & (1ULL << 10)) keys[0] |= (1ULL << (56 - 38)); //bit 54

  00ada	48 0f ba e2 0a	 bt	 rdx, 10
  00adf	73 0c		 jae	 SHORT $LN156@main
  00ae1	48 0f ba e9 12	 bts	 rcx, 18
  00ae6	48 89 0d 00 00
	00 00		 mov	 QWORD PTR ?keys@@3PA_KA, rcx
$LN156@main:

; 942  : 	if (key & (1ULL << 9))  keys[0] |= (1ULL << (56 - 30)); //bit 55

  00aed	48 0f ba e2 09	 bt	 rdx, 9
  00af2	73 0c		 jae	 SHORT $LN157@main
  00af4	48 0f ba e9 1a	 bts	 rcx, 26
  00af9	48 89 0d 00 00
	00 00		 mov	 QWORD PTR ?keys@@3PA_KA, rcx
$LN157@main:

; 943  : 	//if (key & (1ULL << 8))  key |= (1ULL << (56 - 26)); //bit 56
; 944  : 	if (key & (1ULL << 7))  keys[0] |= (1ULL << (56 - 1)); //bit 57

  00b00	84 d2		 test	 dl, dl
  00b02	79 14		 jns	 SHORT $LN158@main
  00b04	49 b8 00 00 00
	00 00 00 80 00	 mov	 r8, 36028797018963968	; 0080000000000000H
  00b0e	49 0b c8	 or	 rcx, r8
  00b11	48 89 0d 00 00
	00 00		 mov	 QWORD PTR ?keys@@3PA_KA, rcx
$LN158@main:

; 945  : 	if (key & (1ULL << 6))  keys[0] |= (1ULL << (56 - 9));  //bit 58

  00b18	f6 c2 40	 test	 dl, 64			; 00000040H
  00b1b	74 14		 je	 SHORT $LN159@main
  00b1d	49 b8 00 00 00
	00 00 80 00 00	 mov	 r8, 140737488355328	; 0000800000000000H
  00b27	49 0b c8	 or	 rcx, r8
  00b2a	48 89 0d 00 00
	00 00		 mov	 QWORD PTR ?keys@@3PA_KA, rcx
$LN159@main:

; 946  : 	if (key & (1ULL << 5))  keys[0] |= (1ULL << (56 - 17)); //bit 59

  00b31	f6 c2 20	 test	 dl, 32			; 00000020H
  00b34	74 0a		 je	 SHORT $LN160@main
  00b36	49 0b cc	 or	 rcx, r12
  00b39	48 89 0d 00 00
	00 00		 mov	 QWORD PTR ?keys@@3PA_KA, rcx
$LN160@main:

; 947  : 	if (key & (1ULL << 4))  keys[0] |= (1ULL << (56 - 25)); //bit 60

  00b40	f6 c2 10	 test	 dl, 16
  00b43	74 0a		 je	 SHORT $LN161@main
  00b45	48 0b c8	 or	 rcx, rax
  00b48	48 89 0d 00 00
	00 00		 mov	 QWORD PTR ?keys@@3PA_KA, rcx
$LN161@main:

; 948  : 	if (key & (1ULL << 3))  keys[0] |= (1ULL << (56 - 45)); //bit 61

  00b4f	f6 c2 08	 test	 dl, 8
  00b52	74 0c		 je	 SHORT $LN162@main
  00b54	48 0f ba e9 0b	 bts	 rcx, 11
  00b59	48 89 0d 00 00
	00 00		 mov	 QWORD PTR ?keys@@3PA_KA, rcx
$LN162@main:

; 949  : 	if (key & (1ULL << 2))  keys[0] |= (1ULL << (56 - 37)); //bit 62

  00b60	f6 c2 04	 test	 dl, 4
  00b63	74 0c		 je	 SHORT $LN163@main
  00b65	48 0f ba e9 13	 bts	 rcx, 19
  00b6a	48 89 0d 00 00
	00 00		 mov	 QWORD PTR ?keys@@3PA_KA, rcx
$LN163@main:

; 950  : 	if (key & (1ULL << 1))  keys[0] |= (1ULL << (56 - 29)); //bit 63

  00b71	f6 c2 02	 test	 dl, 2
  00b74	74 0c		 je	 SHORT $LN164@main
  00b76	48 0f ba e9 1b	 bts	 rcx, 27
  00b7b	48 89 0d 00 00
	00 00		 mov	 QWORD PTR ?keys@@3PA_KA, rcx
$LN164@main:

; 951  : 	//if (key & (1ULL << 0))  key |= (1ULL << (56 - 25)); //bit 64
; 952  : 
; 953  : 	//We want to compute the 16 keys that we will use for encrypting/decrypting
; 954  : 	//ROUNDS 1,2,9,16 rotate 1 bit
; 955  : 	//ROUNDS 3,4,5,6,7,8,10,11,12,13,14,15 all rotate 2 bits
; 956  : 	keys[1] = rotateBits(keys[0], 1);

  00b82	ba 01 00 00 00	 mov	 edx, 1
  00b87	e8 00 00 00 00	 call	 ?rotateBits@@YA_K_KH@Z	; rotateBits
  00b8c	48 8b d8	 mov	 rbx, rax

; 957  : 	keys[2] = rotateBits(keys[1], 2);

  00b8f	ba 02 00 00 00	 mov	 edx, 2
  00b94	48 8b c8	 mov	 rcx, rax
  00b97	e8 00 00 00 00	 call	 ?rotateBits@@YA_K_KH@Z	; rotateBits
  00b9c	48 8b f8	 mov	 rdi, rax

; 958  : 	keys[3] = rotateBits(keys[2], 3);

  00b9f	ba 03 00 00 00	 mov	 edx, 3
  00ba4	48 8b c8	 mov	 rcx, rax
  00ba7	e8 00 00 00 00	 call	 ?rotateBits@@YA_K_KH@Z	; rotateBits
  00bac	48 8b f0	 mov	 rsi, rax

; 959  : 	keys[4] = rotateBits(keys[3], 4);

  00baf	ba 04 00 00 00	 mov	 edx, 4
  00bb4	48 8b c8	 mov	 rcx, rax
  00bb7	e8 00 00 00 00	 call	 ?rotateBits@@YA_K_KH@Z	; rotateBits
  00bbc	4c 8b f0	 mov	 r14, rax

; 960  : 	keys[5] = rotateBits(keys[4], 5);

  00bbf	ba 05 00 00 00	 mov	 edx, 5
  00bc4	48 8b c8	 mov	 rcx, rax
  00bc7	e8 00 00 00 00	 call	 ?rotateBits@@YA_K_KH@Z	; rotateBits
  00bcc	4c 8b f8	 mov	 r15, rax

; 961  : 	keys[6] = rotateBits(keys[5], 6);

  00bcf	ba 06 00 00 00	 mov	 edx, 6
  00bd4	48 8b c8	 mov	 rcx, rax
  00bd7	e8 00 00 00 00	 call	 ?rotateBits@@YA_K_KH@Z	; rotateBits
  00bdc	4c 8b e0	 mov	 r12, rax

; 962  : 	keys[7] = rotateBits(keys[6], 7);

  00bdf	ba 07 00 00 00	 mov	 edx, 7
  00be4	48 8b c8	 mov	 rcx, rax
  00be7	e8 00 00 00 00	 call	 ?rotateBits@@YA_K_KH@Z	; rotateBits
  00bec	4c 8b e8	 mov	 r13, rax

; 963  : 	keys[8] = rotateBits(keys[7], 8);

  00bef	ba 08 00 00 00	 mov	 edx, 8
  00bf4	48 8b c8	 mov	 rcx, rax
  00bf7	e8 00 00 00 00	 call	 ?rotateBits@@YA_K_KH@Z	; rotateBits
  00bfc	48 89 85 50 02
	00 00		 mov	 QWORD PTR ?keys@@3PA_KA$9[rbp-256], rax

; 964  : 	keys[9] = rotateBits(keys[8], 9);

  00c03	ba 09 00 00 00	 mov	 edx, 9
  00c08	48 8b c8	 mov	 rcx, rax
  00c0b	e8 00 00 00 00	 call	 ?rotateBits@@YA_K_KH@Z	; rotateBits
  00c10	48 89 44 24 50	 mov	 QWORD PTR ?keys@@3PA_KA$10[rsp], rax

; 965  : 	keys[10] = rotateBits(keys[9], 10);

  00c15	ba 0a 00 00 00	 mov	 edx, 10
  00c1a	48 8b c8	 mov	 rcx, rax
  00c1d	e8 00 00 00 00	 call	 ?rotateBits@@YA_K_KH@Z	; rotateBits
  00c22	48 89 44 24 58	 mov	 QWORD PTR ?keys@@3PA_KA$11[rsp], rax

; 966  : 	keys[11] = rotateBits(keys[10], 11);

  00c27	ba 0b 00 00 00	 mov	 edx, 11
  00c2c	48 8b c8	 mov	 rcx, rax
  00c2f	e8 00 00 00 00	 call	 ?rotateBits@@YA_K_KH@Z	; rotateBits
  00c34	48 89 44 24 60	 mov	 QWORD PTR ?keys@@3PA_KA$12[rsp], rax

; 967  : 	keys[12] = rotateBits(keys[11], 12);

  00c39	ba 0c 00 00 00	 mov	 edx, 12
  00c3e	48 8b c8	 mov	 rcx, rax
  00c41	e8 00 00 00 00	 call	 ?rotateBits@@YA_K_KH@Z	; rotateBits
  00c46	48 89 44 24 68	 mov	 QWORD PTR ?keys@@3PA_KA$13[rsp], rax

; 968  : 	keys[13] = rotateBits(keys[12], 13);

  00c4b	ba 0d 00 00 00	 mov	 edx, 13
  00c50	48 8b c8	 mov	 rcx, rax
  00c53	e8 00 00 00 00	 call	 ?rotateBits@@YA_K_KH@Z	; rotateBits
  00c58	48 89 44 24 70	 mov	 QWORD PTR ?keys@@3PA_KA$14[rsp], rax

; 969  : 	keys[14] = rotateBits(keys[13], 14);

  00c5d	ba 0e 00 00 00	 mov	 edx, 14
  00c62	48 8b c8	 mov	 rcx, rax
  00c65	e8 00 00 00 00	 call	 ?rotateBits@@YA_K_KH@Z	; rotateBits
  00c6a	48 89 44 24 40	 mov	 QWORD PTR ?keys@@3PA_KA$15[rsp], rax

; 970  : 	keys[15] = rotateBits(keys[14], 15);

  00c6f	ba 0f 00 00 00	 mov	 edx, 15
  00c74	48 8b c8	 mov	 rcx, rax
  00c77	e8 00 00 00 00	 call	 ?rotateBits@@YA_K_KH@Z	; rotateBits
  00c7c	48 89 44 24 30	 mov	 QWORD PTR ?keys@@3PA_KA$16[rsp], rax

; 971  : 	keys[16] = rotateBits(keys[15], 16);

  00c81	ba 10 00 00 00	 mov	 edx, 16
  00c86	48 8b c8	 mov	 rcx, rax
  00c89	e8 00 00 00 00	 call	 ?rotateBits@@YA_K_KH@Z	; rotateBits
  00c8e	48 89 44 24 20	 mov	 QWORD PTR ?keys@@3PA_KA$17[rsp], rax

; 972  : 
; 973  : 	//After getting the 16 keys, we need to convert them into the permuted 48 bit keys
; 974  : 	// that we actually use in the rounds. Just overwriting the 56bit keys and making sure
; 975  : 	// the top 16 bits are cleared.
; 976  : 	keys[1] = compressPermuteKey(keys[1]) & 0x0000FFFFFFFFFFFF;

  00c93	48 8b cb	 mov	 rcx, rbx
  00c96	e8 00 00 00 00	 call	 ?compressPermuteKey@@YA_K_K@Z ; compressPermuteKey
  00c9b	48 bb ff ff ff
	ff ff ff 00 00	 mov	 rbx, 281474976710655	; 0000ffffffffffffH
  00ca5	48 23 c3	 and	 rax, rbx
  00ca8	48 89 05 08 00
	00 00		 mov	 QWORD PTR ?keys@@3PA_KA+8, rax

; 977  : 	keys[2] = compressPermuteKey(keys[2]) & 0x0000FFFFFFFFFFFF;

  00caf	48 8b cf	 mov	 rcx, rdi
  00cb2	e8 00 00 00 00	 call	 ?compressPermuteKey@@YA_K_K@Z ; compressPermuteKey
  00cb7	48 23 c3	 and	 rax, rbx
  00cba	48 89 05 10 00
	00 00		 mov	 QWORD PTR ?keys@@3PA_KA+16, rax

; 978  : 	keys[3] = compressPermuteKey(keys[3]) & 0x0000FFFFFFFFFFFF;

  00cc1	48 8b ce	 mov	 rcx, rsi
  00cc4	e8 00 00 00 00	 call	 ?compressPermuteKey@@YA_K_K@Z ; compressPermuteKey
  00cc9	48 23 c3	 and	 rax, rbx
  00ccc	48 89 05 18 00
	00 00		 mov	 QWORD PTR ?keys@@3PA_KA+24, rax

; 979  : 	keys[4] = compressPermuteKey(keys[4]) & 0x0000FFFFFFFFFFFF;

  00cd3	49 8b ce	 mov	 rcx, r14
  00cd6	e8 00 00 00 00	 call	 ?compressPermuteKey@@YA_K_K@Z ; compressPermuteKey
  00cdb	48 23 c3	 and	 rax, rbx
  00cde	48 89 05 20 00
	00 00		 mov	 QWORD PTR ?keys@@3PA_KA+32, rax

; 980  : 	keys[5] = compressPermuteKey(keys[5]) & 0x0000FFFFFFFFFFFF;

  00ce5	49 8b cf	 mov	 rcx, r15
  00ce8	e8 00 00 00 00	 call	 ?compressPermuteKey@@YA_K_K@Z ; compressPermuteKey
  00ced	48 23 c3	 and	 rax, rbx
  00cf0	48 89 05 28 00
	00 00		 mov	 QWORD PTR ?keys@@3PA_KA+40, rax

; 981  : 	keys[6] = compressPermuteKey(keys[6]) & 0x0000FFFFFFFFFFFF;

  00cf7	49 8b cc	 mov	 rcx, r12
  00cfa	e8 00 00 00 00	 call	 ?compressPermuteKey@@YA_K_K@Z ; compressPermuteKey
  00cff	48 23 c3	 and	 rax, rbx
  00d02	48 89 05 30 00
	00 00		 mov	 QWORD PTR ?keys@@3PA_KA+48, rax

; 982  : 	keys[7] = compressPermuteKey(keys[7]) & 0x0000FFFFFFFFFFFF;

  00d09	49 8b cd	 mov	 rcx, r13
  00d0c	e8 00 00 00 00	 call	 ?compressPermuteKey@@YA_K_K@Z ; compressPermuteKey
  00d11	48 23 c3	 and	 rax, rbx
  00d14	48 89 05 38 00
	00 00		 mov	 QWORD PTR ?keys@@3PA_KA+56, rax

; 983  : 	keys[8] = compressPermuteKey(keys[8]) & 0x0000FFFFFFFFFFFF;

  00d1b	48 8b 8d 50 02
	00 00		 mov	 rcx, QWORD PTR ?keys@@3PA_KA$9[rbp-256]
  00d22	e8 00 00 00 00	 call	 ?compressPermuteKey@@YA_K_K@Z ; compressPermuteKey
  00d27	48 23 c3	 and	 rax, rbx
  00d2a	48 89 05 40 00
	00 00		 mov	 QWORD PTR ?keys@@3PA_KA+64, rax

; 984  : 	keys[9] = compressPermuteKey(keys[9]) & 0x0000FFFFFFFFFFFF;

  00d31	48 8b 4c 24 50	 mov	 rcx, QWORD PTR ?keys@@3PA_KA$10[rsp]
  00d36	e8 00 00 00 00	 call	 ?compressPermuteKey@@YA_K_K@Z ; compressPermuteKey
  00d3b	48 23 c3	 and	 rax, rbx
  00d3e	48 89 05 48 00
	00 00		 mov	 QWORD PTR ?keys@@3PA_KA+72, rax

; 985  : 	keys[10] = compressPermuteKey(keys[10]) & 0x0000FFFFFFFFFFFF;

  00d45	48 8b 4c 24 58	 mov	 rcx, QWORD PTR ?keys@@3PA_KA$11[rsp]
  00d4a	e8 00 00 00 00	 call	 ?compressPermuteKey@@YA_K_K@Z ; compressPermuteKey
  00d4f	48 23 c3	 and	 rax, rbx
  00d52	48 89 05 50 00
	00 00		 mov	 QWORD PTR ?keys@@3PA_KA+80, rax

; 986  : 	keys[11] = compressPermuteKey(keys[11]) & 0x0000FFFFFFFFFFFF;

  00d59	48 8b 4c 24 60	 mov	 rcx, QWORD PTR ?keys@@3PA_KA$12[rsp]
  00d5e	e8 00 00 00 00	 call	 ?compressPermuteKey@@YA_K_K@Z ; compressPermuteKey
  00d63	48 23 c3	 and	 rax, rbx
  00d66	48 89 05 58 00
	00 00		 mov	 QWORD PTR ?keys@@3PA_KA+88, rax

; 987  : 	keys[12] = compressPermuteKey(keys[12]) & 0x0000FFFFFFFFFFFF;

  00d6d	48 8b 4c 24 68	 mov	 rcx, QWORD PTR ?keys@@3PA_KA$13[rsp]
  00d72	e8 00 00 00 00	 call	 ?compressPermuteKey@@YA_K_K@Z ; compressPermuteKey
  00d77	48 23 c3	 and	 rax, rbx
  00d7a	48 89 05 60 00
	00 00		 mov	 QWORD PTR ?keys@@3PA_KA+96, rax

; 988  : 	keys[13] = compressPermuteKey(keys[13]) & 0x0000FFFFFFFFFFFF;

  00d81	48 8b 4c 24 70	 mov	 rcx, QWORD PTR ?keys@@3PA_KA$14[rsp]
  00d86	e8 00 00 00 00	 call	 ?compressPermuteKey@@YA_K_K@Z ; compressPermuteKey
  00d8b	48 23 c3	 and	 rax, rbx
  00d8e	48 89 05 68 00
	00 00		 mov	 QWORD PTR ?keys@@3PA_KA+104, rax

; 989  : 	keys[14] = compressPermuteKey(keys[14]) & 0x0000FFFFFFFFFFFF;

  00d95	48 8b 4c 24 40	 mov	 rcx, QWORD PTR ?keys@@3PA_KA$15[rsp]
  00d9a	e8 00 00 00 00	 call	 ?compressPermuteKey@@YA_K_K@Z ; compressPermuteKey
  00d9f	48 23 c3	 and	 rax, rbx
  00da2	48 89 05 70 00
	00 00		 mov	 QWORD PTR ?keys@@3PA_KA+112, rax

; 990  : 	keys[15] = compressPermuteKey(keys[15]) & 0x0000FFFFFFFFFFFF;

  00da9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ?keys@@3PA_KA$16[rsp]
  00dae	e8 00 00 00 00	 call	 ?compressPermuteKey@@YA_K_K@Z ; compressPermuteKey
  00db3	48 23 c3	 and	 rax, rbx
  00db6	48 89 05 78 00
	00 00		 mov	 QWORD PTR ?keys@@3PA_KA+120, rax

; 991  : 	keys[16] = compressPermuteKey(keys[16]) & 0x0000FFFFFFFFFFFF;

  00dbd	48 8b 4c 24 20	 mov	 rcx, QWORD PTR ?keys@@3PA_KA$17[rsp]
  00dc2	e8 00 00 00 00	 call	 ?compressPermuteKey@@YA_K_K@Z ; compressPermuteKey
  00dc7	48 23 c3	 and	 rax, rbx
  00dca	48 89 05 80 00
	00 00		 mov	 QWORD PTR ?keys@@3PA_KA+128, rax

; 992  : 
; 993  : 	//get the filesize before going into working on the files
; 994  : 
; 995  : 
; 996  : 
; 997  : 	uint32_t fileSize = (uint32_t)inFile.tellg(); //starting position

  00dd1	48 8d 95 d0 01
	00 00		 lea	 rdx, QWORD PTR $T9[rbp-256]
  00dd8	48 8d 4d 80	 lea	 rcx, QWORD PTR inFile$[rbp-256]
  00ddc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?tellg@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA?AV?$fpos@U_Mbstatet@@@2@XZ
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 68   : 		return ((streamoff)(_Myoff + _FPOSOFF(_Fpos)));

  00de2	8b 58 08	 mov	 ebx, DWORD PTR [rax+8]
  00de5	03 18		 add	 ebx, DWORD PTR [rax]
; File c:\users\coschm\desktop\fall-2016\security\des\des\des\main.cpp

; 999  : 	inFile.seekg(0, ios::end); //put pointer at end of file

  00de7	33 d2		 xor	 edx, edx
  00de9	44 8d 42 02	 lea	 r8d, QWORD PTR [rdx+2]
  00ded	48 8d 4d 80	 lea	 rcx, QWORD PTR inFile$[rbp-256]
  00df1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?seekg@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@_JH@Z

; 1000 : 	fileSize = (uint32_t)inFile.tellg() - fileSize; //use the difference for file size

  00df7	48 8d 95 d0 01
	00 00		 lea	 rdx, QWORD PTR $T8[rbp-256]
  00dfe	48 8d 4d 80	 lea	 rcx, QWORD PTR inFile$[rbp-256]
  00e02	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?tellg@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA?AV?$fpos@U_Mbstatet@@@2@XZ
  00e08	8b 78 08	 mov	 edi, DWORD PTR [rax+8]
  00e0b	2b fb		 sub	 edi, ebx
  00e0d	03 38		 add	 edi, DWORD PTR [rax]

; 1001 : 	inFile.seekg(0, ios::beg);//move the pointer back to the beggining of the file

  00e0f	45 33 c0	 xor	 r8d, r8d
  00e12	33 d2		 xor	 edx, edx
  00e14	48 8d 4d 80	 lea	 rcx, QWORD PTR inFile$[rbp-256]
  00e18	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?seekg@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@_JH@Z

; 1002 : 	
; 1003 : 	if (fileSize % 8 != 0)
; 1004 : 	{
; 1005 : 		//we will need to pad bytes on if the length is not a perfect multiple of 8
; 1006 : 		bytesToPad = 8 - (fileSize % 8);
; 1007 : 	}
; 1008 : 
; 1009 : 	//now that we have our keys and file size, we need to see if we're encoding or decoding 
; 1010 : 	//essentially everything else will happen inside one of these cases
; 1011 : 	if (strcmp(argv[1], "-e") == 0 || strcmp(argv[1], "-E") == 0)

  00e1e	48 8b 85 48 02
	00 00		 mov	 rax, QWORD PTR argv$[rbp-256]
  00e25	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00e29	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00e2c	3a 05 00 00 00
	00		 cmp	 al, BYTE PTR ??_C@_02CIKBGMLM@?9e?$AA@
  00e32	75 18		 jne	 SHORT $LN297@main
  00e34	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  00e38	3a 05 01 00 00
	00		 cmp	 al, BYTE PTR ??_C@_02CIKBGMLM@?9e?$AA@+1
  00e3e	75 0c		 jne	 SHORT $LN297@main
  00e40	0f b6 41 02	 movzx	 eax, BYTE PTR [rcx+2]
  00e44	3a 05 02 00 00
	00		 cmp	 al, BYTE PTR ??_C@_02CIKBGMLM@?9e?$AA@+2
  00e4a	74 2f		 je	 SHORT $LN168@main
$LN297@main:
  00e4c	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00e4f	3a 05 00 00 00
	00		 cmp	 al, BYTE PTR ??_C@_02LNCFEIBO@?9E?$AA@
  00e55	0f 85 f3 05 00
	00		 jne	 $LN296@main
  00e5b	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  00e5f	3a 05 01 00 00
	00		 cmp	 al, BYTE PTR ??_C@_02LNCFEIBO@?9E?$AA@+1
  00e65	0f 85 e3 05 00
	00		 jne	 $LN296@main
  00e6b	0f b6 41 02	 movzx	 eax, BYTE PTR [rcx+2]
  00e6f	3a 05 02 00 00
	00		 cmp	 al, BYTE PTR ??_C@_02LNCFEIBO@?9E?$AA@+2
  00e75	0f 85 d3 05 00
	00		 jne	 $LN296@main
$LN168@main:
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\time.h

; 535  :             return _time64(_Time);

  00e7b	33 c9		 xor	 ecx, ecx
  00e7d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__time64
  00e83	48 8b c8	 mov	 rcx, rax
; File c:\users\coschm\desktop\fall-2016\security\des\des\des\main.cpp

; 1015 : 		srand((unsigned)time(0));

  00e86	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_srand

; 1016 : 		uint64_t randomGarb = (uint16_t)rand();		//casting to 16 bits so the max is 

  00e8c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rand
  00e92	0f b7 d8	 movzx	 ebx, ax

; 1017 : 		randomGarb = randomGarb * (uint16_t)rand(); //less than 32 bits after the mul

  00e95	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rand
  00e9b	0f b7 c8	 movzx	 ecx, ax

; 1018 : 		randomGarb = (randomGarb << 32); //clearing out the space for the filesize

  00e9e	48 0f af cb	 imul	 rcx, rbx
  00ea2	48 c1 e1 20	 shl	 rcx, 32			; 00000020H

; 1019 : 		randomGarb += fileSize;

  00ea6	8b c7		 mov	 eax, edi
  00ea8	48 03 c8	 add	 rcx, rax

; 1020 : 
; 1021 : 		//now we have the first 8bytes of the output file that we need to encrypt
; 1022 : 		// initial permutation
; 1023 : 		randomGarb = permutation1(randomGarb);

  00eab	e8 00 00 00 00	 call	 ?permutation1@@YA_K_K@Z	; permutation1

; 1024 : 		
; 1025 : 		//The 16 Feistel rounds
; 1026 : 		randomGarb = runIt(randomGarb, 1);

  00eb0	ba 01 00 00 00	 mov	 edx, 1
  00eb5	48 8b c8	 mov	 rcx, rax
  00eb8	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  00ebd	48 8b c8	 mov	 rcx, rax

; 1027 : 		randomGarb = runIt(randomGarb, 2);

  00ec0	ba 02 00 00 00	 mov	 edx, 2
  00ec5	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  00eca	48 8b c8	 mov	 rcx, rax

; 1028 : 		randomGarb = runIt(randomGarb, 3);

  00ecd	ba 03 00 00 00	 mov	 edx, 3
  00ed2	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  00ed7	48 8b c8	 mov	 rcx, rax

; 1029 : 		randomGarb = runIt(randomGarb, 4);

  00eda	ba 04 00 00 00	 mov	 edx, 4
  00edf	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  00ee4	48 8b c8	 mov	 rcx, rax

; 1030 : 		randomGarb = runIt(randomGarb, 5);

  00ee7	ba 05 00 00 00	 mov	 edx, 5
  00eec	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  00ef1	48 8b c8	 mov	 rcx, rax

; 1031 : 		randomGarb = runIt(randomGarb, 6);

  00ef4	ba 06 00 00 00	 mov	 edx, 6
  00ef9	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  00efe	48 8b c8	 mov	 rcx, rax

; 1032 : 		randomGarb = runIt(randomGarb, 7);

  00f01	ba 07 00 00 00	 mov	 edx, 7
  00f06	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  00f0b	48 8b c8	 mov	 rcx, rax

; 1033 : 		randomGarb = runIt(randomGarb, 8);

  00f0e	ba 08 00 00 00	 mov	 edx, 8
  00f13	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  00f18	48 8b c8	 mov	 rcx, rax

; 1034 : 		randomGarb = runIt(randomGarb, 9);

  00f1b	ba 09 00 00 00	 mov	 edx, 9
  00f20	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  00f25	48 8b c8	 mov	 rcx, rax

; 1035 : 		randomGarb = runIt(randomGarb, 10);

  00f28	ba 0a 00 00 00	 mov	 edx, 10
  00f2d	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  00f32	48 8b c8	 mov	 rcx, rax

; 1036 : 		randomGarb = runIt(randomGarb, 11);

  00f35	ba 0b 00 00 00	 mov	 edx, 11
  00f3a	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  00f3f	48 8b c8	 mov	 rcx, rax

; 1037 : 		randomGarb = runIt(randomGarb, 12);

  00f42	ba 0c 00 00 00	 mov	 edx, 12
  00f47	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  00f4c	48 8b c8	 mov	 rcx, rax

; 1038 : 		randomGarb = runIt(randomGarb, 13);

  00f4f	ba 0d 00 00 00	 mov	 edx, 13
  00f54	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  00f59	48 8b c8	 mov	 rcx, rax

; 1039 : 		randomGarb = runIt(randomGarb, 14);

  00f5c	ba 0e 00 00 00	 mov	 edx, 14
  00f61	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  00f66	48 8b c8	 mov	 rcx, rax

; 1040 : 		randomGarb = runIt(randomGarb, 15);

  00f69	ba 0f 00 00 00	 mov	 edx, 15
  00f6e	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  00f73	48 8b c8	 mov	 rcx, rax

; 1041 : 		randomGarb = runIt(randomGarb, 16);

  00f76	ba 10 00 00 00	 mov	 edx, 16
  00f7b	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt

; 1042 : 
; 1043 : 		uint64_t right = randomGarb & 0x00000000FFFFFFFF;

  00f80	8b c8		 mov	 ecx, eax

; 1044 : 
; 1045 : 		//the last swap after the 16th round
; 1046 : 		randomGarb = (randomGarb >> 32) | (right << 32);

  00f82	48 c1 e1 20	 shl	 rcx, 32			; 00000020H
  00f86	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  00f8a	48 0b c8	 or	 rcx, rax

; 1047 : 		//final permutation before putting it in the output file
; 1048 : 		randomGarb = finalPermutation(randomGarb);

  00f8d	e8 00 00 00 00	 call	 ?finalPermutation@@YA_K_K@Z ; finalPermutation
  00f92	48 8b d0	 mov	 rdx, rax

; 1049 : 
; 1050 : 		char fSizeOut[9] = { 0 };

  00f95	33 c0		 xor	 eax, eax
  00f97	48 89 44 24 31	 mov	 QWORD PTR fSizeOut$4[rsp+1], rax

; 115  : 	output[0] = ((char)(value >> 56));

  00f9c	48 8b ca	 mov	 rcx, rdx
  00f9f	48 c1 e9 38	 shr	 rcx, 56			; 00000038H
  00fa3	88 4c 24 30	 mov	 BYTE PTR fSizeOut$4[rsp], cl

; 116  : 	output[1] = ((char)(value >> 48));

  00fa7	48 8b ca	 mov	 rcx, rdx
  00faa	48 c1 e9 30	 shr	 rcx, 48			; 00000030H
  00fae	88 4c 24 31	 mov	 BYTE PTR fSizeOut$4[rsp+1], cl

; 117  : 	output[2] = ((char)(value >> 40));

  00fb2	48 8b ca	 mov	 rcx, rdx
  00fb5	48 c1 e9 28	 shr	 rcx, 40			; 00000028H
  00fb9	88 4c 24 32	 mov	 BYTE PTR fSizeOut$4[rsp+2], cl

; 118  : 	output[3] = ((char)(value >> 32));

  00fbd	48 8b ca	 mov	 rcx, rdx
  00fc0	48 c1 e9 20	 shr	 rcx, 32			; 00000020H
  00fc4	88 4c 24 33	 mov	 BYTE PTR fSizeOut$4[rsp+3], cl

; 119  : 	output[4] = ((char)(value >> 24));

  00fc8	48 8b c2	 mov	 rax, rdx
  00fcb	48 c1 e8 18	 shr	 rax, 24
  00fcf	88 44 24 34	 mov	 BYTE PTR fSizeOut$4[rsp+4], al

; 120  : 	output[5] = ((char)(value >> 16));

  00fd3	48 8b c2	 mov	 rax, rdx
  00fd6	48 c1 e8 10	 shr	 rax, 16
  00fda	88 44 24 35	 mov	 BYTE PTR fSizeOut$4[rsp+5], al

; 121  : 	output[6] = ((char)(value >> 8));

  00fde	48 8b c2	 mov	 rax, rdx
  00fe1	48 c1 e8 08	 shr	 rax, 8
  00fe5	88 44 24 36	 mov	 BYTE PTR fSizeOut$4[rsp+6], al

; 122  : 	output[7] = ((char)(value));

  00fe9	88 54 24 37	 mov	 BYTE PTR fSizeOut$4[rsp+7], dl

; 1051 : 		convertToChar(randomGarb, fSizeOut);
; 1052 : 
; 1053 : 		outFile.write(fSizeOut, 8);

  00fed	41 b8 08 00 00
	00		 mov	 r8d, 8
  00ff3	48 8d 54 24 30	 lea	 rdx, QWORD PTR fSizeOut$4[rsp]
  00ff8	48 8d 8d c0 00
	00 00		 lea	 rcx, QWORD PTR outFile$[rbp-240]
  00fff	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?write@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@PEBD_J@Z

; 1054 : 		outFile.flush();

  01005	48 8d 8d c0 00
	00 00		 lea	 rcx, QWORD PTR outFile$[rbp-240]
  0100c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ

; 1055 : 
; 1056 : 		int bytesRead = 0;
; 1057 : 		char in[9] = { 0 };

  01012	c6 44 24 20 00	 mov	 BYTE PTR in$2[rsp], 0
  01017	33 c0		 xor	 eax, eax
  01019	48 89 44 24 21	 mov	 QWORD PTR in$2[rsp+1], rax
  0101e	33 db		 xor	 ebx, ebx

; 1058 : 
; 1059 : 		while ((fileSize - bytesRead) >= 8)

  01020	83 ff 08	 cmp	 edi, 8
  01023	0f 82 0a 02 00
	00		 jb	 $LN3@main
  01029	0f 1f 80 00 00
	00 00		 npad	 7
$LL2@main:

; 1060 : 		{
; 1061 : 			inFile.read(in, 8);

  01030	41 b8 08 00 00
	00		 mov	 r8d, 8
  01036	48 8d 54 24 20	 lea	 rdx, QWORD PTR in$2[rsp]
  0103b	48 8d 4d 80	 lea	 rcx, QWORD PTR inFile$[rbp-256]
  0103f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@PEAD_J@Z

; 1062 : 			bytesRead += 8;

  01045	83 c3 08	 add	 ebx, 8

; 1063 : 
; 1064 : 			uint64_t y = 0;
; 1065 : 			y  |= (((uint64_t)in[0] << 56) & 0xFF00000000000000)

  01048	48 0f be 44 24
	21		 movsx	 rax, BYTE PTR in$2[rsp+1]

; 1092 : 			y = runIt(y, 16);

  0104e	44 0f b6 c0	 movzx	 r8d, al

; 1063 : 
; 1064 : 			uint64_t y = 0;
; 1065 : 			y  |= (((uint64_t)in[0] << 56) & 0xFF00000000000000)

  01052	48 0f be 44 24
	20		 movsx	 rax, BYTE PTR in$2[rsp]

; 1092 : 			y = runIt(y, 16);

  01058	48 c1 e0 08	 shl	 rax, 8
  0105c	4c 0b c0	 or	 r8, rax

; 1063 : 
; 1064 : 			uint64_t y = 0;
; 1065 : 			y  |= (((uint64_t)in[0] << 56) & 0xFF00000000000000)

  0105f	49 c1 e0 08	 shl	 r8, 8
  01063	48 0f be 44 24
	22		 movsx	 rax, BYTE PTR in$2[rsp+2]

; 1092 : 			y = runIt(y, 16);

  01069	0f b6 c8	 movzx	 ecx, al
  0106c	4c 0b c1	 or	 r8, rcx

; 1063 : 
; 1064 : 			uint64_t y = 0;
; 1065 : 			y  |= (((uint64_t)in[0] << 56) & 0xFF00000000000000)

  0106f	49 c1 e0 08	 shl	 r8, 8
  01073	48 0f be 44 24
	23		 movsx	 rax, BYTE PTR in$2[rsp+3]

; 1092 : 			y = runIt(y, 16);

  01079	0f b6 c8	 movzx	 ecx, al
  0107c	4c 0b c1	 or	 r8, rcx

; 1063 : 
; 1064 : 			uint64_t y = 0;
; 1065 : 			y  |= (((uint64_t)in[0] << 56) & 0xFF00000000000000)

  0107f	49 c1 e0 08	 shl	 r8, 8
  01083	48 0f be 44 24
	24		 movsx	 rax, BYTE PTR in$2[rsp+4]

; 1092 : 			y = runIt(y, 16);

  01089	0f b6 c8	 movzx	 ecx, al
  0108c	49 0b c8	 or	 rcx, r8

; 1063 : 
; 1064 : 			uint64_t y = 0;
; 1065 : 			y  |= (((uint64_t)in[0] << 56) & 0xFF00000000000000)

  0108f	48 c1 e1 08	 shl	 rcx, 8
  01093	48 0f be 44 24
	25		 movsx	 rax, BYTE PTR in$2[rsp+5]

; 1092 : 			y = runIt(y, 16);

  01099	0f b6 d0	 movzx	 edx, al
  0109c	48 0b ca	 or	 rcx, rdx

; 1063 : 
; 1064 : 			uint64_t y = 0;
; 1065 : 			y  |= (((uint64_t)in[0] << 56) & 0xFF00000000000000)

  0109f	48 c1 e1 08	 shl	 rcx, 8
  010a3	48 0f be 44 24
	26		 movsx	 rax, BYTE PTR in$2[rsp+6]

; 1092 : 			y = runIt(y, 16);

  010a9	0f b6 d0	 movzx	 edx, al
  010ac	48 0b ca	 or	 rcx, rdx

; 1063 : 
; 1064 : 			uint64_t y = 0;
; 1065 : 			y  |= (((uint64_t)in[0] << 56) & 0xFF00000000000000)

  010af	48 c1 e1 08	 shl	 rcx, 8
  010b3	48 0f be 44 24
	27		 movsx	 rax, BYTE PTR in$2[rsp+7]
  010b9	0f b6 d0	 movzx	 edx, al
  010bc	48 0b ca	 or	 rcx, rdx

; 1066 : 				| (((uint64_t)in[1] << 48) & 0x00FF000000000000)
; 1067 : 				| (((uint64_t)in[2] << 40) & 0x0000FF0000000000)
; 1068 : 				| (((uint64_t)in[3] << 32) & 0x000000FF00000000)
; 1069 : 				| (((uint64_t)in[4] << 24) & 0x00000000FF000000)
; 1070 : 				| (((uint64_t)in[5] << 16) & 0x0000000000FF0000)
; 1071 : 				| (((uint64_t)in[6] << 8)  & 0x000000000000FF00)
; 1072 : 				| (((uint64_t)in[7])       & 0x00000000000000FF);
; 1073 : 
; 1074 : 			y = permutation1(y);

  010bf	e8 00 00 00 00	 call	 ?permutation1@@YA_K_K@Z	; permutation1
  010c4	48 8b c8	 mov	 rcx, rax

; 1075 : 
; 1076 : 			//The 16 Feistel rounds
; 1077 : 			y = runIt(y, 1);

  010c7	ba 01 00 00 00	 mov	 edx, 1
  010cc	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  010d1	48 8b c8	 mov	 rcx, rax

; 1078 : 			y = runIt(y, 2);

  010d4	ba 02 00 00 00	 mov	 edx, 2
  010d9	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  010de	48 8b c8	 mov	 rcx, rax

; 1079 : 			y = runIt(y, 3);

  010e1	ba 03 00 00 00	 mov	 edx, 3
  010e6	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  010eb	48 8b c8	 mov	 rcx, rax

; 1080 : 			y = runIt(y, 4);

  010ee	ba 04 00 00 00	 mov	 edx, 4
  010f3	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  010f8	48 8b c8	 mov	 rcx, rax

; 1081 : 			y = runIt(y, 5);

  010fb	ba 05 00 00 00	 mov	 edx, 5
  01100	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  01105	48 8b c8	 mov	 rcx, rax

; 1082 : 			y = runIt(y, 6);

  01108	ba 06 00 00 00	 mov	 edx, 6
  0110d	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  01112	48 8b c8	 mov	 rcx, rax

; 1083 : 			y = runIt(y, 7);

  01115	ba 07 00 00 00	 mov	 edx, 7
  0111a	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  0111f	48 8b c8	 mov	 rcx, rax

; 1084 : 			y = runIt(y, 8);

  01122	ba 08 00 00 00	 mov	 edx, 8
  01127	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  0112c	48 8b c8	 mov	 rcx, rax

; 1085 : 			y = runIt(y, 9);

  0112f	ba 09 00 00 00	 mov	 edx, 9
  01134	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  01139	48 8b c8	 mov	 rcx, rax

; 1086 : 			y = runIt(y, 10);

  0113c	ba 0a 00 00 00	 mov	 edx, 10
  01141	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  01146	48 8b c8	 mov	 rcx, rax

; 1087 : 			y = runIt(y, 11);

  01149	ba 0b 00 00 00	 mov	 edx, 11
  0114e	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  01153	48 8b c8	 mov	 rcx, rax

; 1088 : 			y = runIt(y, 12);

  01156	ba 0c 00 00 00	 mov	 edx, 12
  0115b	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  01160	48 8b c8	 mov	 rcx, rax

; 1089 : 			y = runIt(y, 13);

  01163	ba 0d 00 00 00	 mov	 edx, 13
  01168	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  0116d	48 8b c8	 mov	 rcx, rax

; 1090 : 			y = runIt(y, 14);

  01170	ba 0e 00 00 00	 mov	 edx, 14
  01175	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  0117a	48 8b c8	 mov	 rcx, rax

; 1091 : 			y = runIt(y, 15);

  0117d	ba 0f 00 00 00	 mov	 edx, 15
  01182	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  01187	48 8b c8	 mov	 rcx, rax

; 1092 : 			y = runIt(y, 16);

  0118a	ba 10 00 00 00	 mov	 edx, 16
  0118f	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt

; 1093 : 
; 1094 : 			uint64_t right = y & 0x00000000FFFFFFFF;

  01194	8b c8		 mov	 ecx, eax

; 1095 : 
; 1096 : 			//the last swap after the 16th round
; 1097 : 			y = (y >> 32) | (right << 32);

  01196	48 c1 e1 20	 shl	 rcx, 32			; 00000020H
  0119a	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  0119e	48 0b c8	 or	 rcx, rax

; 1098 : 
; 1099 : 			y = finalPermutation(y);

  011a1	e8 00 00 00 00	 call	 ?finalPermutation@@YA_K_K@Z ; finalPermutation
  011a6	48 8b d0	 mov	 rdx, rax

; 1100 : 			char a[9] = { 0 };

  011a9	33 c0		 xor	 eax, eax
  011ab	48 89 44 24 41	 mov	 QWORD PTR a$6[rsp+1], rax

; 115  : 	output[0] = ((char)(value >> 56));

  011b0	48 8b ca	 mov	 rcx, rdx
  011b3	48 c1 e9 38	 shr	 rcx, 56			; 00000038H
  011b7	88 4c 24 40	 mov	 BYTE PTR a$6[rsp], cl

; 116  : 	output[1] = ((char)(value >> 48));

  011bb	48 8b ca	 mov	 rcx, rdx
  011be	48 c1 e9 30	 shr	 rcx, 48			; 00000030H
  011c2	88 4c 24 41	 mov	 BYTE PTR a$6[rsp+1], cl

; 117  : 	output[2] = ((char)(value >> 40));

  011c6	48 8b ca	 mov	 rcx, rdx
  011c9	48 c1 e9 28	 shr	 rcx, 40			; 00000028H
  011cd	88 4c 24 42	 mov	 BYTE PTR a$6[rsp+2], cl

; 118  : 	output[3] = ((char)(value >> 32));

  011d1	48 8b ca	 mov	 rcx, rdx
  011d4	48 c1 e9 20	 shr	 rcx, 32			; 00000020H
  011d8	88 4c 24 43	 mov	 BYTE PTR a$6[rsp+3], cl

; 119  : 	output[4] = ((char)(value >> 24));

  011dc	48 8b c2	 mov	 rax, rdx
  011df	48 c1 e8 18	 shr	 rax, 24
  011e3	88 44 24 44	 mov	 BYTE PTR a$6[rsp+4], al

; 120  : 	output[5] = ((char)(value >> 16));

  011e7	48 8b c2	 mov	 rax, rdx
  011ea	48 c1 e8 10	 shr	 rax, 16
  011ee	88 44 24 45	 mov	 BYTE PTR a$6[rsp+5], al

; 121  : 	output[6] = ((char)(value >> 8));

  011f2	48 8b c2	 mov	 rax, rdx
  011f5	48 c1 e8 08	 shr	 rax, 8
  011f9	88 44 24 46	 mov	 BYTE PTR a$6[rsp+6], al

; 122  : 	output[7] = ((char)(value));

  011fd	88 54 24 47	 mov	 BYTE PTR a$6[rsp+7], dl

; 1101 : 			convertToChar(y, a);
; 1102 : 			outFile.write(a, 8);

  01201	41 b8 08 00 00
	00		 mov	 r8d, 8
  01207	48 8d 54 24 40	 lea	 rdx, QWORD PTR a$6[rsp]
  0120c	48 8d 8d c0 00
	00 00		 lea	 rcx, QWORD PTR outFile$[rbp-240]
  01213	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?write@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@PEBD_J@Z

; 1103 : 			outFile.flush();

  01219	48 8d 8d c0 00
	00 00		 lea	 rcx, QWORD PTR outFile$[rbp-240]
  01220	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ

; 1058 : 
; 1059 : 		while ((fileSize - bytesRead) >= 8)

  01226	8b c7		 mov	 eax, edi
  01228	2b c3		 sub	 eax, ebx
  0122a	83 f8 08	 cmp	 eax, 8
  0122d	0f 83 fd fd ff
	ff		 jae	 $LL2@main
$LN3@main:

; 1104 : 		}
; 1105 : 		if ((fileSize - bytesRead) > 0)

  01233	8b c7		 mov	 eax, edi
  01235	2b c3		 sub	 eax, ebx
  01237	0f 84 7b 07 00
	00		 je	 $LN169@main

; 1108 : 			inFile.read(in, fileSize-bytesRead);

  0123d	44 8b c0	 mov	 r8d, eax
  01240	48 8d 54 24 20	 lea	 rdx, QWORD PTR in$2[rsp]
  01245	48 8d 4d 80	 lea	 rcx, QWORD PTR inFile$[rbp-256]
  01249	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@PEAD_J@Z

; 1106 : 		{
; 1107 : 			int bytesToFill = (fileSize % 8);

  0124f	83 e7 07	 and	 edi, 7

; 1109 : 			while (bytesToFill < 8)

  01252	48 63 df	 movsxd	 rbx, edi
  01255	48 83 fb 08	 cmp	 rbx, 8
  01259	7d 28		 jge	 SHORT $LN5@main
  0125b	0f 1f 44 00 00	 npad	 5
$LL4@main:

; 1110 : 			{
; 1111 : 				in[bytesToFill++] = (rand() % 256); //trying to get a random character to finish out the last string

  01260	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rand
  01266	25 ff 00 00 80	 and	 eax, -2147483393	; ffffffff800000ffH
  0126b	7d 09		 jge	 SHORT $LN295@main
  0126d	ff c8		 dec	 eax
  0126f	0d 00 ff ff ff	 or	 eax, -256		; ffffffffffffff00H
  01274	ff c0		 inc	 eax
$LN295@main:
  01276	88 44 1c 20	 mov	 BYTE PTR in$2[rsp+rbx], al
  0127a	48 ff c3	 inc	 rbx

; 1109 : 			while (bytesToFill < 8)

  0127d	48 83 fb 08	 cmp	 rbx, 8
  01281	7c dd		 jl	 SHORT $LL4@main
$LN5@main:

; 1112 : 			}
; 1113 : 
; 1114 : 			uint64_t y = 0;
; 1115 : 			y  |= (((uint64_t)in[0] << 56) & 0xFF00000000000000)

  01283	48 0f be 44 24
	21		 movsx	 rax, BYTE PTR in$2[rsp+1]

; 1142 : 			y = runIt(y, 16);

  01289	44 0f b6 c8	 movzx	 r9d, al

; 1112 : 			}
; 1113 : 
; 1114 : 			uint64_t y = 0;
; 1115 : 			y  |= (((uint64_t)in[0] << 56) & 0xFF00000000000000)

  0128d	48 0f be 44 24
	20		 movsx	 rax, BYTE PTR in$2[rsp]

; 1142 : 			y = runIt(y, 16);

  01293	48 c1 e0 08	 shl	 rax, 8
  01297	4c 0b c8	 or	 r9, rax

; 1112 : 			}
; 1113 : 
; 1114 : 			uint64_t y = 0;
; 1115 : 			y  |= (((uint64_t)in[0] << 56) & 0xFF00000000000000)

  0129a	49 c1 e1 08	 shl	 r9, 8
  0129e	48 0f be 44 24
	22		 movsx	 rax, BYTE PTR in$2[rsp+2]

; 1142 : 			y = runIt(y, 16);

  012a4	0f b6 c8	 movzx	 ecx, al
  012a7	4c 0b c9	 or	 r9, rcx

; 1112 : 			}
; 1113 : 
; 1114 : 			uint64_t y = 0;
; 1115 : 			y  |= (((uint64_t)in[0] << 56) & 0xFF00000000000000)

  012aa	49 c1 e1 08	 shl	 r9, 8
  012ae	48 0f be 44 24
	23		 movsx	 rax, BYTE PTR in$2[rsp+3]

; 1142 : 			y = runIt(y, 16);

  012b4	0f b6 c8	 movzx	 ecx, al
  012b7	4c 0b c9	 or	 r9, rcx

; 1112 : 			}
; 1113 : 
; 1114 : 			uint64_t y = 0;
; 1115 : 			y  |= (((uint64_t)in[0] << 56) & 0xFF00000000000000)

  012ba	49 c1 e1 08	 shl	 r9, 8
  012be	48 0f be 44 24
	24		 movsx	 rax, BYTE PTR in$2[rsp+4]

; 1142 : 			y = runIt(y, 16);

  012c4	0f b6 c8	 movzx	 ecx, al
  012c7	49 0b c9	 or	 rcx, r9

; 1112 : 			}
; 1113 : 
; 1114 : 			uint64_t y = 0;
; 1115 : 			y  |= (((uint64_t)in[0] << 56) & 0xFF00000000000000)

  012ca	48 c1 e1 08	 shl	 rcx, 8
  012ce	48 0f be 44 24
	25		 movsx	 rax, BYTE PTR in$2[rsp+5]

; 1142 : 			y = runIt(y, 16);

  012d4	0f b6 d0	 movzx	 edx, al
  012d7	48 0b ca	 or	 rcx, rdx

; 1112 : 			}
; 1113 : 
; 1114 : 			uint64_t y = 0;
; 1115 : 			y  |= (((uint64_t)in[0] << 56) & 0xFF00000000000000)

  012da	48 c1 e1 08	 shl	 rcx, 8
  012de	48 0f be 44 24
	26		 movsx	 rax, BYTE PTR in$2[rsp+6]

; 1142 : 			y = runIt(y, 16);

  012e4	44 0f b6 c0	 movzx	 r8d, al
  012e8	49 0b c8	 or	 rcx, r8

; 1112 : 			}
; 1113 : 
; 1114 : 			uint64_t y = 0;
; 1115 : 			y  |= (((uint64_t)in[0] << 56) & 0xFF00000000000000)

  012eb	48 c1 e1 08	 shl	 rcx, 8
  012ef	48 0f be 44 24
	27		 movsx	 rax, BYTE PTR in$2[rsp+7]
  012f5	44 0f b6 c0	 movzx	 r8d, al
  012f9	49 0b c8	 or	 rcx, r8

; 1116 : 				| (((uint64_t)in[1] << 48) & 0x00FF000000000000)
; 1117 : 				| (((uint64_t)in[2] << 40) & 0x0000FF0000000000)
; 1118 : 				| (((uint64_t)in[3] << 32) & 0x000000FF00000000)
; 1119 : 				| (((uint64_t)in[4] << 24) & 0x00000000FF000000)
; 1120 : 				| (((uint64_t)in[5] << 16) & 0x0000000000FF0000)
; 1121 : 				| (((uint64_t)in[6] << 8)  & 0x000000000000FF00)
; 1122 : 				| (((uint64_t)in[7])	   & 0x00000000000000FF);
; 1123 : 
; 1124 : 			y = permutation1(y);

  012fc	e8 00 00 00 00	 call	 ?permutation1@@YA_K_K@Z	; permutation1
  01301	48 8b c8	 mov	 rcx, rax

; 1125 : 
; 1126 : 			//The 16 Feistel rounds
; 1127 : 			y = runIt(y, 1);

  01304	ba 01 00 00 00	 mov	 edx, 1
  01309	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  0130e	48 8b c8	 mov	 rcx, rax

; 1128 : 			y = runIt(y, 2);

  01311	ba 02 00 00 00	 mov	 edx, 2
  01316	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  0131b	48 8b c8	 mov	 rcx, rax

; 1129 : 			y = runIt(y, 3);

  0131e	ba 03 00 00 00	 mov	 edx, 3
  01323	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  01328	48 8b c8	 mov	 rcx, rax

; 1130 : 			y = runIt(y, 4);

  0132b	ba 04 00 00 00	 mov	 edx, 4
  01330	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  01335	48 8b c8	 mov	 rcx, rax

; 1131 : 			y = runIt(y, 5);

  01338	ba 05 00 00 00	 mov	 edx, 5
  0133d	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  01342	48 8b c8	 mov	 rcx, rax

; 1132 : 			y = runIt(y, 6);

  01345	ba 06 00 00 00	 mov	 edx, 6
  0134a	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  0134f	48 8b c8	 mov	 rcx, rax

; 1133 : 			y = runIt(y, 7);

  01352	ba 07 00 00 00	 mov	 edx, 7
  01357	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  0135c	48 8b c8	 mov	 rcx, rax

; 1134 : 			y = runIt(y, 8);

  0135f	ba 08 00 00 00	 mov	 edx, 8
  01364	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  01369	48 8b c8	 mov	 rcx, rax

; 1135 : 			y = runIt(y, 9);

  0136c	ba 09 00 00 00	 mov	 edx, 9
  01371	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  01376	48 8b c8	 mov	 rcx, rax

; 1136 : 			y = runIt(y, 10);

  01379	ba 0a 00 00 00	 mov	 edx, 10
  0137e	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  01383	48 8b c8	 mov	 rcx, rax

; 1137 : 			y = runIt(y, 11);

  01386	ba 0b 00 00 00	 mov	 edx, 11
  0138b	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  01390	48 8b c8	 mov	 rcx, rax

; 1138 : 			y = runIt(y, 12);

  01393	ba 0c 00 00 00	 mov	 edx, 12
  01398	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  0139d	48 8b c8	 mov	 rcx, rax

; 1139 : 			y = runIt(y, 13);

  013a0	ba 0d 00 00 00	 mov	 edx, 13
  013a5	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  013aa	48 8b c8	 mov	 rcx, rax

; 1140 : 			y = runIt(y, 14);

  013ad	ba 0e 00 00 00	 mov	 edx, 14
  013b2	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  013b7	48 8b c8	 mov	 rcx, rax

; 1141 : 			y = runIt(y, 15);

  013ba	ba 0f 00 00 00	 mov	 edx, 15
  013bf	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  013c4	48 8b c8	 mov	 rcx, rax

; 1142 : 			y = runIt(y, 16);

  013c7	ba 10 00 00 00	 mov	 edx, 16
  013cc	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt

; 1143 : 
; 1144 : 			uint64_t right = y & 0x00000000FFFFFFFF;

  013d1	8b c8		 mov	 ecx, eax

; 1145 : 
; 1146 : 			//the last swap after the 16th round
; 1147 : 			y = (y >> 32) | (right << 32);

  013d3	48 c1 e1 20	 shl	 rcx, 32			; 00000020H
  013d7	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  013db	48 0b c8	 or	 rcx, rax

; 1148 : 
; 1149 : 			y = finalPermutation(y);

  013de	e8 00 00 00 00	 call	 ?finalPermutation@@YA_K_K@Z ; finalPermutation
  013e3	48 8b d0	 mov	 rdx, rax

; 1150 : 			char a[9] = { 0 };

  013e6	33 c0		 xor	 eax, eax
  013e8	48 89 44 24 41	 mov	 QWORD PTR a$5[rsp+1], rax

; 115  : 	output[0] = ((char)(value >> 56));

  013ed	48 8b ca	 mov	 rcx, rdx
  013f0	48 c1 e9 38	 shr	 rcx, 56			; 00000038H
  013f4	88 4c 24 40	 mov	 BYTE PTR a$5[rsp], cl

; 116  : 	output[1] = ((char)(value >> 48));

  013f8	48 8b ca	 mov	 rcx, rdx
  013fb	48 c1 e9 30	 shr	 rcx, 48			; 00000030H
  013ff	88 4c 24 41	 mov	 BYTE PTR a$5[rsp+1], cl

; 117  : 	output[2] = ((char)(value >> 40));

  01403	48 8b ca	 mov	 rcx, rdx
  01406	48 c1 e9 28	 shr	 rcx, 40			; 00000028H
  0140a	88 4c 24 42	 mov	 BYTE PTR a$5[rsp+2], cl

; 118  : 	output[3] = ((char)(value >> 32));

  0140e	48 8b ca	 mov	 rcx, rdx
  01411	48 c1 e9 20	 shr	 rcx, 32			; 00000020H
  01415	88 4c 24 43	 mov	 BYTE PTR a$5[rsp+3], cl

; 119  : 	output[4] = ((char)(value >> 24));

  01419	48 8b c2	 mov	 rax, rdx
  0141c	48 c1 e8 18	 shr	 rax, 24
  01420	88 44 24 44	 mov	 BYTE PTR a$5[rsp+4], al

; 120  : 	output[5] = ((char)(value >> 16));

  01424	48 8b c2	 mov	 rax, rdx
  01427	48 c1 e8 10	 shr	 rax, 16
  0142b	88 44 24 45	 mov	 BYTE PTR a$5[rsp+5], al

; 121  : 	output[6] = ((char)(value >> 8));

  0142f	48 8b c2	 mov	 rax, rdx
  01432	48 c1 e8 08	 shr	 rax, 8
  01436	88 44 24 46	 mov	 BYTE PTR a$5[rsp+6], al

; 122  : 	output[7] = ((char)(value));

  0143a	88 54 24 47	 mov	 BYTE PTR a$5[rsp+7], dl

; 1151 : 			convertToChar(y, a);
; 1152 : 			outFile.write(a, 8);

  0143e	41 b8 08 00 00
	00		 mov	 r8d, 8
  01444	48 8d 54 24 40	 lea	 rdx, QWORD PTR a$5[rsp]

; 1153 : 			outFile.flush();

  01449	e9 50 05 00 00	 jmp	 $LN318@main
$LN296@main:

; 1154 : 		}
; 1155 : 	}
; 1156 : 	else //decoding
; 1157 : 	{
; 1158 : 		int bytesRead = 0;
; 1159 : 		char in[9] = { 0 };

  0144e	c6 44 24 20 00	 mov	 BYTE PTR in$1[rsp], 0
  01453	33 c0		 xor	 eax, eax
  01455	48 89 44 24 21	 mov	 QWORD PTR in$1[rsp+1], rax

; 1160 : 		char a[9] = { 0 };

  0145a	88 44 24 30	 mov	 BYTE PTR a$3[rsp], al
  0145e	48 89 44 24 31	 mov	 QWORD PTR a$3[rsp+1], rax

; 1161 : 		inFile.read(in, 8);

  01463	44 8d 40 08	 lea	 r8d, QWORD PTR [rax+8]
  01467	48 8d 54 24 20	 lea	 rdx, QWORD PTR in$1[rsp]
  0146c	48 8d 4d 80	 lea	 rcx, QWORD PTR inFile$[rbp-256]
  01470	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@PEAD_J@Z

; 1162 : 		bytesRead += 8;

  01476	bb 08 00 00 00	 mov	 ebx, 8

; 1163 : 
; 1164 : 		uint64_t y = 0;
; 1165 : 		y |= (((uint64_t)in[0] << 56) & 0xFF00000000000000)

  0147b	48 0f be 44 24
	21		 movsx	 rax, BYTE PTR in$1[rsp+1]

; 1193 : 		y = runIt(y, 1);

  01481	44 0f b6 c0	 movzx	 r8d, al

; 1163 : 
; 1164 : 		uint64_t y = 0;
; 1165 : 		y |= (((uint64_t)in[0] << 56) & 0xFF00000000000000)

  01485	48 0f be 44 24
	20		 movsx	 rax, BYTE PTR in$1[rsp]

; 1193 : 		y = runIt(y, 1);

  0148b	48 c1 e0 08	 shl	 rax, 8
  0148f	4c 0b c0	 or	 r8, rax

; 1163 : 
; 1164 : 		uint64_t y = 0;
; 1165 : 		y |= (((uint64_t)in[0] << 56) & 0xFF00000000000000)

  01492	49 c1 e0 08	 shl	 r8, 8
  01496	48 0f be 44 24
	22		 movsx	 rax, BYTE PTR in$1[rsp+2]

; 1193 : 		y = runIt(y, 1);

  0149c	0f b6 c8	 movzx	 ecx, al
  0149f	4c 0b c1	 or	 r8, rcx

; 1163 : 
; 1164 : 		uint64_t y = 0;
; 1165 : 		y |= (((uint64_t)in[0] << 56) & 0xFF00000000000000)

  014a2	49 c1 e0 08	 shl	 r8, 8
  014a6	48 0f be 44 24
	23		 movsx	 rax, BYTE PTR in$1[rsp+3]

; 1193 : 		y = runIt(y, 1);

  014ac	0f b6 c8	 movzx	 ecx, al
  014af	4c 0b c1	 or	 r8, rcx

; 1163 : 
; 1164 : 		uint64_t y = 0;
; 1165 : 		y |= (((uint64_t)in[0] << 56) & 0xFF00000000000000)

  014b2	49 c1 e0 08	 shl	 r8, 8
  014b6	48 0f be 44 24
	24		 movsx	 rax, BYTE PTR in$1[rsp+4]

; 1193 : 		y = runIt(y, 1);

  014bc	0f b6 c8	 movzx	 ecx, al
  014bf	49 0b c8	 or	 rcx, r8

; 1163 : 
; 1164 : 		uint64_t y = 0;
; 1165 : 		y |= (((uint64_t)in[0] << 56) & 0xFF00000000000000)

  014c2	48 c1 e1 08	 shl	 rcx, 8
  014c6	48 0f be 44 24
	25		 movsx	 rax, BYTE PTR in$1[rsp+5]

; 1193 : 		y = runIt(y, 1);

  014cc	0f b6 d0	 movzx	 edx, al
  014cf	48 0b ca	 or	 rcx, rdx

; 1163 : 
; 1164 : 		uint64_t y = 0;
; 1165 : 		y |= (((uint64_t)in[0] << 56) & 0xFF00000000000000)

  014d2	48 c1 e1 08	 shl	 rcx, 8
  014d6	48 0f be 44 24
	26		 movsx	 rax, BYTE PTR in$1[rsp+6]

; 1193 : 		y = runIt(y, 1);

  014dc	0f b6 d0	 movzx	 edx, al
  014df	48 0b ca	 or	 rcx, rdx

; 1163 : 
; 1164 : 		uint64_t y = 0;
; 1165 : 		y |= (((uint64_t)in[0] << 56) & 0xFF00000000000000)

  014e2	48 c1 e1 08	 shl	 rcx, 8
  014e6	48 0f be 44 24
	27		 movsx	 rax, BYTE PTR in$1[rsp+7]
  014ec	0f b6 d0	 movzx	 edx, al
  014ef	48 0b ca	 or	 rcx, rdx

; 1166 : 			| (((uint64_t)in[1] << 48) & 0x00FF000000000000)
; 1167 : 			| (((uint64_t)in[2] << 40) & 0x0000FF0000000000)
; 1168 : 			| (((uint64_t)in[3] << 32) & 0x000000FF00000000)
; 1169 : 			| (((uint64_t)in[4] << 24) & 0x00000000FF000000)
; 1170 : 			| (((uint64_t)in[5] << 16) & 0x0000000000FF0000)
; 1171 : 			| (((uint64_t)in[6] << 8) & 0x000000000000FF00)
; 1172 : 			| (((uint64_t)in[7]) & 0x00000000000000FF);
; 1173 : 
; 1174 : 
; 1175 : 		y = permutation1(y);

  014f2	e8 00 00 00 00	 call	 ?permutation1@@YA_K_K@Z	; permutation1
  014f7	48 8b c8	 mov	 rcx, rax

; 1176 : 
; 1177 : 		//The 16 Feistel rounds
; 1178 : 		y = runIt(y, 16);

  014fa	8d 53 08	 lea	 edx, QWORD PTR [rbx+8]
  014fd	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  01502	48 8b c8	 mov	 rcx, rax

; 1179 : 		y = runIt(y, 15);

  01505	8d 53 07	 lea	 edx, QWORD PTR [rbx+7]
  01508	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  0150d	48 8b c8	 mov	 rcx, rax

; 1180 : 		y = runIt(y, 14);

  01510	8d 53 06	 lea	 edx, QWORD PTR [rbx+6]
  01513	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  01518	48 8b c8	 mov	 rcx, rax

; 1181 : 		y = runIt(y, 13);

  0151b	8d 53 05	 lea	 edx, QWORD PTR [rbx+5]
  0151e	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  01523	48 8b c8	 mov	 rcx, rax

; 1182 : 		y = runIt(y, 12);

  01526	8d 53 04	 lea	 edx, QWORD PTR [rbx+4]
  01529	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  0152e	48 8b c8	 mov	 rcx, rax

; 1183 : 		y = runIt(y, 11);

  01531	8d 53 03	 lea	 edx, QWORD PTR [rbx+3]
  01534	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  01539	48 8b c8	 mov	 rcx, rax

; 1184 : 		y = runIt(y, 10);

  0153c	8d 53 02	 lea	 edx, QWORD PTR [rbx+2]
  0153f	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  01544	48 8b c8	 mov	 rcx, rax

; 1185 : 		y = runIt(y, 9);

  01547	8d 53 01	 lea	 edx, QWORD PTR [rbx+1]
  0154a	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  0154f	48 8b c8	 mov	 rcx, rax

; 1186 : 		y = runIt(y, 8);

  01552	8b d3		 mov	 edx, ebx
  01554	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  01559	48 8b c8	 mov	 rcx, rax

; 1187 : 		y = runIt(y, 7);

  0155c	8d 53 ff	 lea	 edx, QWORD PTR [rbx-1]
  0155f	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  01564	48 8b c8	 mov	 rcx, rax

; 1188 : 		y = runIt(y, 6);

  01567	8d 53 fe	 lea	 edx, QWORD PTR [rbx-2]
  0156a	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  0156f	48 8b c8	 mov	 rcx, rax

; 1189 : 		y = runIt(y, 5);

  01572	8d 53 fd	 lea	 edx, QWORD PTR [rbx-3]
  01575	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  0157a	48 8b c8	 mov	 rcx, rax

; 1190 : 		y = runIt(y, 4);

  0157d	8d 53 fc	 lea	 edx, QWORD PTR [rbx-4]
  01580	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  01585	48 8b c8	 mov	 rcx, rax

; 1191 : 		y = runIt(y, 3);

  01588	8d 53 fb	 lea	 edx, QWORD PTR [rbx-5]
  0158b	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  01590	48 8b c8	 mov	 rcx, rax

; 1192 : 		y = runIt(y, 2);

  01593	8d 53 fa	 lea	 edx, QWORD PTR [rbx-6]
  01596	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  0159b	48 8b c8	 mov	 rcx, rax

; 1193 : 		y = runIt(y, 1);

  0159e	8d 53 f9	 lea	 edx, QWORD PTR [rbx-7]
  015a1	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt

; 1194 : 
; 1195 : 		uint64_t right = y & 0x00000000FFFFFFFF;

  015a6	8b c8		 mov	 ecx, eax

; 1196 : 
; 1197 : 		//the last swap after the last round
; 1198 : 		y = (y >> 32) | (right << 32);

  015a8	48 c1 e1 20	 shl	 rcx, 32			; 00000020H
  015ac	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  015b0	48 0b c8	 or	 rcx, rax

; 1199 : 
; 1200 : 		y = finalPermutation(y);

  015b3	e8 00 00 00 00	 call	 ?finalPermutation@@YA_K_K@Z ; finalPermutation

; 1201 : 
; 1202 : 		uint64_t realFileSize = y & 0x00000000FFFFFFFF;

  015b8	8b f0		 mov	 esi, eax

; 1203 : 
; 1204 : 		while (fileSize - bytesRead > 8)

  015ba	8d 47 f8	 lea	 eax, DWORD PTR [rdi-8]
  015bd	3b c3		 cmp	 eax, ebx
  015bf	0f 86 04 02 00
	00		 jbe	 $LN7@main
  015c5	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL6@main:

; 1205 : 		{
; 1206 : 			inFile.read(in, 8);

  015d0	41 b8 08 00 00
	00		 mov	 r8d, 8
  015d6	48 8d 54 24 20	 lea	 rdx, QWORD PTR in$1[rsp]
  015db	48 8d 4d 80	 lea	 rcx, QWORD PTR inFile$[rbp-256]
  015df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@PEAD_J@Z

; 1207 : 			bytesRead += 8;

  015e5	83 c3 08	 add	 ebx, 8

; 1208 : 
; 1209 : 			uint64_t y = 0;
; 1210 : 			y |= (((uint64_t)in[0] << 56)  & 0xFF00000000000000)

  015e8	48 0f be 44 24
	21		 movsx	 rax, BYTE PTR in$1[rsp+1]

; 1237 : 			y = runIt(y, 1);

  015ee	44 0f b6 c0	 movzx	 r8d, al

; 1208 : 
; 1209 : 			uint64_t y = 0;
; 1210 : 			y |= (((uint64_t)in[0] << 56)  & 0xFF00000000000000)

  015f2	48 0f be 44 24
	20		 movsx	 rax, BYTE PTR in$1[rsp]

; 1237 : 			y = runIt(y, 1);

  015f8	48 c1 e0 08	 shl	 rax, 8
  015fc	4c 0b c0	 or	 r8, rax

; 1208 : 
; 1209 : 			uint64_t y = 0;
; 1210 : 			y |= (((uint64_t)in[0] << 56)  & 0xFF00000000000000)

  015ff	49 c1 e0 08	 shl	 r8, 8
  01603	48 0f be 44 24
	22		 movsx	 rax, BYTE PTR in$1[rsp+2]

; 1237 : 			y = runIt(y, 1);

  01609	0f b6 c8	 movzx	 ecx, al
  0160c	4c 0b c1	 or	 r8, rcx

; 1208 : 
; 1209 : 			uint64_t y = 0;
; 1210 : 			y |= (((uint64_t)in[0] << 56)  & 0xFF00000000000000)

  0160f	49 c1 e0 08	 shl	 r8, 8
  01613	48 0f be 44 24
	23		 movsx	 rax, BYTE PTR in$1[rsp+3]

; 1237 : 			y = runIt(y, 1);

  01619	0f b6 c8	 movzx	 ecx, al
  0161c	4c 0b c1	 or	 r8, rcx

; 1208 : 
; 1209 : 			uint64_t y = 0;
; 1210 : 			y |= (((uint64_t)in[0] << 56)  & 0xFF00000000000000)

  0161f	49 c1 e0 08	 shl	 r8, 8
  01623	48 0f be 44 24
	24		 movsx	 rax, BYTE PTR in$1[rsp+4]

; 1237 : 			y = runIt(y, 1);

  01629	0f b6 c8	 movzx	 ecx, al
  0162c	49 0b c8	 or	 rcx, r8

; 1208 : 
; 1209 : 			uint64_t y = 0;
; 1210 : 			y |= (((uint64_t)in[0] << 56)  & 0xFF00000000000000)

  0162f	48 c1 e1 08	 shl	 rcx, 8
  01633	48 0f be 44 24
	25		 movsx	 rax, BYTE PTR in$1[rsp+5]

; 1237 : 			y = runIt(y, 1);

  01639	0f b6 d0	 movzx	 edx, al
  0163c	48 0b ca	 or	 rcx, rdx

; 1208 : 
; 1209 : 			uint64_t y = 0;
; 1210 : 			y |= (((uint64_t)in[0] << 56)  & 0xFF00000000000000)

  0163f	48 c1 e1 08	 shl	 rcx, 8
  01643	48 0f be 44 24
	26		 movsx	 rax, BYTE PTR in$1[rsp+6]

; 1237 : 			y = runIt(y, 1);

  01649	0f b6 d0	 movzx	 edx, al
  0164c	48 0b ca	 or	 rcx, rdx

; 1208 : 
; 1209 : 			uint64_t y = 0;
; 1210 : 			y |= (((uint64_t)in[0] << 56)  & 0xFF00000000000000)

  0164f	48 c1 e1 08	 shl	 rcx, 8
  01653	48 0f be 44 24
	27		 movsx	 rax, BYTE PTR in$1[rsp+7]
  01659	0f b6 d0	 movzx	 edx, al
  0165c	48 0b ca	 or	 rcx, rdx

; 1211 : 				| (((uint64_t)in[1] << 48) & 0x00FF000000000000)
; 1212 : 				| (((uint64_t)in[2] << 40) & 0x0000FF0000000000)
; 1213 : 				| (((uint64_t)in[3] << 32) & 0x000000FF00000000)
; 1214 : 				| (((uint64_t)in[4] << 24) & 0x00000000FF000000)
; 1215 : 				| (((uint64_t)in[5] << 16) & 0x0000000000FF0000)
; 1216 : 				| (((uint64_t)in[6] << 8)  & 0x000000000000FF00)
; 1217 : 				| (((uint64_t)in[7])	   & 0x00000000000000FF);
; 1218 : 
; 1219 : 			y = permutation1(y);

  0165f	e8 00 00 00 00	 call	 ?permutation1@@YA_K_K@Z	; permutation1
  01664	48 8b c8	 mov	 rcx, rax

; 1220 : 
; 1221 : 			//The 16 Feistel rounds
; 1222 : 			y = runIt(y, 16);

  01667	ba 10 00 00 00	 mov	 edx, 16
  0166c	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  01671	48 8b c8	 mov	 rcx, rax

; 1223 : 			y = runIt(y, 15);

  01674	ba 0f 00 00 00	 mov	 edx, 15
  01679	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  0167e	48 8b c8	 mov	 rcx, rax

; 1224 : 			y = runIt(y, 14);

  01681	ba 0e 00 00 00	 mov	 edx, 14
  01686	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  0168b	48 8b c8	 mov	 rcx, rax

; 1225 : 			y = runIt(y, 13);

  0168e	ba 0d 00 00 00	 mov	 edx, 13
  01693	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  01698	48 8b c8	 mov	 rcx, rax

; 1226 : 			y = runIt(y, 12);

  0169b	ba 0c 00 00 00	 mov	 edx, 12
  016a0	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  016a5	48 8b c8	 mov	 rcx, rax

; 1227 : 			y = runIt(y, 11);

  016a8	ba 0b 00 00 00	 mov	 edx, 11
  016ad	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  016b2	48 8b c8	 mov	 rcx, rax

; 1228 : 			y = runIt(y, 10);

  016b5	ba 0a 00 00 00	 mov	 edx, 10
  016ba	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  016bf	48 8b c8	 mov	 rcx, rax

; 1229 : 			y = runIt(y, 9);

  016c2	ba 09 00 00 00	 mov	 edx, 9
  016c7	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  016cc	48 8b c8	 mov	 rcx, rax

; 1230 : 			y = runIt(y, 8);

  016cf	ba 08 00 00 00	 mov	 edx, 8
  016d4	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  016d9	48 8b c8	 mov	 rcx, rax

; 1231 : 			y = runIt(y, 7);

  016dc	ba 07 00 00 00	 mov	 edx, 7
  016e1	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  016e6	48 8b c8	 mov	 rcx, rax

; 1232 : 			y = runIt(y, 6);

  016e9	ba 06 00 00 00	 mov	 edx, 6
  016ee	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  016f3	48 8b c8	 mov	 rcx, rax

; 1233 : 			y = runIt(y, 5);

  016f6	ba 05 00 00 00	 mov	 edx, 5
  016fb	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  01700	48 8b c8	 mov	 rcx, rax

; 1234 : 			y = runIt(y, 4);

  01703	ba 04 00 00 00	 mov	 edx, 4
  01708	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  0170d	48 8b c8	 mov	 rcx, rax

; 1235 : 			y = runIt(y, 3);

  01710	ba 03 00 00 00	 mov	 edx, 3
  01715	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  0171a	48 8b c8	 mov	 rcx, rax

; 1236 : 			y = runIt(y, 2);

  0171d	ba 02 00 00 00	 mov	 edx, 2
  01722	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  01727	48 8b c8	 mov	 rcx, rax

; 1237 : 			y = runIt(y, 1);

  0172a	ba 01 00 00 00	 mov	 edx, 1
  0172f	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt

; 1238 : 
; 1239 : 			uint64_t right = y & 0x00000000FFFFFFFF;

  01734	8b c8		 mov	 ecx, eax

; 1240 : 
; 1241 : 			//the last swap after the last round
; 1242 : 			y = (y >> 32) | (right << 32);

  01736	48 c1 e1 20	 shl	 rcx, 32			; 00000020H
  0173a	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  0173e	48 0b c8	 or	 rcx, rax

; 1243 : 
; 1244 : 			y = finalPermutation(y);

  01741	e8 00 00 00 00	 call	 ?finalPermutation@@YA_K_K@Z ; finalPermutation
  01746	48 8b d0	 mov	 rdx, rax

; 115  : 	output[0] = ((char)(value >> 56));

  01749	48 8b c8	 mov	 rcx, rax
  0174c	48 c1 e9 38	 shr	 rcx, 56			; 00000038H
  01750	88 4c 24 30	 mov	 BYTE PTR a$3[rsp], cl

; 116  : 	output[1] = ((char)(value >> 48));

  01754	48 8b c8	 mov	 rcx, rax
  01757	48 c1 e9 30	 shr	 rcx, 48			; 00000030H
  0175b	88 4c 24 31	 mov	 BYTE PTR a$3[rsp+1], cl

; 117  : 	output[2] = ((char)(value >> 40));

  0175f	48 8b c8	 mov	 rcx, rax
  01762	48 c1 e9 28	 shr	 rcx, 40			; 00000028H
  01766	88 4c 24 32	 mov	 BYTE PTR a$3[rsp+2], cl

; 118  : 	output[3] = ((char)(value >> 32));

  0176a	48 8b c8	 mov	 rcx, rax
  0176d	48 c1 e9 20	 shr	 rcx, 32			; 00000020H
  01771	88 4c 24 33	 mov	 BYTE PTR a$3[rsp+3], cl

; 119  : 	output[4] = ((char)(value >> 24));

  01775	48 8b c8	 mov	 rcx, rax
  01778	48 c1 e9 18	 shr	 rcx, 24
  0177c	88 4c 24 34	 mov	 BYTE PTR a$3[rsp+4], cl

; 120  : 	output[5] = ((char)(value >> 16));

  01780	48 c1 e8 10	 shr	 rax, 16
  01784	88 44 24 35	 mov	 BYTE PTR a$3[rsp+5], al

; 121  : 	output[6] = ((char)(value >> 8));

  01788	48 8b c2	 mov	 rax, rdx
  0178b	48 c1 e8 08	 shr	 rax, 8
  0178f	88 44 24 36	 mov	 BYTE PTR a$3[rsp+6], al

; 122  : 	output[7] = ((char)(value));

  01793	88 54 24 37	 mov	 BYTE PTR a$3[rsp+7], dl

; 1245 : 			
; 1246 : 			convertToChar(y, a);
; 1247 : 			outFile.write(a, 8);

  01797	41 b8 08 00 00
	00		 mov	 r8d, 8
  0179d	48 8d 54 24 30	 lea	 rdx, QWORD PTR a$3[rsp]
  017a2	48 8d 8d c0 00
	00 00		 lea	 rcx, QWORD PTR outFile$[rbp-240]
  017a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?write@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@PEBD_J@Z

; 1248 : 			outFile.flush();

  017af	48 8d 8d c0 00
	00 00		 lea	 rcx, QWORD PTR outFile$[rbp-240]
  017b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ

; 1203 : 
; 1204 : 		while (fileSize - bytesRead > 8)

  017bc	8b c7		 mov	 eax, edi
  017be	2b c3		 sub	 eax, ebx
  017c0	83 f8 08	 cmp	 eax, 8
  017c3	0f 87 07 fe ff
	ff		 ja	 $LL6@main
$LN7@main:

; 1249 : 		}
; 1250 : 		if (realFileSize % 8 != 0) //we still have another block to read in with only partially important data

  017c9	83 e6 07	 and	 esi, 7
  017cc	0f 84 e6 01 00
	00		 je	 $LN169@main

; 1251 : 		{
; 1252 : 			inFile.read(in, 8);

  017d2	41 b8 08 00 00
	00		 mov	 r8d, 8
  017d8	48 8d 54 24 20	 lea	 rdx, QWORD PTR in$1[rsp]
  017dd	48 8d 4d 80	 lea	 rcx, QWORD PTR inFile$[rbp-256]
  017e1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@PEAD_J@Z

; 1253 : 			bytesRead += 8;
; 1254 : 
; 1255 : 			uint64_t y = 0;
; 1256 : 			y |= (((uint64_t)in[0] << 56) & 0xFF00000000000000)

  017e7	48 0f be 44 24
	21		 movsx	 rax, BYTE PTR in$1[rsp+1]

; 1283 : 			y = runIt(y, 1);

  017ed	44 0f b6 c0	 movzx	 r8d, al

; 1253 : 			bytesRead += 8;
; 1254 : 
; 1255 : 			uint64_t y = 0;
; 1256 : 			y |= (((uint64_t)in[0] << 56) & 0xFF00000000000000)

  017f1	48 0f be 44 24
	20		 movsx	 rax, BYTE PTR in$1[rsp]

; 1283 : 			y = runIt(y, 1);

  017f7	48 c1 e0 08	 shl	 rax, 8
  017fb	4c 0b c0	 or	 r8, rax

; 1253 : 			bytesRead += 8;
; 1254 : 
; 1255 : 			uint64_t y = 0;
; 1256 : 			y |= (((uint64_t)in[0] << 56) & 0xFF00000000000000)

  017fe	49 c1 e0 08	 shl	 r8, 8
  01802	48 0f be 44 24
	22		 movsx	 rax, BYTE PTR in$1[rsp+2]

; 1283 : 			y = runIt(y, 1);

  01808	0f b6 c8	 movzx	 ecx, al
  0180b	4c 0b c1	 or	 r8, rcx

; 1253 : 			bytesRead += 8;
; 1254 : 
; 1255 : 			uint64_t y = 0;
; 1256 : 			y |= (((uint64_t)in[0] << 56) & 0xFF00000000000000)

  0180e	49 c1 e0 08	 shl	 r8, 8
  01812	48 0f be 44 24
	23		 movsx	 rax, BYTE PTR in$1[rsp+3]

; 1283 : 			y = runIt(y, 1);

  01818	0f b6 c8	 movzx	 ecx, al
  0181b	4c 0b c1	 or	 r8, rcx

; 1253 : 			bytesRead += 8;
; 1254 : 
; 1255 : 			uint64_t y = 0;
; 1256 : 			y |= (((uint64_t)in[0] << 56) & 0xFF00000000000000)

  0181e	49 c1 e0 08	 shl	 r8, 8
  01822	48 0f be 44 24
	24		 movsx	 rax, BYTE PTR in$1[rsp+4]

; 1283 : 			y = runIt(y, 1);

  01828	0f b6 c8	 movzx	 ecx, al
  0182b	49 0b c8	 or	 rcx, r8

; 1253 : 			bytesRead += 8;
; 1254 : 
; 1255 : 			uint64_t y = 0;
; 1256 : 			y |= (((uint64_t)in[0] << 56) & 0xFF00000000000000)

  0182e	48 c1 e1 08	 shl	 rcx, 8
  01832	48 0f be 44 24
	25		 movsx	 rax, BYTE PTR in$1[rsp+5]

; 1283 : 			y = runIt(y, 1);

  01838	0f b6 d0	 movzx	 edx, al
  0183b	48 0b ca	 or	 rcx, rdx

; 1253 : 			bytesRead += 8;
; 1254 : 
; 1255 : 			uint64_t y = 0;
; 1256 : 			y |= (((uint64_t)in[0] << 56) & 0xFF00000000000000)

  0183e	48 c1 e1 08	 shl	 rcx, 8
  01842	48 0f be 44 24
	26		 movsx	 rax, BYTE PTR in$1[rsp+6]

; 1283 : 			y = runIt(y, 1);

  01848	0f b6 d0	 movzx	 edx, al
  0184b	48 0b ca	 or	 rcx, rdx

; 1253 : 			bytesRead += 8;
; 1254 : 
; 1255 : 			uint64_t y = 0;
; 1256 : 			y |= (((uint64_t)in[0] << 56) & 0xFF00000000000000)

  0184e	48 c1 e1 08	 shl	 rcx, 8
  01852	48 0f be 44 24
	27		 movsx	 rax, BYTE PTR in$1[rsp+7]
  01858	0f b6 d0	 movzx	 edx, al
  0185b	48 0b ca	 or	 rcx, rdx

; 1257 : 				| (((uint64_t)in[1] << 48) & 0x00FF000000000000)
; 1258 : 				| (((uint64_t)in[2] << 40) & 0x0000FF0000000000)
; 1259 : 				| (((uint64_t)in[3] << 32) & 0x000000FF00000000)
; 1260 : 				| (((uint64_t)in[4] << 24) & 0x00000000FF000000)
; 1261 : 				| (((uint64_t)in[5] << 16) & 0x0000000000FF0000)
; 1262 : 				| (((uint64_t)in[6] << 8) & 0x000000000000FF00)
; 1263 : 				| (((uint64_t)in[7]) & 0x00000000000000FF);
; 1264 : 
; 1265 : 			y = permutation1(y);

  0185e	e8 00 00 00 00	 call	 ?permutation1@@YA_K_K@Z	; permutation1
  01863	48 8b c8	 mov	 rcx, rax

; 1266 : 
; 1267 : 			//The 16 Feistel rounds
; 1268 : 			y = runIt(y, 16);

  01866	ba 10 00 00 00	 mov	 edx, 16
  0186b	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  01870	48 8b c8	 mov	 rcx, rax

; 1269 : 			y = runIt(y, 15);

  01873	ba 0f 00 00 00	 mov	 edx, 15
  01878	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  0187d	48 8b c8	 mov	 rcx, rax

; 1270 : 			y = runIt(y, 14);

  01880	ba 0e 00 00 00	 mov	 edx, 14
  01885	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  0188a	48 8b c8	 mov	 rcx, rax

; 1271 : 			y = runIt(y, 13);

  0188d	ba 0d 00 00 00	 mov	 edx, 13
  01892	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  01897	48 8b c8	 mov	 rcx, rax

; 1272 : 			y = runIt(y, 12);

  0189a	ba 0c 00 00 00	 mov	 edx, 12
  0189f	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  018a4	48 8b c8	 mov	 rcx, rax

; 1273 : 			y = runIt(y, 11);

  018a7	ba 0b 00 00 00	 mov	 edx, 11
  018ac	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  018b1	48 8b c8	 mov	 rcx, rax

; 1274 : 			y = runIt(y, 10);

  018b4	ba 0a 00 00 00	 mov	 edx, 10
  018b9	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  018be	48 8b c8	 mov	 rcx, rax

; 1275 : 			y = runIt(y, 9);

  018c1	ba 09 00 00 00	 mov	 edx, 9
  018c6	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  018cb	48 8b c8	 mov	 rcx, rax

; 1276 : 			y = runIt(y, 8);

  018ce	ba 08 00 00 00	 mov	 edx, 8
  018d3	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  018d8	48 8b c8	 mov	 rcx, rax

; 1277 : 			y = runIt(y, 7);

  018db	ba 07 00 00 00	 mov	 edx, 7
  018e0	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  018e5	48 8b c8	 mov	 rcx, rax

; 1278 : 			y = runIt(y, 6);

  018e8	ba 06 00 00 00	 mov	 edx, 6
  018ed	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  018f2	48 8b c8	 mov	 rcx, rax

; 1279 : 			y = runIt(y, 5);

  018f5	ba 05 00 00 00	 mov	 edx, 5
  018fa	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  018ff	48 8b c8	 mov	 rcx, rax

; 1280 : 			y = runIt(y, 4);

  01902	ba 04 00 00 00	 mov	 edx, 4
  01907	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  0190c	48 8b c8	 mov	 rcx, rax

; 1281 : 			y = runIt(y, 3);

  0190f	ba 03 00 00 00	 mov	 edx, 3
  01914	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  01919	48 8b c8	 mov	 rcx, rax

; 1282 : 			y = runIt(y, 2);

  0191c	ba 02 00 00 00	 mov	 edx, 2
  01921	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt
  01926	48 8b c8	 mov	 rcx, rax

; 1283 : 			y = runIt(y, 1);

  01929	ba 01 00 00 00	 mov	 edx, 1
  0192e	e8 00 00 00 00	 call	 ?runIt@@YA_K_KH@Z	; runIt

; 1284 : 
; 1285 : 			uint64_t right = y & 0x00000000FFFFFFFF;

  01933	8b c8		 mov	 ecx, eax

; 1286 : 
; 1287 : 			//the last swap after the last round
; 1288 : 			y = (y >> 32) | (right << 32);

  01935	48 c1 e1 20	 shl	 rcx, 32			; 00000020H
  01939	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  0193d	48 0b c8	 or	 rcx, rax

; 1289 : 
; 1290 : 			y = finalPermutation(y);

  01940	e8 00 00 00 00	 call	 ?finalPermutation@@YA_K_K@Z ; finalPermutation
  01945	48 8b d0	 mov	 rdx, rax

; 115  : 	output[0] = ((char)(value >> 56));

  01948	48 8b c8	 mov	 rcx, rax
  0194b	48 c1 e9 38	 shr	 rcx, 56			; 00000038H
  0194f	88 4c 24 30	 mov	 BYTE PTR a$3[rsp], cl

; 116  : 	output[1] = ((char)(value >> 48));

  01953	48 8b c8	 mov	 rcx, rax
  01956	48 c1 e9 30	 shr	 rcx, 48			; 00000030H
  0195a	88 4c 24 31	 mov	 BYTE PTR a$3[rsp+1], cl

; 117  : 	output[2] = ((char)(value >> 40));

  0195e	48 8b c8	 mov	 rcx, rax
  01961	48 c1 e9 28	 shr	 rcx, 40			; 00000028H
  01965	88 4c 24 32	 mov	 BYTE PTR a$3[rsp+2], cl

; 118  : 	output[3] = ((char)(value >> 32));

  01969	48 8b c8	 mov	 rcx, rax
  0196c	48 c1 e9 20	 shr	 rcx, 32			; 00000020H
  01970	88 4c 24 33	 mov	 BYTE PTR a$3[rsp+3], cl

; 119  : 	output[4] = ((char)(value >> 24));

  01974	48 8b c8	 mov	 rcx, rax
  01977	48 c1 e9 18	 shr	 rcx, 24
  0197b	88 4c 24 34	 mov	 BYTE PTR a$3[rsp+4], cl

; 120  : 	output[5] = ((char)(value >> 16));

  0197f	48 c1 e8 10	 shr	 rax, 16
  01983	88 44 24 35	 mov	 BYTE PTR a$3[rsp+5], al

; 121  : 	output[6] = ((char)(value >> 8));

  01987	48 8b c2	 mov	 rax, rdx
  0198a	48 c1 e8 08	 shr	 rax, 8
  0198e	88 44 24 36	 mov	 BYTE PTR a$3[rsp+6], al

; 122  : 	output[7] = ((char)(value));

  01992	88 54 24 37	 mov	 BYTE PTR a$3[rsp+7], dl

; 1291 : 
; 1292 : 			convertToChar(y, a);
; 1293 : 			outFile.write(a, (realFileSize % 8));

  01996	44 8b c6	 mov	 r8d, esi
  01999	48 8d 54 24 30	 lea	 rdx, QWORD PTR a$3[rsp]
$LN318@main:
  0199e	48 8d 8d c0 00
	00 00		 lea	 rcx, QWORD PTR outFile$[rbp-240]
  019a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?write@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@PEBD_J@Z

; 1294 : 			outFile.flush();

  019ab	48 8d 8d c0 00
	00 00		 lea	 rcx, QWORD PTR outFile$[rbp-240]
  019b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ
$LN169@main:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream

; 1331 : 		if (_Filebuffer.close() == 0)

  019b8	48 8d 4d 98	 lea	 rcx, QWORD PTR inFile$[rbp-232]
  019bc	e8 00 00 00 00	 call	 ?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
  019c1	48 85 c0	 test	 rax, rax
  019c4	75 1c		 jne	 SHORT $LN218@main

; 1332 : 			_Myios::setstate(ios_base::failbit);

  019c6	48 8b 45 80	 mov	 rax, QWORD PTR inFile$[rbp-256]
  019ca	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  019ce	48 8d 45 80	 lea	 rax, QWORD PTR inFile$[rbp-256]
  019d2	48 03 c8	 add	 rcx, rax
  019d5	45 33 c0	 xor	 r8d, r8d
  019d8	41 8d 50 02	 lea	 edx, QWORD PTR [r8+2]
  019dc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
$LN218@main:

; 1331 : 		if (_Filebuffer.close() == 0)

  019e2	48 8d 8d c8 00
	00 00		 lea	 rcx, QWORD PTR outFile$[rbp-232]
  019e9	e8 00 00 00 00	 call	 ?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
  019ee	48 85 c0	 test	 rax, rax
  019f1	75 22		 jne	 SHORT $LN221@main

; 1332 : 			_Myios::setstate(ios_base::failbit);

  019f3	48 8b 85 b0 00
	00 00		 mov	 rax, QWORD PTR outFile$[rbp-256]
  019fa	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  019fe	48 8d 85 b0 00
	00 00		 lea	 rax, QWORD PTR outFile$[rbp-256]
  01a05	48 03 c8	 add	 rcx, rax
  01a08	45 33 c0	 xor	 r8d, r8d
  01a0b	41 8d 50 02	 lea	 edx, QWORD PTR [r8+2]
  01a0f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
$LN221@main:
; File c:\users\coschm\desktop\fall-2016\security\des\des\des\main.cpp

; 1302 : 	duration = (clock() - start) / (double)CLOCKS_PER_SEC;

  01a15	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clock
  01a1b	2b 85 58 02 00
	00		 sub	 eax, DWORD PTR start$1$[rbp-256]
  01a21	66 0f 6e f0	 movd	 xmm6, eax
  01a25	f3 0f e6 f6	 cvtdq2pd xmm6, xmm6
  01a29	f2 0f 5e 35 00
	00 00 00	 divsd	 xmm6, QWORD PTR __real@408f400000000000

; 1303 : 	cout << "Total time: " << duration << "s" << endl;

  01a31	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@LGHPBDLJ@Total?5time?3?5?$AA@
  01a38	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  01a3f	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  01a44	48 8b c8	 mov	 rcx, rax
  01a47	0f 28 ce	 movaps	 xmm1, xmm6
  01a4a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@N@Z
  01a50	48 8b c8	 mov	 rcx, rax
  01a53	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01LKDEMHDF@s?$AA@
  01a5a	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  01a5f	48 8b c8	 mov	 rcx, rax
  01a62	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  01a69	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z
  01a6f	90		 npad	 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream

; 1292 : 		{	// destroy the object

  01a70	48 8b 85 b0 00
	00 00		 mov	 rax, QWORD PTR outFile$[rbp-256]
  01a77	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  01a7b	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:??_7?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@
  01a82	48 89 9c 0d b0
	00 00 00	 mov	 QWORD PTR outFile$[rbp+rcx-256], rbx
  01a8a	48 8b 85 b0 00
	00 00		 mov	 rax, QWORD PTR outFile$[rbp-256]
  01a91	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  01a95	8d 91 48 ff ff
	ff		 lea	 edx, DWORD PTR [rcx-184]
  01a9b	89 94 0d ac 00
	00 00		 mov	 DWORD PTR outFile$[rbp+rcx-260], edx

; 1293 : 		}

  01aa2	48 8d 8d c8 00
	00 00		 lea	 rcx, QWORD PTR outFile$[rbp-232]
  01aa9	e8 00 00 00 00	 call	 ??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
  01aae	48 8d 8d d0 00
	00 00		 lea	 rcx, QWORD PTR outFile$[rbp-224]
  01ab5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UEAA@XZ
  01abb	48 8d 8d 68 01
	00 00		 lea	 rcx, QWORD PTR outFile$[rbp-72]
  01ac2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
  01ac8	90		 npad	 1

; 1292 : 		{	// destroy the object

  01ac9	48 8b 45 80	 mov	 rax, QWORD PTR inFile$[rbp-256]
  01acd	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  01ad1	48 89 5c 0d 80	 mov	 QWORD PTR inFile$[rbp+rcx-256], rbx
  01ad6	48 8b 45 80	 mov	 rax, QWORD PTR inFile$[rbp-256]
  01ada	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  01ade	8d 91 48 ff ff
	ff		 lea	 edx, DWORD PTR [rcx-184]
  01ae4	89 54 0c 7c	 mov	 DWORD PTR inFile$[rsp+rcx-4], edx

; 1293 : 		}

  01ae8	48 8d 4d 98	 lea	 rcx, QWORD PTR inFile$[rbp-232]
  01aec	e8 00 00 00 00	 call	 ??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
  01af1	48 8d 4d a0	 lea	 rcx, QWORD PTR inFile$[rbp-224]
  01af5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UEAA@XZ
  01afb	48 8d 4d 38	 lea	 rcx, QWORD PTR inFile$[rbp-72]
  01aff	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
; File c:\users\coschm\desktop\fall-2016\security\des\des\des\main.cpp

; 1304 : 	return 0;

  01b05	33 c0		 xor	 eax, eax
  01b07	e9 dd 00 00 00	 jmp	 $LN171@main
$LN108@main:

; 880  : 	{
; 881  : 		errorWithMessage("This is a weak key. Try again");

  01b0c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BO@EHAFNCKF@This?5is?5a?5weak?5key?4?5Try?5again?$AA@
  01b13	e8 00 00 00 00	 call	 ?errorWithMessage@@YAXPEAD@Z ; errorWithMessage
  01b18	cc		 int	 3
$LN105@main:

; 854  : 		}
; 855  : 		else errorWithMessage("Not a valid char value.");

  01b19	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@DPNHLANH@Not?5a?5valid?5char?5value?4?$AA@
  01b20	e8 00 00 00 00	 call	 ?errorWithMessage@@YAXPEAD@Z ; errorWithMessage
  01b25	cc		 int	 3
$LN99@main:

; 840  : 		}
; 841  : 		else errorWithMessage("Not a valid char value.");

  01b26	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@DPNHLANH@Not?5a?5valid?5char?5value?4?$AA@
  01b2d	e8 00 00 00 00	 call	 ?errorWithMessage@@YAXPEAD@Z ; errorWithMessage
  01b32	cc		 int	 3
$LN93@main:

; 826  : 		}
; 827  : 		else errorWithMessage("Not a valid char value.");

  01b33	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@DPNHLANH@Not?5a?5valid?5char?5value?4?$AA@
  01b3a	e8 00 00 00 00	 call	 ?errorWithMessage@@YAXPEAD@Z ; errorWithMessage
  01b3f	cc		 int	 3
$LN87@main:

; 812  : 		}
; 813  : 		else errorWithMessage("Not a valid char value.");

  01b40	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@DPNHLANH@Not?5a?5valid?5char?5value?4?$AA@
  01b47	e8 00 00 00 00	 call	 ?errorWithMessage@@YAXPEAD@Z ; errorWithMessage
  01b4c	cc		 int	 3
$LN81@main:

; 798  : 		}
; 799  : 		else errorWithMessage("Not a valid char value.");

  01b4d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@DPNHLANH@Not?5a?5valid?5char?5value?4?$AA@
  01b54	e8 00 00 00 00	 call	 ?errorWithMessage@@YAXPEAD@Z ; errorWithMessage
  01b59	cc		 int	 3
$LN75@main:

; 784  : 		}
; 785  : 		else errorWithMessage("Not a valid char value.");

  01b5a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@DPNHLANH@Not?5a?5valid?5char?5value?4?$AA@
  01b61	e8 00 00 00 00	 call	 ?errorWithMessage@@YAXPEAD@Z ; errorWithMessage
  01b66	cc		 int	 3
$LN69@main:

; 770  : 		}
; 771  : 		else errorWithMessage("Not a valid char value.");

  01b67	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@DPNHLANH@Not?5a?5valid?5char?5value?4?$AA@
  01b6e	e8 00 00 00 00	 call	 ?errorWithMessage@@YAXPEAD@Z ; errorWithMessage
  01b73	cc		 int	 3
$LN63@main:

; 756  : 		}
; 757  : 		else errorWithMessage("Not a valid char value.");

  01b74	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@DPNHLANH@Not?5a?5valid?5char?5value?4?$AA@
  01b7b	e8 00 00 00 00	 call	 ?errorWithMessage@@YAXPEAD@Z ; errorWithMessage
  01b80	cc		 int	 3
$LN57@main:

; 742  : 		}
; 743  : 		else errorWithMessage("Not a valid char value.");

  01b81	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@DPNHLANH@Not?5a?5valid?5char?5value?4?$AA@
  01b88	e8 00 00 00 00	 call	 ?errorWithMessage@@YAXPEAD@Z ; errorWithMessage
  01b8d	cc		 int	 3
$LN51@main:

; 728  : 		}
; 729  : 		else errorWithMessage("Not a valid char value.");

  01b8e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@DPNHLANH@Not?5a?5valid?5char?5value?4?$AA@
  01b95	e8 00 00 00 00	 call	 ?errorWithMessage@@YAXPEAD@Z ; errorWithMessage
  01b9a	cc		 int	 3
$LN45@main:

; 714  : 		}
; 715  : 		else errorWithMessage("Not a valid char value.");

  01b9b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@DPNHLANH@Not?5a?5valid?5char?5value?4?$AA@
  01ba2	e8 00 00 00 00	 call	 ?errorWithMessage@@YAXPEAD@Z ; errorWithMessage
  01ba7	cc		 int	 3
$LN39@main:

; 700  : 		}
; 701  : 		else errorWithMessage("Not a valid char value.");

  01ba8	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@DPNHLANH@Not?5a?5valid?5char?5value?4?$AA@
  01baf	e8 00 00 00 00	 call	 ?errorWithMessage@@YAXPEAD@Z ; errorWithMessage
  01bb4	cc		 int	 3
$LN33@main:

; 686  : 		}
; 687  : 		else errorWithMessage("Not a valid char value.");

  01bb5	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@DPNHLANH@Not?5a?5valid?5char?5value?4?$AA@
  01bbc	e8 00 00 00 00	 call	 ?errorWithMessage@@YAXPEAD@Z ; errorWithMessage
  01bc1	cc		 int	 3
$LN27@main:

; 672  : 		}
; 673  : 		else errorWithMessage("Not a valid char value.");

  01bc2	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@DPNHLANH@Not?5a?5valid?5char?5value?4?$AA@
  01bc9	e8 00 00 00 00	 call	 ?errorWithMessage@@YAXPEAD@Z ; errorWithMessage
  01bce	cc		 int	 3
$LN21@main:

; 658  : 		}
; 659  : 		else errorWithMessage("Not a valid char value.");

  01bcf	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@DPNHLANH@Not?5a?5valid?5char?5value?4?$AA@
  01bd6	e8 00 00 00 00	 call	 ?errorWithMessage@@YAXPEAD@Z ; errorWithMessage
  01bdb	cc		 int	 3
$LN15@main:

; 644  : 		}
; 645  : 		else errorWithMessage("Not a valid char value.");

  01bdc	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@DPNHLANH@Not?5a?5valid?5char?5value?4?$AA@
  01be3	e8 00 00 00 00	 call	 ?errorWithMessage@@YAXPEAD@Z ; errorWithMessage
  01be8	90		 npad	 1
$LN171@main:

; 1305 : }

  01be9	48 8b 9c 24 40
	03 00 00	 mov	 rbx, QWORD PTR [rsp+832]
  01bf1	0f 28 b4 24 f0
	02 00 00	 movaps	 xmm6, XMMWORD PTR [rsp+752]
  01bf9	48 81 c4 00 03
	00 00		 add	 rsp, 768		; 00000300H
  01c00	41 5f		 pop	 r15
  01c02	41 5e		 pop	 r14
  01c04	41 5d		 pop	 r13
  01c06	41 5c		 pop	 r12
  01c08	5f		 pop	 rdi
  01c09	5e		 pop	 rsi
  01c0a	5d		 pop	 rbp
  01c0b	c3		 ret	 0
$LN301@main:
main	ENDP
_TEXT	ENDS
text$x	SEGMENT
?keys@@3PA_KA$17 = 32
this$ = 32
in$1 = 32
in$2 = 32
?keys@@3PA_KA$16 = 48
a$3 = 48
fSizeOut$4 = 48
?keys@@3PA_KA$15 = 64
a$5 = 64
a$6 = 64
?keys@@3PA_KA$10 = 80
?keys@@3PA_KA$11 = 88
?keys@@3PA_KA$12 = 96
?keys@@3PA_KA$13 = 104
?keys@@3PA_KA$14 = 112
inFile$ = 128
$T7 = 416
outFile$ = 432
$T8 = 720
$T9 = 720
argc$ = 832
argv$ = 840
?keys@@3PA_KA$9 = 848
$T10 = 848
start$1$ = 856
main$dtor$2 PROC
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	8b 85 50 03 00
	00		 mov	 eax, DWORD PTR $T10[rbp]
  0000f	83 e0 01	 and	 eax, 1
  00012	85 c0		 test	 eax, eax
  00014	74 1b		 je	 SHORT $LN178@main$dtor$
  00016	83 a5 50 03 00
	00 fe		 and	 DWORD PTR $T10[rbp], -2
  0001d	48 8d 8d 80 00
	00 00		 lea	 rcx, QWORD PTR inFile$[rbp]
  00024	48 81 c1 b8 00
	00 00		 add	 rcx, 184		; 000000b8H
  0002b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
$LN178@main$dtor$:
  00031	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00035	5d		 pop	 rbp
  00036	c3		 ret	 0
main$dtor$2 ENDP
?keys@@3PA_KA$17 = 32
this$ = 32
in$1 = 32
in$2 = 32
?keys@@3PA_KA$16 = 48
a$3 = 48
fSizeOut$4 = 48
?keys@@3PA_KA$15 = 64
a$5 = 64
a$6 = 64
?keys@@3PA_KA$10 = 80
?keys@@3PA_KA$11 = 88
?keys@@3PA_KA$12 = 96
?keys@@3PA_KA$13 = 104
?keys@@3PA_KA$14 = 112
inFile$ = 128
$T7 = 416
outFile$ = 432
$T8 = 720
$T9 = 720
argc$ = 832
argv$ = 840
?keys@@3PA_KA$9 = 848
$T10 = 848
start$1$ = 856
main$dtor$3 PROC
  00037	48 8d 8a 80 00
	00 00		 lea	 rcx, QWORD PTR inFile$[rdx]
  0003e	48 83 c1 20	 add	 rcx, 32			; 00000020H
  00042	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UEAA@XZ
main$dtor$3 ENDP
?keys@@3PA_KA$17 = 32
this$ = 32
in$1 = 32
in$2 = 32
?keys@@3PA_KA$16 = 48
a$3 = 48
fSizeOut$4 = 48
?keys@@3PA_KA$15 = 64
a$5 = 64
a$6 = 64
?keys@@3PA_KA$10 = 80
?keys@@3PA_KA$11 = 88
?keys@@3PA_KA$12 = 96
?keys@@3PA_KA$13 = 104
?keys@@3PA_KA$14 = 112
inFile$ = 128
$T7 = 416
outFile$ = 432
$T8 = 720
$T9 = 720
argc$ = 832
argv$ = 840
?keys@@3PA_KA$9 = 848
$T10 = 848
start$1$ = 856
main$dtor$5 PROC
  00049	48 8b 8a 20 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00050	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
main$dtor$5 ENDP
?keys@@3PA_KA$17 = 32
this$ = 32
in$1 = 32
in$2 = 32
?keys@@3PA_KA$16 = 48
a$3 = 48
fSizeOut$4 = 48
?keys@@3PA_KA$15 = 64
a$5 = 64
a$6 = 64
?keys@@3PA_KA$10 = 80
?keys@@3PA_KA$11 = 88
?keys@@3PA_KA$12 = 96
?keys@@3PA_KA$13 = 104
?keys@@3PA_KA$14 = 112
inFile$ = 128
$T7 = 416
outFile$ = 432
$T8 = 720
$T9 = 720
argc$ = 832
argv$ = 840
?keys@@3PA_KA$9 = 848
$T10 = 848
start$1$ = 856
main$dtor$0 PROC
  00057	48 8d 8a 80 00
	00 00		 lea	 rcx, QWORD PTR inFile$[rdx]
  0005e	e9 00 00 00 00	 jmp	 ??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
main$dtor$0 ENDP
?keys@@3PA_KA$17 = 32
this$ = 32
in$1 = 32
in$2 = 32
?keys@@3PA_KA$16 = 48
a$3 = 48
fSizeOut$4 = 48
?keys@@3PA_KA$15 = 64
a$5 = 64
a$6 = 64
?keys@@3PA_KA$10 = 80
?keys@@3PA_KA$11 = 88
?keys@@3PA_KA$12 = 96
?keys@@3PA_KA$13 = 104
?keys@@3PA_KA$14 = 112
inFile$ = 128
$T7 = 416
outFile$ = 432
$T8 = 720
$T9 = 720
argc$ = 832
argv$ = 840
?keys@@3PA_KA$9 = 848
$T10 = 848
start$1$ = 856
main$dtor$1 PROC
  00063	48 8d 8a b0 01
	00 00		 lea	 rcx, QWORD PTR outFile$[rdx]
  0006a	e9 00 00 00 00	 jmp	 ??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
main$dtor$1 ENDP
text$x	ENDS
; Function compile flags: /Ogtpy
text$x	SEGMENT
?keys@@3PA_KA$17 = 32
this$ = 32
in$1 = 32
in$2 = 32
?keys@@3PA_KA$16 = 48
a$3 = 48
fSizeOut$4 = 48
?keys@@3PA_KA$15 = 64
a$5 = 64
a$6 = 64
?keys@@3PA_KA$10 = 80
?keys@@3PA_KA$11 = 88
?keys@@3PA_KA$12 = 96
?keys@@3PA_KA$13 = 104
?keys@@3PA_KA$14 = 112
inFile$ = 128
$T7 = 416
outFile$ = 432
$T8 = 720
$T9 = 720
argc$ = 832
argv$ = 840
?keys@@3PA_KA$9 = 848
$T10 = 848
start$1$ = 856
main$dtor$2 PROC
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	8b 85 50 03 00
	00		 mov	 eax, DWORD PTR $T10[rbp]
  0000f	83 e0 01	 and	 eax, 1
  00012	85 c0		 test	 eax, eax
  00014	74 1b		 je	 SHORT $LN178@main$dtor$
  00016	83 a5 50 03 00
	00 fe		 and	 DWORD PTR $T10[rbp], -2
  0001d	48 8d 8d 80 00
	00 00		 lea	 rcx, QWORD PTR inFile$[rbp]
  00024	48 81 c1 b8 00
	00 00		 add	 rcx, 184		; 000000b8H
  0002b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
$LN178@main$dtor$:
  00031	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00035	5d		 pop	 rbp
  00036	c3		 ret	 0
main$dtor$2 ENDP
text$x	ENDS
; Function compile flags: /Ogtpy
text$x	SEGMENT
?keys@@3PA_KA$17 = 32
this$ = 32
in$1 = 32
in$2 = 32
?keys@@3PA_KA$16 = 48
a$3 = 48
fSizeOut$4 = 48
?keys@@3PA_KA$15 = 64
a$5 = 64
a$6 = 64
?keys@@3PA_KA$10 = 80
?keys@@3PA_KA$11 = 88
?keys@@3PA_KA$12 = 96
?keys@@3PA_KA$13 = 104
?keys@@3PA_KA$14 = 112
inFile$ = 128
$T7 = 416
outFile$ = 432
$T8 = 720
$T9 = 720
argc$ = 832
argv$ = 840
?keys@@3PA_KA$9 = 848
$T10 = 848
start$1$ = 856
main$dtor$3 PROC
  00037	48 8d 8a 80 00
	00 00		 lea	 rcx, QWORD PTR inFile$[rdx]
  0003e	48 83 c1 20	 add	 rcx, 32			; 00000020H
  00042	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UEAA@XZ
main$dtor$3 ENDP
text$x	ENDS
; Function compile flags: /Ogtpy
text$x	SEGMENT
?keys@@3PA_KA$17 = 32
this$ = 32
in$1 = 32
in$2 = 32
?keys@@3PA_KA$16 = 48
a$3 = 48
fSizeOut$4 = 48
?keys@@3PA_KA$15 = 64
a$5 = 64
a$6 = 64
?keys@@3PA_KA$10 = 80
?keys@@3PA_KA$11 = 88
?keys@@3PA_KA$12 = 96
?keys@@3PA_KA$13 = 104
?keys@@3PA_KA$14 = 112
inFile$ = 128
$T7 = 416
outFile$ = 432
$T8 = 720
$T9 = 720
argc$ = 832
argv$ = 840
?keys@@3PA_KA$9 = 848
$T10 = 848
start$1$ = 856
main$dtor$5 PROC
  00049	48 8b 8a 20 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00050	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
main$dtor$5 ENDP
text$x	ENDS
; Function compile flags: /Ogtpy
text$x	SEGMENT
?keys@@3PA_KA$17 = 32
this$ = 32
in$1 = 32
in$2 = 32
?keys@@3PA_KA$16 = 48
a$3 = 48
fSizeOut$4 = 48
?keys@@3PA_KA$15 = 64
a$5 = 64
a$6 = 64
?keys@@3PA_KA$10 = 80
?keys@@3PA_KA$11 = 88
?keys@@3PA_KA$12 = 96
?keys@@3PA_KA$13 = 104
?keys@@3PA_KA$14 = 112
inFile$ = 128
$T7 = 416
outFile$ = 432
$T8 = 720
$T9 = 720
argc$ = 832
argv$ = 840
?keys@@3PA_KA$9 = 848
$T10 = 848
start$1$ = 856
main$dtor$0 PROC
  00057	48 8d 8a 80 00
	00 00		 lea	 rcx, QWORD PTR inFile$[rdx]
  0005e	e9 00 00 00 00	 jmp	 ??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
main$dtor$0 ENDP
text$x	ENDS
; Function compile flags: /Ogtpy
text$x	SEGMENT
?keys@@3PA_KA$17 = 32
this$ = 32
in$1 = 32
in$2 = 32
?keys@@3PA_KA$16 = 48
a$3 = 48
fSizeOut$4 = 48
?keys@@3PA_KA$15 = 64
a$5 = 64
a$6 = 64
?keys@@3PA_KA$10 = 80
?keys@@3PA_KA$11 = 88
?keys@@3PA_KA$12 = 96
?keys@@3PA_KA$13 = 104
?keys@@3PA_KA$14 = 112
inFile$ = 128
$T7 = 416
outFile$ = 432
$T8 = 720
$T9 = 720
argc$ = 832
argv$ = 840
?keys@@3PA_KA$9 = 848
$T10 = 848
start$1$ = 856
main$dtor$1 PROC
  00063	48 8d 8a b0 01
	00 00		 lea	 rcx, QWORD PTR outFile$[rdx]
  0006a	e9 00 00 00 00	 jmp	 ??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
main$dtor$1 ENDP
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\users\coschm\desktop\fall-2016\security\des\des\des\main.cpp
_TEXT	SEGMENT
y$ = 40
roundKey$ = 48
?runIt@@YA_K_KH@Z PROC					; runIt

; 392  : {

$LN68:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12
  00016	41 55		 push	 r13
  00018	41 56		 push	 r14
  0001a	41 57		 push	 r15

; 393  : 	uint64_t right = y & 0xFFFFFFFF;

  0001c	44 8b f1	 mov	 r14d, ecx
  0001f	4c 8b f9	 mov	 r15, rcx

; 394  : 	uint64_t left = (y >> 32);
; 395  : 	uint64_t nextLeft = right;
; 396  : 
; 397  : 	uint64_t expandedRight = 0;

  00022	33 ed		 xor	 ebp, ebp
  00024	49 c1 ef 20	 shr	 r15, 32			; 00000020H

; 398  : 	//expansion permutation of right side
; 399  : 	if (right & (1ULL << 31))//bit 1

  00028	b9 00 00 00 80	 mov	 ecx, -2147483648	; 80000000H
  0002d	48 63 c2	 movsxd	 rax, edx
  00030	4c 85 f1	 test	 r14, rcx
  00033	8b d5		 mov	 edx, ebp
  00035	48 b9 01 00 00
	00 00 40 00 00	 mov	 rcx, 70368744177665	; 0000400000000001H
  0003f	48 0f 45 d1	 cmovne	 rdx, rcx

; 400  : 	{
; 401  : 		expandedRight |= (1ULL << (48 - 2));
; 402  : 		expandedRight |= (1ULL << (48 - 48));
; 403  : 	}
; 404  : 	if (right & (1ULL << 30)) expandedRight |= (1ULL << (48 - 3)); //bit 2

  00043	49 0f ba e6 1e	 bt	 r14, 30
  00048	73 0d		 jae	 SHORT $LN3@runIt
  0004a	48 b9 00 00 00
	00 00 20 00 00	 mov	 rcx, 35184372088832	; 0000200000000000H
  00054	48 0b d1	 or	 rdx, rcx
$LN3@runIt:

; 405  : 	if (right & (1ULL << 29)) expandedRight |= (1ULL << (48 - 4)); //bit 3

  00057	49 0f ba e6 1d	 bt	 r14, 29
  0005c	73 0d		 jae	 SHORT $LN4@runIt
  0005e	48 b9 00 00 00
	00 00 10 00 00	 mov	 rcx, 17592186044416	; 0000100000000000H
  00068	48 0b d1	 or	 rdx, rcx
$LN4@runIt:

; 406  : 	if (right & (1ULL << 28)) //bit 4

  0006b	49 0f ba e6 1c	 bt	 r14, 28
  00070	73 0d		 jae	 SHORT $LN5@runIt

; 407  : 	{
; 408  : 		expandedRight |= (1ULL << (48 - 5));
; 409  : 		expandedRight |= (1ULL << (48 - 7));

  00072	48 b9 00 00 00
	00 00 0a 00 00	 mov	 rcx, 10995116277760	; 00000a0000000000H
  0007c	48 0b d1	 or	 rdx, rcx
$LN5@runIt:

; 410  : 	}
; 411  : 	if (right & (1ULL << 27)) //bit 5

  0007f	49 0f ba e6 1b	 bt	 r14, 27
  00084	73 0d		 jae	 SHORT $LN6@runIt

; 412  : 	{
; 413  : 		expandedRight |= (1ULL << (48 - 6));
; 414  : 		expandedRight |= (1ULL << (48 - 8));

  00086	48 b9 00 00 00
	00 00 05 00 00	 mov	 rcx, 5497558138880	; 0000050000000000H
  00090	48 0b d1	 or	 rdx, rcx
$LN6@runIt:

; 415  : 	}
; 416  : 	if (right & (1ULL << 26)) expandedRight |= (1ULL << (48 - 9)); //bit 6

  00093	49 0f ba e6 1a	 bt	 r14, 26
  00098	73 0d		 jae	 SHORT $LN7@runIt
  0009a	48 b9 00 00 00
	00 80 00 00 00	 mov	 rcx, 549755813888	; 0000008000000000H
  000a4	48 0b d1	 or	 rdx, rcx
$LN7@runIt:

; 417  : 	if (right & (1ULL << 25)) expandedRight |= (1ULL << (48 - 10)); //bit 7

  000a7	49 0f ba e6 19	 bt	 r14, 25
  000ac	73 0d		 jae	 SHORT $LN8@runIt
  000ae	48 b9 00 00 00
	00 40 00 00 00	 mov	 rcx, 274877906944	; 0000004000000000H
  000b8	48 0b d1	 or	 rdx, rcx
$LN8@runIt:

; 418  : 	if (right & (1ULL << 24)) //bit 8

  000bb	49 0f ba e6 18	 bt	 r14, 24
  000c0	73 0d		 jae	 SHORT $LN9@runIt

; 419  : 	{
; 420  : 		expandedRight |= (1ULL << (48 - 11));
; 421  : 		expandedRight |= (1ULL << (48 - 13));

  000c2	48 b9 00 00 00
	00 28 00 00 00	 mov	 rcx, 171798691840	; 0000002800000000H
  000cc	48 0b d1	 or	 rdx, rcx
$LN9@runIt:

; 422  : 	}
; 423  : 	if (right & (1ULL << 23)) //bit 9

  000cf	41 bd 00 00 80
	00		 mov	 r13d, 8388608		; 00800000H
  000d5	4d 85 f5	 test	 r14, r13
  000d8	74 0d		 je	 SHORT $LN10@runIt

; 424  : 	{
; 425  : 		expandedRight |= (1ULL << (48 - 12));
; 426  : 		expandedRight |= (1ULL << (48 - 14));

  000da	48 b9 00 00 00
	00 14 00 00 00	 mov	 rcx, 85899345920	; 0000001400000000H
  000e4	48 0b d1	 or	 rdx, rcx
$LN10@runIt:

; 427  : 	}
; 428  : 	if (right & (1ULL << 22)) expandedRight |= (1ULL << (48 - 15)); //bit 10

  000e7	49 0f ba e6 16	 bt	 r14, 22
  000ec	73 0d		 jae	 SHORT $LN11@runIt
  000ee	48 b9 00 00 00
	00 02 00 00 00	 mov	 rcx, 8589934592		; 0000000200000000H
  000f8	48 0b d1	 or	 rdx, rcx
$LN11@runIt:

; 429  : 	if (right & (1ULL << 21)) expandedRight |= (1ULL << (48 - 16)); //bit 11

  000fb	49 0f ba e6 15	 bt	 r14, 21
  00100	73 0d		 jae	 SHORT $LN12@runIt
  00102	48 b9 00 00 00
	00 01 00 00 00	 mov	 rcx, 4294967296		; 0000000100000000H
  0010c	48 0b d1	 or	 rdx, rcx
$LN12@runIt:

; 430  : 	if (right & (1ULL << 20)) //bit 12

  0010f	49 0f ba e6 14	 bt	 r14, 20
  00114	73 08		 jae	 SHORT $LN13@runIt

; 431  : 	{
; 432  : 		expandedRight |= (1ULL << (48 - 17));
; 433  : 		expandedRight |= (1ULL << (48 - 19));

  00116	b9 00 00 00 a0	 mov	 ecx, -1610612736	; a0000000H
  0011b	48 0b d1	 or	 rdx, rcx
$LN13@runIt:

; 434  : 	}
; 435  : 	if (right & (1ULL << 19)) //bit 13

  0011e	49 0f ba e6 13	 bt	 r14, 19
  00123	73 07		 jae	 SHORT $LN14@runIt

; 436  : 	{
; 437  : 		expandedRight |= (1ULL << (48 - 18));
; 438  : 		expandedRight |= (1ULL << (48 - 20));

  00125	48 81 ca 00 00
	00 50		 or	 rdx, 1342177280		; 50000000H
$LN14@runIt:

; 439  : 	}
; 440  : 	if (right & (1ULL << 18)) expandedRight |= (1ULL << (48 - 21)); //bit 14

  0012c	49 0f ba e6 12	 bt	 r14, 18
  00131	73 05		 jae	 SHORT $LN15@runIt
  00133	48 0f ba ea 1b	 bts	 rdx, 27
$LN15@runIt:

; 441  : 	if (right & (1ULL << 17)) expandedRight |= (1ULL << (48 - 22)); //bit 15

  00138	49 0f ba e6 11	 bt	 r14, 17
  0013d	73 05		 jae	 SHORT $LN16@runIt
  0013f	48 0f ba ea 1a	 bts	 rdx, 26
$LN16@runIt:

; 442  : 	if (right & (1ULL << 16)) //bit 16

  00144	49 0f ba e6 10	 bt	 r14, 16
  00149	73 07		 jae	 SHORT $LN17@runIt

; 443  : 	{
; 444  : 		expandedRight |= (1ULL << (48 - 23));
; 445  : 		expandedRight |= (1ULL << (48 - 25));

  0014b	48 81 ca 00 00
	80 02		 or	 rdx, 41943040		; 02800000H
$LN17@runIt:

; 446  : 	}
; 447  : 	if (right & (1ULL << 15)) //bit 17

  00152	49 0f ba e6 0f	 bt	 r14, 15
  00157	73 07		 jae	 SHORT $LN18@runIt

; 448  : 	{
; 449  : 		expandedRight |= (1ULL << (48 - 24));
; 450  : 		expandedRight |= (1ULL << (48 - 26));

  00159	48 81 ca 00 00
	40 01		 or	 rdx, 20971520		; 01400000H
$LN18@runIt:

; 451  : 	}
; 452  : 	if (right & (1ULL << 14)) expandedRight |= (1ULL << (48 - 27)); //bit 18

  00160	49 0f ba e6 0e	 bt	 r14, 14
  00165	73 05		 jae	 SHORT $LN19@runIt
  00167	48 0f ba ea 15	 bts	 rdx, 21
$LN19@runIt:

; 453  : 	if (right & (1ULL << 13)) expandedRight |= (1ULL << (48 - 28)); //bit 19

  0016c	49 0f ba e6 0d	 bt	 r14, 13
  00171	73 05		 jae	 SHORT $LN20@runIt
  00173	48 0f ba ea 14	 bts	 rdx, 20
$LN20@runIt:

; 454  : 	if (right & (1ULL << 12)) //bit 20

  00178	49 0f ba e6 0c	 bt	 r14, 12
  0017d	73 07		 jae	 SHORT $LN21@runIt

; 455  : 	{
; 456  : 		expandedRight |= (1ULL << (48 - 29));
; 457  : 		expandedRight |= (1ULL << (48 - 31));

  0017f	48 81 ca 00 00
	0a 00		 or	 rdx, 655360		; 000a0000H
$LN21@runIt:

; 458  : 	}
; 459  : 	if (right & (1ULL << 11)) //bit 21

  00186	49 0f ba e6 0b	 bt	 r14, 11
  0018b	73 07		 jae	 SHORT $LN22@runIt

; 460  : 	{
; 461  : 		expandedRight |= (1ULL << (48 - 30));
; 462  : 		expandedRight |= (1ULL << (48 - 32));

  0018d	48 81 ca 00 00
	05 00		 or	 rdx, 327680		; 00050000H
$LN22@runIt:

; 463  : 	}
; 464  : 	if (right & (1ULL << 10)) expandedRight |= (1ULL << (48 - 33)); //bit 22

  00194	49 0f ba e6 0a	 bt	 r14, 10
  00199	73 05		 jae	 SHORT $LN23@runIt
  0019b	48 0f ba ea 0f	 bts	 rdx, 15
$LN23@runIt:

; 465  : 	if (right & (1ULL << 9)) expandedRight |= (1ULL << (48 - 34)); //bit 23

  001a0	49 0f ba e6 09	 bt	 r14, 9
  001a5	73 05		 jae	 SHORT $LN24@runIt
  001a7	48 0f ba ea 0e	 bts	 rdx, 14
$LN24@runIt:

; 466  : 	if (right & (1ULL << 8))  //bit 24

  001ac	49 0f ba e6 08	 bt	 r14, 8
  001b1	73 07		 jae	 SHORT $LN25@runIt

; 467  : 	{
; 468  : 		expandedRight |= (1ULL << (48 - 35));
; 469  : 		expandedRight |= (1ULL << (48 - 37));

  001b3	48 81 ca 00 28
	00 00		 or	 rdx, 10240		; 00002800H
$LN25@runIt:

; 470  : 	}
; 471  : 	if (right & (1ULL << 7))  //bit 25

  001ba	45 84 f6	 test	 r14b, r14b
  001bd	79 07		 jns	 SHORT $LN26@runIt

; 472  : 	{
; 473  : 		expandedRight |= (1ULL << (48 - 36));
; 474  : 		expandedRight |= (1ULL << (48 - 38));

  001bf	48 81 ca 00 14
	00 00		 or	 rdx, 5120		; 00001400H
$LN26@runIt:

; 475  : 	}
; 476  : 	if (right & (1ULL << 6))  expandedRight |= (1ULL << (48 - 39)); //bit 26

  001c6	41 f6 c6 40	 test	 r14b, 64		; 00000040H
  001ca	74 05		 je	 SHORT $LN27@runIt
  001cc	48 0f ba ea 09	 bts	 rdx, 9
$LN27@runIt:

; 477  : 	if (right & (1ULL << 5))  expandedRight |= (1ULL << (48 - 40)); //bit 27

  001d1	41 f6 c6 20	 test	 r14b, 32		; 00000020H
  001d5	74 05		 je	 SHORT $LN28@runIt
  001d7	48 0f ba ea 08	 bts	 rdx, 8
$LN28@runIt:

; 478  : 	if (right & (1ULL << 4))  //bit 28

  001dc	41 f6 c6 10	 test	 r14b, 16
  001e0	74 07		 je	 SHORT $LN29@runIt

; 479  : 	{
; 480  : 		expandedRight |= (1ULL << (48 - 41));
; 481  : 		expandedRight |= (1ULL << (48 - 43));

  001e2	48 81 ca a0 00
	00 00		 or	 rdx, 160		; 000000a0H
$LN29@runIt:

; 482  : 	}
; 483  : 	if (right & (1ULL << 3))  //bit 29

  001e9	41 f6 c6 08	 test	 r14b, 8
  001ed	74 04		 je	 SHORT $LN30@runIt

; 484  : 	{
; 485  : 		expandedRight |= (1ULL << (48 - 42));
; 486  : 		expandedRight |= (1ULL << (48 - 44));

  001ef	48 83 ca 50	 or	 rdx, 80			; 00000050H
$LN30@runIt:

; 487  : 	}
; 488  : 	if (right & (1ULL << 2))  expandedRight |= (1ULL << (48 - 45)); //bit 30

  001f3	41 f6 c6 04	 test	 r14b, 4
  001f7	74 04		 je	 SHORT $LN31@runIt
  001f9	48 83 ca 08	 or	 rdx, 8
$LN31@runIt:

; 489  : 	if (right & (1ULL << 1))  expandedRight |= (1ULL << (48 - 46)); //bit 31

  001fd	41 f6 c6 02	 test	 r14b, 2
  00201	74 04		 je	 SHORT $LN32@runIt
  00203	48 83 ca 04	 or	 rdx, 4
$LN32@runIt:

; 490  : 	if (right & (1ULL << 0))  //bit 32

  00207	41 f6 c6 01	 test	 r14b, 1
  0020b	74 0d		 je	 SHORT $LN33@runIt

; 491  : 	{
; 492  : 		expandedRight |= (1ULL << (48 - 47));
; 493  : 		expandedRight |= (1ULL << (48 - 1));

  0020d	48 b9 02 00 00
	00 00 80 00 00	 mov	 rcx, 140737488355330	; 0000800000000002H
  00217	48 0b d1	 or	 rdx, rcx
$LN33@runIt:

; 494  : 	}
; 495  : 
; 496  : 	//Now we want to take the expandedRight and keys[roundKey] and xor them
; 497  : 	uint64_t rk = (expandedRight ^ keys[roundKey]);

  0021a	4c 8d 25 00 00
	00 00		 lea	 r12, OFFSET FLAT:__ImageBase
  00221	49 8b 9c c4 00
	00 00 00	 mov	 rbx, QWORD PTR ?keys@@3PA_KA[r12+rax*8]
  00229	48 33 da	 xor	 rbx, rdx

; 498  : 
; 499  : 	//to get each 6-bit value we shift the bits and clear any unwanted bits
; 500  : 	uint8_t s1 = (uint8_t)(rk >> 42);
; 501  : 	uint8_t s2 = (uint8_t)(rk >> 36) & 0x3F;
; 502  : 	uint8_t	s3 = (uint8_t)(rk >> 30) & 0x3F;
; 503  : 	uint8_t s4 = (uint8_t)(rk >> 24) & 0x3F;
; 504  : 	uint8_t s5 = (uint8_t)(rk >> 18) & 0x3F;
; 505  : 	uint8_t s6 = (uint8_t)(rk >> 12) & 0x3F;

  0022c	48 8b cb	 mov	 rcx, rbx
  0022f	4c 8b c3	 mov	 r8, rbx
  00232	48 c1 e9 0c	 shr	 rcx, 12

; 506  : 	uint8_t s7 = (uint8_t)(rk >> 6) & 0x3F;

  00236	48 8b c3	 mov	 rax, rbx
  00239	48 c1 e8 06	 shr	 rax, 6
  0023d	80 e1 3f	 and	 cl, 63			; 0000003fH
  00240	24 3f		 and	 al, 63			; 0000003fH

; 507  : 	uint8_t s8 = (uint8_t)(rk) & 0x3F;
; 508  : 
; 509  : 	//I know this looks crazy but in short, the first part is selecting which row
; 510  : 	//of the Sbox to select from (0-3) then multiply that by 16 to get to the right
; 511  : 	//part of the array.  To select the right column we need to add the value of the 4 inner 
; 512  : 	//bits of the s values set above. This total will give us the array index that we need to select.
; 513  : 	//Finally we & it with F to make sure we only get the 4 bits and nothing more.
; 514  : 	s1 = 0xF & S1[16 * ((((s1 >> 4) & 0x02) | (s1 & 1)) & 0x03) + (((s1 >> 1)) & 0x0F)];
; 515  : 	s2 = 0xF & S2[16 * ((((s2 >> 4) & 0x02) | (s2 & 1)) & 0x03) + (((s2 >> 1)) & 0x0F)];
; 516  : 	s3 = 0xF & S3[16 * ((((s3 >> 4) & 0x02) | (s3 & 1)) & 0x03) + (((s3 >> 1)) & 0x0F)];
; 517  : 	s4 = 0xF & S4[16 * ((((s4 >> 4) & 0x02) | (s4 & 1)) & 0x03) + (((s4 >> 1)) & 0x0F)];
; 518  : 	s5 = 0xF & S5[16 * ((((s5 >> 4) & 0x02) | (s5 & 1)) & 0x03) + (((s5 >> 1)) & 0x0F)];
; 519  : 	s6 = 0xF & S6[16 * ((((s6 >> 4) & 0x02) | (s6 & 1)) & 0x03) + (((s6 >> 1)) & 0x0F)];
; 520  : 	s7 = 0xF & S7[16 * ((((s7 >> 4) & 0x02) | (s7 & 1)) & 0x03) + (((s7 >> 1)) & 0x0F)];
; 521  : 	s8 = 0xF & S8[16 * ((((s8 >> 4) & 0x02) | (s8 & 1)) & 0x03) + (((s8 >> 1)) & 0x0F)];
; 522  : 
; 523  : 	right = (((uint64_t)s1 << 28)

  00242	0f b6 f9	 movzx	 edi, cl
  00245	0f b6 f0	 movzx	 esi, al
  00248	4c 8b db	 mov	 r11, rbx
  0024b	49 c1 e8 2a	 shr	 r8, 42			; 0000002aH
  0024f	4c 8b d3	 mov	 r10, rbx
  00252	45 0f b6 c0	 movzx	 r8d, r8b
  00256	4c 8b cb	 mov	 r9, rbx
  00259	41 8b c8	 mov	 ecx, r8d
  0025c	49 c1 eb 24	 shr	 r11, 36			; 00000024H
  00260	c1 e9 04	 shr	 ecx, 4
  00263	41 8b c0	 mov	 eax, r8d
  00266	83 e0 01	 and	 eax, 1
  00269	41 d1 e8	 shr	 r8d, 1
  0026c	83 e1 02	 and	 ecx, 2
  0026f	49 c1 ea 1e	 shr	 r10, 30
  00273	0b c1		 or	 eax, ecx
  00275	49 c1 e9 18	 shr	 r9, 24
  00279	c1 e0 04	 shl	 eax, 4
  0027c	41 83 e0 0f	 and	 r8d, 15
  00280	41 03 c0	 add	 eax, r8d
  00283	41 80 e3 3f	 and	 r11b, 63		; 0000003fH
  00287	48 98		 cdqe
  00289	41 80 e2 3f	 and	 r10b, 63		; 0000003fH
  0028d	45 0f b6 db	 movzx	 r11d, r11b
  00291	48 8b d3	 mov	 rdx, rbx
  00294	41 8b cb	 mov	 ecx, r11d
  00297	45 0f b6 d2	 movzx	 r10d, r10b
  0029b	c1 e9 04	 shr	 ecx, 4
  0029e	41 80 e1 3f	 and	 r9b, 63			; 0000003fH
  002a2	46 0f b6 84 20
	00 00 00 00	 movzx	 r8d, BYTE PTR ?S1@@3QBEB[rax+r12]
  002ab	83 e1 02	 and	 ecx, 2
  002ae	41 83 e0 0f	 and	 r8d, 15
  002b2	48 c1 ea 12	 shr	 rdx, 18
  002b6	49 c1 e0 04	 shl	 r8, 4
  002ba	41 8b c3	 mov	 eax, r11d
  002bd	83 e0 01	 and	 eax, 1
  002c0	41 d1 eb	 shr	 r11d, 1
  002c3	0b c1		 or	 eax, ecx
  002c5	45 0f b6 c9	 movzx	 r9d, r9b
  002c9	c1 e0 04	 shl	 eax, 4
  002cc	41 83 e3 0f	 and	 r11d, 15
  002d0	41 03 c3	 add	 eax, r11d
  002d3	80 e2 3f	 and	 dl, 63			; 0000003fH
  002d6	48 98		 cdqe
  002d8	80 e3 3f	 and	 bl, 63			; 0000003fH
  002db	0f b6 d2	 movzx	 edx, dl
  002de	0f b6 db	 movzx	 ebx, bl
  002e1	42 0f b6 8c 20
	00 00 00 00	 movzx	 ecx, BYTE PTR ?S2@@3QBEB[rax+r12]
  002ea	41 8b c2	 mov	 eax, r10d
  002ed	83 e1 0f	 and	 ecx, 15
  002f0	83 e0 01	 and	 eax, 1
  002f3	4c 0b c1	 or	 r8, rcx
  002f6	41 8b ca	 mov	 ecx, r10d
  002f9	c1 e9 04	 shr	 ecx, 4
  002fc	83 e1 02	 and	 ecx, 2
  002ff	49 c1 e0 04	 shl	 r8, 4
  00303	0b c1		 or	 eax, ecx
  00305	41 d1 ea	 shr	 r10d, 1
  00308	c1 e0 04	 shl	 eax, 4
  0030b	41 83 e2 0f	 and	 r10d, 15
  0030f	41 03 c2	 add	 eax, r10d
  00312	48 98		 cdqe
  00314	42 0f b6 8c 20
	00 00 00 00	 movzx	 ecx, BYTE PTR ?S3@@3QBEB[rax+r12]
  0031d	41 8b c1	 mov	 eax, r9d
  00320	83 e1 0f	 and	 ecx, 15
  00323	4c 0b c1	 or	 r8, rcx
  00326	41 8b c9	 mov	 ecx, r9d
  00329	c1 e9 04	 shr	 ecx, 4
  0032c	83 e1 02	 and	 ecx, 2
  0032f	49 c1 e0 04	 shl	 r8, 4
  00333	83 e0 01	 and	 eax, 1
  00336	0b c1		 or	 eax, ecx
  00338	41 d1 e9	 shr	 r9d, 1
  0033b	c1 e0 04	 shl	 eax, 4
  0033e	41 83 e1 0f	 and	 r9d, 15
  00342	41 03 c1	 add	 eax, r9d
  00345	48 98		 cdqe
  00347	42 0f b6 8c 20
	00 00 00 00	 movzx	 ecx, BYTE PTR ?S4@@3QBEB[rax+r12]
  00350	8b c2		 mov	 eax, edx
  00352	83 e0 01	 and	 eax, 1
  00355	83 e1 0f	 and	 ecx, 15
  00358	4c 0b c1	 or	 r8, rcx
  0035b	8b ca		 mov	 ecx, edx
  0035d	c1 e9 04	 shr	 ecx, 4
  00360	83 e1 02	 and	 ecx, 2
  00363	49 c1 e0 04	 shl	 r8, 4
  00367	0b c1		 or	 eax, ecx
  00369	d1 ea		 shr	 edx, 1
  0036b	c1 e0 04	 shl	 eax, 4
  0036e	83 e2 0f	 and	 edx, 15
  00371	03 c2		 add	 eax, edx
  00373	48 98		 cdqe
  00375	42 0f b6 8c 20
	00 00 00 00	 movzx	 ecx, BYTE PTR ?S5@@3QBEB[rax+r12]
  0037e	8b c7		 mov	 eax, edi
  00380	83 e0 01	 and	 eax, 1
  00383	83 e1 0f	 and	 ecx, 15
  00386	4c 0b c1	 or	 r8, rcx
  00389	8b cf		 mov	 ecx, edi
  0038b	c1 e9 04	 shr	 ecx, 4
  0038e	83 e1 02	 and	 ecx, 2
  00391	49 c1 e0 04	 shl	 r8, 4
  00395	0b c1		 or	 eax, ecx
  00397	d1 ef		 shr	 edi, 1
  00399	c1 e0 04	 shl	 eax, 4
  0039c	83 e7 0f	 and	 edi, 15
  0039f	03 c7		 add	 eax, edi
  003a1	48 98		 cdqe
  003a3	42 0f b6 8c 20
	00 00 00 00	 movzx	 ecx, BYTE PTR ?S6@@3QBEB[rax+r12]
  003ac	8b c6		 mov	 eax, esi
  003ae	83 e1 0f	 and	 ecx, 15
  003b1	83 e0 01	 and	 eax, 1
  003b4	4c 0b c1	 or	 r8, rcx
  003b7	8b ce		 mov	 ecx, esi
  003b9	c1 e9 04	 shr	 ecx, 4
  003bc	83 e1 02	 and	 ecx, 2
  003bf	49 c1 e0 04	 shl	 r8, 4
  003c3	0b c1		 or	 eax, ecx
  003c5	d1 ee		 shr	 esi, 1
  003c7	c1 e0 04	 shl	 eax, 4
  003ca	83 e6 0f	 and	 esi, 15
  003cd	03 c6		 add	 eax, esi
  003cf	48 98		 cdqe
  003d1	42 0f b6 8c 20
	00 00 00 00	 movzx	 ecx, BYTE PTR ?S7@@3QBEB[rax+r12]
  003da	8b c3		 mov	 eax, ebx
  003dc	83 e1 0f	 and	 ecx, 15
  003df	83 e0 01	 and	 eax, 1
  003e2	4c 0b c1	 or	 r8, rcx
  003e5	8b cb		 mov	 ecx, ebx
  003e7	c1 e9 04	 shr	 ecx, 4
  003ea	83 e1 02	 and	 ecx, 2
  003ed	d1 eb		 shr	 ebx, 1
  003ef	0b c1		 or	 eax, ecx
  003f1	49 c1 e0 04	 shl	 r8, 4
  003f5	c1 e0 04	 shl	 eax, 4
  003f8	83 e3 0f	 and	 ebx, 15
  003fb	03 c3		 add	 eax, ebx
  003fd	48 98		 cdqe
  003ff	42 0f b6 8c 20
	00 00 00 00	 movzx	 ecx, BYTE PTR ?S8@@3QBEB[rax+r12]

; 524  : 		| ((uint64_t)s2 << 24)
; 525  : 		| ((uint64_t)s3 << 20)
; 526  : 		| ((uint64_t)s4 << 16)
; 527  : 		| ((uint64_t)s5 << 12)
; 528  : 		| ((uint64_t)s6 << 8)
; 529  : 		| ((uint64_t)s7 << 4)
; 530  : 		| ((uint64_t)s8))
; 531  : 		& 0x00000000FFFFFFFF;
; 532  : 
; 533  : 	uint64_t permRight = 0;
; 534  : 	//Straight Permutation of the right block
; 535  : 	if (right & (1ULL << 31)) permRight |= (1ULL << (32 - 9));

  00408	b8 00 00 00 80	 mov	 eax, -2147483648	; 80000000H
  0040d	83 e1 0f	 and	 ecx, 15
  00410	4c 0b c1	 or	 r8, rcx
  00413	4c 85 c0	 test	 r8, rax
  00416	49 0f 45 ed	 cmovne	 rbp, r13

; 536  : 	if (right & (1ULL << 30)) permRight |= (1ULL << (32 - 17));

  0041a	49 0f ba e0 1e	 bt	 r8, 30
  0041f	73 05		 jae	 SHORT $LN35@runIt
  00421	48 0f ba ed 0f	 bts	 rbp, 15
$LN35@runIt:

; 537  : 	if (right & (1ULL << 29)) permRight |= (1ULL << (32 - 23));

  00426	49 0f ba e0 1d	 bt	 r8, 29
  0042b	73 05		 jae	 SHORT $LN36@runIt
  0042d	48 0f ba ed 09	 bts	 rbp, 9
$LN36@runIt:

; 538  : 	if (right & (1ULL << 28)) permRight |= (1ULL << (32 - 31));

  00432	49 0f ba e0 1c	 bt	 r8, 28
  00437	73 04		 jae	 SHORT $LN37@runIt
  00439	48 83 cd 02	 or	 rbp, 2
$LN37@runIt:

; 539  : 	if (right & (1ULL << 27)) permRight |= (1ULL << (32 - 13));

  0043d	49 0f ba e0 1b	 bt	 r8, 27
  00442	73 05		 jae	 SHORT $LN38@runIt
  00444	48 0f ba ed 13	 bts	 rbp, 19
$LN38@runIt:

; 540  : 	if (right & (1ULL << 26)) permRight |= (1ULL << (32 - 28));

  00449	49 0f ba e0 1a	 bt	 r8, 26
  0044e	73 04		 jae	 SHORT $LN39@runIt
  00450	48 83 cd 10	 or	 rbp, 16
$LN39@runIt:

; 541  : 	if (right & (1ULL << 25)) permRight |= (1ULL << (32 - 2));

  00454	49 0f ba e0 19	 bt	 r8, 25
  00459	73 05		 jae	 SHORT $LN40@runIt
  0045b	48 0f ba ed 1e	 bts	 rbp, 30
$LN40@runIt:

; 542  : 	if (right & (1ULL << 24)) permRight |= (1ULL << (32 - 18));

  00460	49 0f ba e0 18	 bt	 r8, 24
  00465	73 05		 jae	 SHORT $LN41@runIt
  00467	48 0f ba ed 0e	 bts	 rbp, 14
$LN41@runIt:

; 543  : 	if (right & (1ULL << 23)) permRight |= (1ULL << (32 - 24));

  0046c	4d 85 c5	 test	 r8, r13
  0046f	74 05		 je	 SHORT $LN42@runIt
  00471	48 0f ba ed 08	 bts	 rbp, 8
$LN42@runIt:

; 544  : 	if (right & (1ULL << 22)) permRight |= (1ULL << (32 - 16));

  00476	49 0f ba e0 16	 bt	 r8, 22
  0047b	73 05		 jae	 SHORT $LN43@runIt
  0047d	48 0f ba ed 10	 bts	 rbp, 16
$LN43@runIt:

; 545  : 	if (right & (1ULL << 21)) permRight |= (1ULL << (32 - 30));

  00482	49 0f ba e0 15	 bt	 r8, 21
  00487	73 04		 jae	 SHORT $LN44@runIt
  00489	48 83 cd 04	 or	 rbp, 4
$LN44@runIt:

; 546  : 	if (right & (1ULL << 20)) permRight |= (1ULL << (32 - 6));

  0048d	49 0f ba e0 14	 bt	 r8, 20
  00492	73 05		 jae	 SHORT $LN45@runIt
  00494	48 0f ba ed 1a	 bts	 rbp, 26
$LN45@runIt:

; 547  : 	if (right & (1ULL << 19)) permRight |= (1ULL << (32 - 26));

  00499	49 0f ba e0 13	 bt	 r8, 19
  0049e	73 04		 jae	 SHORT $LN46@runIt
  004a0	48 83 cd 40	 or	 rbp, 64			; 00000040H
$LN46@runIt:

; 548  : 	if (right & (1ULL << 18)) permRight |= (1ULL << (32 - 20));

  004a4	49 0f ba e0 12	 bt	 r8, 18
  004a9	73 05		 jae	 SHORT $LN47@runIt
  004ab	48 0f ba ed 0c	 bts	 rbp, 12
$LN47@runIt:

; 549  : 	if (right & (1ULL << 17)) permRight |= (1ULL << (32 - 10));

  004b0	49 0f ba e0 11	 bt	 r8, 17
  004b5	73 05		 jae	 SHORT $LN48@runIt
  004b7	48 0f ba ed 16	 bts	 rbp, 22
$LN48@runIt:

; 550  : 	if (right & (1ULL << 16)) permRight |= (1ULL << (32 - 1));

  004bc	49 0f ba e0 10	 bt	 r8, 16
  004c1	73 03		 jae	 SHORT $LN49@runIt
  004c3	48 0b e8	 or	 rbp, rax
$LN49@runIt:

; 551  : 
; 552  : 	if (right & (1ULL << 15)) permRight |= (1ULL << (32 - 8));

  004c6	49 0f ba e0 0f	 bt	 r8, 15
  004cb	73 05		 jae	 SHORT $LN50@runIt
  004cd	48 0f ba ed 18	 bts	 rbp, 24
$LN50@runIt:

; 553  : 	if (right & (1ULL << 14)) permRight |= (1ULL << (32 - 14));

  004d2	49 0f ba e0 0e	 bt	 r8, 14
  004d7	73 05		 jae	 SHORT $LN51@runIt
  004d9	48 0f ba ed 12	 bts	 rbp, 18
$LN51@runIt:

; 554  : 	if (right & (1ULL << 13)) permRight |= (1ULL << (32 - 25));

  004de	49 0f ba e0 0d	 bt	 r8, 13
  004e3	73 05		 jae	 SHORT $LN52@runIt
  004e5	48 0f ba ed 07	 bts	 rbp, 7
$LN52@runIt:

; 555  : 	if (right & (1ULL << 12)) permRight |= (1ULL << (32 - 3));

  004ea	49 0f ba e0 0c	 bt	 r8, 12
  004ef	73 05		 jae	 SHORT $LN53@runIt
  004f1	48 0f ba ed 1d	 bts	 rbp, 29
$LN53@runIt:

; 556  : 	if (right & (1ULL << 11)) permRight |= (1ULL << (32 - 4));

  004f6	49 0f ba e0 0b	 bt	 r8, 11
  004fb	73 05		 jae	 SHORT $LN54@runIt
  004fd	48 0f ba ed 1c	 bts	 rbp, 28
$LN54@runIt:

; 557  : 	if (right & (1ULL << 10)) permRight |= (1ULL << (32 - 29));

  00502	49 0f ba e0 0a	 bt	 r8, 10
  00507	73 04		 jae	 SHORT $LN55@runIt
  00509	48 83 cd 08	 or	 rbp, 8
$LN55@runIt:

; 558  : 	if (right & (1ULL << 9))  permRight |= (1ULL << (32 - 11));

  0050d	49 0f ba e0 09	 bt	 r8, 9
  00512	73 05		 jae	 SHORT $LN56@runIt
  00514	48 0f ba ed 15	 bts	 rbp, 21
$LN56@runIt:

; 559  : 	if (right & (1ULL << 8))  permRight |= (1ULL << (32 - 19));

  00519	49 0f ba e0 08	 bt	 r8, 8
  0051e	73 05		 jae	 SHORT $LN57@runIt
  00520	48 0f ba ed 0d	 bts	 rbp, 13
$LN57@runIt:

; 560  : 	if (right & (1ULL << 7))  permRight |= (1ULL << (32 - 32));

  00525	45 84 c0	 test	 r8b, r8b
  00528	79 04		 jns	 SHORT $LN58@runIt
  0052a	48 83 cd 01	 or	 rbp, 1
$LN58@runIt:

; 561  : 	if (right & (1ULL << 6))  permRight |= (1ULL << (32 - 12));

  0052e	41 f6 c0 40	 test	 r8b, 64			; 00000040H
  00532	74 05		 je	 SHORT $LN59@runIt
  00534	48 0f ba ed 14	 bts	 rbp, 20
$LN59@runIt:

; 562  : 	if (right & (1ULL << 5))  permRight |= (1ULL << (32 - 22));

  00539	41 f6 c0 20	 test	 r8b, 32			; 00000020H
  0053d	74 05		 je	 SHORT $LN60@runIt
  0053f	48 0f ba ed 0a	 bts	 rbp, 10
$LN60@runIt:

; 563  : 	if (right & (1ULL << 4))  permRight |= (1ULL << (32 - 7));

  00544	41 f6 c0 10	 test	 r8b, 16
  00548	74 05		 je	 SHORT $LN61@runIt
  0054a	48 0f ba ed 19	 bts	 rbp, 25
$LN61@runIt:

; 564  : 	if (right & (1ULL << 3))  permRight |= (1ULL << (32 - 5));

  0054f	41 f6 c0 08	 test	 r8b, 8
  00553	74 05		 je	 SHORT $LN62@runIt
  00555	48 0f ba ed 1b	 bts	 rbp, 27
$LN62@runIt:

; 565  : 	if (right & (1ULL << 2))  permRight |= (1ULL << (32 - 27));

  0055a	41 f6 c0 04	 test	 r8b, 4
  0055e	74 04		 je	 SHORT $LN63@runIt
  00560	48 83 cd 20	 or	 rbp, 32			; 00000020H
$LN63@runIt:

; 566  : 	if (right & (1ULL << 1))  permRight |= (1ULL << (32 - 15));

  00564	41 f6 c0 02	 test	 r8b, 2
  00568	74 05		 je	 SHORT $LN64@runIt
  0056a	48 0f ba ed 11	 bts	 rbp, 17
$LN64@runIt:

; 567  : 	if (right & (1ULL << 0))  permRight |= (1ULL << (32 - 21));

  0056f	41 f6 c0 01	 test	 r8b, 1
  00573	74 05		 je	 SHORT $LN65@runIt
  00575	48 0f ba ed 0b	 bts	 rbp, 11
$LN65@runIt:

; 568  : 
; 569  : 
; 570  : 	right = (permRight ^ left);
; 571  : 
; 572  : 	y = (nextLeft << 32) | right;
; 573  : 
; 574  : 
; 575  : 	return y;
; 576  : }

  0057a	48 8b 5c 24 28	 mov	 rbx, QWORD PTR [rsp+40]
  0057f	49 33 ef	 xor	 rbp, r15
  00582	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00587	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
  0058c	49 c1 e6 20	 shl	 r14, 32			; 00000020H
  00590	49 0b ee	 or	 rbp, r14
  00593	48 8b c5	 mov	 rax, rbp
  00596	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]
  0059b	41 5f		 pop	 r15
  0059d	41 5e		 pop	 r14
  0059f	41 5d		 pop	 r13
  005a1	41 5c		 pop	 r12
  005a3	c3		 ret	 0
?runIt@@YA_K_KH@Z ENDP					; runIt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\coschm\desktop\fall-2016\security\des\des\des\main.cpp
_TEXT	SEGMENT
y$ = 40
?finalPermutation@@YA_K_K@Z PROC			; finalPermutation

; 317  : {

$LN69:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12
  00016	41 55		 push	 r13
  00018	41 56		 push	 r14
  0001a	41 57		 push	 r15

; 318  : 	uint64_t output = 0;

  0001c	33 c0		 xor	 eax, eax

; 319  : 
; 320  : 	if (y & (1ULL << 63)) output |= (1ULL << (64 - 58)); //bit 1

  0001e	48 ba 00 00 00
	00 00 00 00 80	 mov	 rdx, -9223372036854775808 ; 8000000000000000H
  00028	48 85 ca	 test	 rcx, rdx

; 321  : 	if (y & (1ULL << 62)) output |= (1ULL << (64 - 50)); //bit 2

  0002b	49 b8 00 00 00
	00 00 00 00 40	 mov	 r8, 4611686018427387904	; 4000000000000000H
  00035	ba 40 00 00 00	 mov	 edx, 64			; 00000040H
  0003a	0f 45 c2	 cmovne	 eax, edx
  0003d	49 85 c8	 test	 rcx, r8
  00040	74 05		 je	 SHORT $LN3@finalPermu
  00042	48 0f ba e8 0e	 bts	 rax, 14
$LN3@finalPermu:

; 322  : 	if (y & (1ULL << 61)) output |= (1ULL << (64 - 42)); //bit 3

  00047	48 ba 00 00 00
	00 00 00 00 20	 mov	 rdx, 2305843009213693952 ; 2000000000000000H
  00051	48 85 ca	 test	 rcx, rdx
  00054	74 05		 je	 SHORT $LN4@finalPermu
  00056	48 0f ba e8 16	 bts	 rax, 22
$LN4@finalPermu:

; 323  : 	if (y & (1ULL << 60)) output |= (1ULL << (64 - 34)); //bit 4

  0005b	49 b9 00 00 00
	00 00 00 00 10	 mov	 r9, 1152921504606846976	; 1000000000000000H
  00065	49 85 c9	 test	 rcx, r9
  00068	74 05		 je	 SHORT $LN5@finalPermu
  0006a	48 0f ba e8 1e	 bts	 rax, 30
$LN5@finalPermu:

; 324  : 	if (y & (1ULL << 59)) output |= (1ULL << (64 - 26)); //bit 5

  0006f	48 ba 00 00 00
	00 00 00 00 08	 mov	 rdx, 576460752303423488	; 0800000000000000H
  00079	48 bf 00 00 00
	00 40 00 00 00	 mov	 rdi, 274877906944	; 0000004000000000H
  00083	48 85 ca	 test	 rcx, rdx
  00086	74 03		 je	 SHORT $LN6@finalPermu
  00088	48 0b c7	 or	 rax, rdi
$LN6@finalPermu:

; 325  : 	if (y & (1ULL << 58)) output |= (1ULL << (64 - 18)); //bit 6

  0008b	48 bb 00 00 00
	00 00 00 00 04	 mov	 rbx, 288230376151711744	; 0400000000000000H
  00095	49 ba 00 00 00
	00 00 40 00 00	 mov	 r10, 70368744177664	; 0000400000000000H
  0009f	48 85 cb	 test	 rcx, rbx
  000a2	74 03		 je	 SHORT $LN7@finalPermu
  000a4	49 0b c2	 or	 rax, r10
$LN7@finalPermu:

; 326  : 	if (y & (1ULL << 57)) output |= (1ULL << (64 - 10)); //bit 7

  000a7	49 bb 00 00 00
	00 00 00 00 02	 mov	 r11, 144115188075855872	; 0200000000000000H
  000b1	48 ba 00 00 00
	00 00 00 40 00	 mov	 rdx, 18014398509481984	; 0040000000000000H
  000bb	49 85 cb	 test	 rcx, r11
  000be	74 03		 je	 SHORT $LN8@finalPermu
  000c0	48 0b c2	 or	 rax, rdx
$LN8@finalPermu:

; 327  : 	if (y & (1ULL << 56)) output |= (1ULL << (64 - 2));  //bit 8

  000c3	49 be 00 00 00
	00 00 00 00 01	 mov	 r14, 72057594037927936	; 0100000000000000H
  000cd	49 85 ce	 test	 rcx, r14
  000d0	74 03		 je	 SHORT $LN9@finalPermu
  000d2	49 0b c0	 or	 rax, r8
$LN9@finalPermu:

; 328  : 	if (y & (1ULL << 55)) output |= (1ULL << (64 - 60)); //bit 9

  000d5	49 bc 00 00 00
	00 00 00 80 00	 mov	 r12, 36028797018963968	; 0080000000000000H
  000df	49 85 cc	 test	 rcx, r12
  000e2	74 04		 je	 SHORT $LN10@finalPermu
  000e4	48 83 c8 10	 or	 rax, 16
$LN10@finalPermu:

; 329  : 	if (y & (1ULL << 54)) output |= (1ULL << (64 - 52)); //bit 10

  000e8	48 85 ca	 test	 rcx, rdx
  000eb	74 05		 je	 SHORT $LN11@finalPermu
  000ed	48 0f ba e8 0c	 bts	 rax, 12
$LN11@finalPermu:

; 330  : 	if (y & (1ULL << 53)) output |= (1ULL << (64 - 44)); //bit 11

  000f2	48 ba 00 00 00
	00 00 00 20 00	 mov	 rdx, 9007199254740992	; 0020000000000000H
  000fc	48 85 ca	 test	 rcx, rdx
  000ff	74 05		 je	 SHORT $LN12@finalPermu
  00101	48 0f ba e8 14	 bts	 rax, 20
$LN12@finalPermu:

; 331  : 	if (y & (1ULL << 52)) output |= (1ULL << (64 - 36)); //bit 12

  00106	48 ba 00 00 00
	00 00 00 10 00	 mov	 rdx, 4503599627370496	; 0010000000000000H
  00110	48 85 ca	 test	 rcx, rdx
  00113	74 05		 je	 SHORT $LN13@finalPermu
  00115	48 0f ba e8 1c	 bts	 rax, 28
$LN13@finalPermu:

; 332  : 	if (y & (1ULL << 51)) output |= (1ULL << (64 - 28)); //bit 13

  0011a	49 b8 00 00 00
	00 00 00 08 00	 mov	 r8, 2251799813685248	; 0008000000000000H
  00124	48 be 00 00 00
	00 10 00 00 00	 mov	 rsi, 68719476736	; 0000001000000000H
  0012e	49 85 c8	 test	 rcx, r8
  00131	74 03		 je	 SHORT $LN14@finalPermu
  00133	48 0b c6	 or	 rax, rsi
$LN14@finalPermu:

; 333  : 	if (y & (1ULL << 50)) output |= (1ULL << (64 - 20)); //bit 14

  00136	49 bb 00 00 00
	00 00 00 04 00	 mov	 r11, 1125899906842624	; 0004000000000000H
  00140	49 b8 00 00 00
	00 00 10 00 00	 mov	 r8, 17592186044416	; 0000100000000000H
  0014a	49 85 cb	 test	 rcx, r11
  0014d	74 03		 je	 SHORT $LN15@finalPermu
  0014f	49 0b c0	 or	 rax, r8
$LN15@finalPermu:

; 334  : 	if (y & (1ULL << 49)) output |= (1ULL << (64 - 12)); //bit 15

  00152	48 bd 00 00 00
	00 00 00 02 00	 mov	 rbp, 562949953421312	; 0002000000000000H
  0015c	48 85 cd	 test	 rcx, rbp
  0015f	74 03		 je	 SHORT $LN16@finalPermu
  00161	48 0b c2	 or	 rax, rdx
$LN16@finalPermu:

; 335  : 	if (y & (1ULL << 48)) output |= (1ULL << (64 - 4));  //bit 16

  00164	48 bd 00 00 00
	00 00 00 01 00	 mov	 rbp, 281474976710656	; 0001000000000000H
  0016e	48 85 cd	 test	 rcx, rbp
  00171	74 03		 je	 SHORT $LN17@finalPermu
  00173	49 0b c1	 or	 rax, r9
$LN17@finalPermu:

; 336  : 
; 337  : 	if (y & (1ULL << 47)) output |= (1ULL << (64 - 62)); //bit 17

  00176	49 bf 00 00 00
	00 00 80 00 00	 mov	 r15, 140737488355328	; 0000800000000000H
  00180	49 85 cf	 test	 rcx, r15
  00183	74 04		 je	 SHORT $LN18@finalPermu
  00185	48 83 c8 04	 or	 rax, 4
$LN18@finalPermu:

; 338  : 	if (y & (1ULL << 46)) output |= (1ULL << (64 - 54)); //bit 18

  00189	49 85 ca	 test	 rcx, r10
  0018c	74 05		 je	 SHORT $LN19@finalPermu
  0018e	48 0f ba e8 0a	 bts	 rax, 10
$LN19@finalPermu:

; 339  : 	if (y & (1ULL << 45)) output |= (1ULL << (64 - 46)); //bit 19

  00193	49 bd 00 00 00
	00 00 20 00 00	 mov	 r13, 35184372088832	; 0000200000000000H
  0019d	49 85 cd	 test	 rcx, r13
  001a0	74 05		 je	 SHORT $LN20@finalPermu
  001a2	48 0f ba e8 12	 bts	 rax, 18
$LN20@finalPermu:

; 340  : 	if (y & (1ULL << 44)) output |= (1ULL << (64 - 38)); //bit 20

  001a7	49 85 c8	 test	 rcx, r8
  001aa	74 05		 je	 SHORT $LN21@finalPermu
  001ac	48 0f ba e8 1a	 bts	 rax, 26
$LN21@finalPermu:

; 341  : 	if (y & (1ULL << 43)) output |= (1ULL << (64 - 30)); //bit 21

  001b1	48 ba 00 00 00
	00 00 08 00 00	 mov	 rdx, 8796093022208	; 0000080000000000H
  001bb	49 b9 00 00 00
	00 04 00 00 00	 mov	 r9, 17179869184		; 0000000400000000H
  001c5	48 85 ca	 test	 rcx, rdx
  001c8	74 03		 je	 SHORT $LN22@finalPermu
  001ca	49 0b c1	 or	 rax, r9
$LN22@finalPermu:

; 342  : 	if (y & (1ULL << 42)) output |= (1ULL << (64 - 22)); //bit 22

  001cd	48 ba 00 00 00
	00 00 04 00 00	 mov	 rdx, 4398046511104	; 0000040000000000H
  001d7	48 85 ca	 test	 rcx, rdx
  001da	74 03		 je	 SHORT $LN23@finalPermu
  001dc	48 0b c2	 or	 rax, rdx
$LN23@finalPermu:

; 343  : 	if (y & (1ULL << 41)) output |= (1ULL << (64 - 14)); //bit 23

  001df	48 ba 00 00 00
	00 00 02 00 00	 mov	 rdx, 2199023255552	; 0000020000000000H
  001e9	48 85 ca	 test	 rcx, rdx
  001ec	74 03		 je	 SHORT $LN24@finalPermu
  001ee	49 0b c3	 or	 rax, r11
$LN24@finalPermu:

; 344  : 	if (y & (1ULL << 40)) output |= (1ULL << (64 - 6));  //bit 24

  001f1	49 b8 00 00 00
	00 00 01 00 00	 mov	 r8, 1099511627776	; 0000010000000000H
  001fb	49 85 c8	 test	 rcx, r8
  001fe	74 03		 je	 SHORT $LN25@finalPermu
  00200	48 0b c3	 or	 rax, rbx
$LN25@finalPermu:

; 345  : 	if (y & (1ULL << 39)) output |= (1ULL << (64 - 64)); //bit 25

  00203	49 ba 00 00 00
	00 80 00 00 00	 mov	 r10, 549755813888	; 0000008000000000H
  0020d	49 85 ca	 test	 rcx, r10
  00210	74 04		 je	 SHORT $LN26@finalPermu
  00212	48 83 c8 01	 or	 rax, 1
$LN26@finalPermu:

; 346  : 	if (y & (1ULL << 38)) output |= (1ULL << (64 - 56)); //bit 26

  00216	48 85 cf	 test	 rcx, rdi
  00219	74 05		 je	 SHORT $LN27@finalPermu
  0021b	48 0f ba e8 08	 bts	 rax, 8
$LN27@finalPermu:

; 347  : 	if (y & (1ULL << 37)) output |= (1ULL << (64 - 48)); //bit 27

  00220	49 bb 00 00 00
	00 20 00 00 00	 mov	 r11, 137438953472	; 0000002000000000H
  0022a	49 85 cb	 test	 rcx, r11
  0022d	74 05		 je	 SHORT $LN28@finalPermu
  0022f	48 0f ba e8 10	 bts	 rax, 16
$LN28@finalPermu:

; 348  : 	if (y & (1ULL << 36)) output |= (1ULL << (64 - 40)); //bit 28

  00234	48 85 ce	 test	 rcx, rsi
  00237	74 05		 je	 SHORT $LN29@finalPermu
  00239	48 0f ba e8 18	 bts	 rax, 24
$LN29@finalPermu:

; 349  : 	if (y & (1ULL << 35)) output |= (1ULL << (64 - 32)); //bit 29

  0023e	48 bb 00 00 00
	00 08 00 00 00	 mov	 rbx, 34359738368	; 0000000800000000H
  00248	48 ba 00 00 00
	00 01 00 00 00	 mov	 rdx, 4294967296		; 0000000100000000H
  00252	48 85 cb	 test	 rcx, rbx
  00255	74 03		 je	 SHORT $LN30@finalPermu
  00257	48 0b c2	 or	 rax, rdx
$LN30@finalPermu:

; 350  : 	if (y & (1ULL << 34)) output |= (1ULL << (64 - 24)); //bit 30

  0025a	49 85 c9	 test	 rcx, r9
  0025d	74 03		 je	 SHORT $LN31@finalPermu
  0025f	49 0b c0	 or	 rax, r8
$LN31@finalPermu:

; 351  : 	if (y & (1ULL << 33)) output |= (1ULL << (64 - 16)); //bit 31

  00262	49 b8 00 00 00
	00 02 00 00 00	 mov	 r8, 8589934592		; 0000000200000000H
  0026c	49 85 c8	 test	 rcx, r8
  0026f	74 03		 je	 SHORT $LN32@finalPermu
  00271	48 0b c5	 or	 rax, rbp
$LN32@finalPermu:

; 352  : 	if (y & (1ULL << 32)) output |= (1ULL << (64 - 8));  //bit 32

  00274	48 85 ca	 test	 rcx, rdx
  00277	74 03		 je	 SHORT $LN33@finalPermu
  00279	49 0b c6	 or	 rax, r14
$LN33@finalPermu:

; 353  : 
; 354  : 	if (y & (1ULL << 31)) output |= (1ULL << (64 - 57)); //bit 33

  0027c	ba 00 00 00 80	 mov	 edx, -2147483648	; 80000000H
  00281	48 85 ca	 test	 rcx, rdx
  00284	74 05		 je	 SHORT $LN34@finalPermu
  00286	48 0f ba e8 07	 bts	 rax, 7
$LN34@finalPermu:

; 355  : 	if (y & (1ULL << 30)) output |= (1ULL << (64 - 49)); //bit 34

  0028b	48 0f ba e1 1e	 bt	 rcx, 30
  00290	73 05		 jae	 SHORT $LN35@finalPermu
  00292	48 0f ba e8 0f	 bts	 rax, 15
$LN35@finalPermu:

; 356  : 	if (y & (1ULL << 29)) output |= (1ULL << (64 - 41)); //bit 35

  00297	48 0f ba e1 1d	 bt	 rcx, 29
  0029c	73 05		 jae	 SHORT $LN36@finalPermu
  0029e	48 0f ba e8 17	 bts	 rax, 23
$LN36@finalPermu:

; 357  : 	if (y & (1ULL << 28)) output |= (1ULL << (64 - 33)); //bit 36

  002a3	48 0f ba e1 1c	 bt	 rcx, 28
  002a8	73 03		 jae	 SHORT $LN37@finalPermu
  002aa	48 0b c2	 or	 rax, rdx
$LN37@finalPermu:

; 358  : 	if (y & (1ULL << 27)) output |= (1ULL << (64 - 25)); //bit 37

  002ad	48 0f ba e1 1b	 bt	 rcx, 27
  002b2	73 03		 jae	 SHORT $LN38@finalPermu
  002b4	49 0b c2	 or	 rax, r10
$LN38@finalPermu:

; 359  : 	if (y & (1ULL << 26)) output |= (1ULL << (64 - 17)); //bit 38

  002b7	48 0f ba e1 1a	 bt	 rcx, 26
  002bc	73 03		 jae	 SHORT $LN39@finalPermu
  002be	49 0b c7	 or	 rax, r15
$LN39@finalPermu:

; 360  : 	if (y & (1ULL << 25)) output |= (1ULL << (64 - 9));  //bit 39

  002c1	48 0f ba e1 19	 bt	 rcx, 25
  002c6	73 03		 jae	 SHORT $LN40@finalPermu
  002c8	49 0b c4	 or	 rax, r12
$LN40@finalPermu:

; 361  : 	if (y & (1ULL << 24)) output |= (1ULL << (64 - 1));  //bit 40

  002cb	48 0f ba e1 18	 bt	 rcx, 24
  002d0	73 0d		 jae	 SHORT $LN41@finalPermu
  002d2	48 ba 00 00 00
	00 00 00 00 80	 mov	 rdx, -9223372036854775808 ; 8000000000000000H
  002dc	48 0b c2	 or	 rax, rdx
$LN41@finalPermu:

; 362  : 	if (y & (1ULL << 23)) output |= (1ULL << (64 - 59)); //bit 41

  002df	48 0f ba e1 17	 bt	 rcx, 23
  002e4	73 04		 jae	 SHORT $LN42@finalPermu
  002e6	48 83 c8 20	 or	 rax, 32			; 00000020H
$LN42@finalPermu:

; 363  : 	if (y & (1ULL << 22)) output |= (1ULL << (64 - 51)); //bit 42

  002ea	48 0f ba e1 16	 bt	 rcx, 22
  002ef	73 05		 jae	 SHORT $LN43@finalPermu
  002f1	48 0f ba e8 0d	 bts	 rax, 13
$LN43@finalPermu:

; 364  : 	if (y & (1ULL << 21)) output |= (1ULL << (64 - 43)); //bit 43

  002f6	48 0f ba e1 15	 bt	 rcx, 21
  002fb	73 05		 jae	 SHORT $LN44@finalPermu
  002fd	48 0f ba e8 15	 bts	 rax, 21
$LN44@finalPermu:

; 365  : 	if (y & (1ULL << 20)) output |= (1ULL << (64 - 35)); //bit 44

  00302	48 0f ba e1 14	 bt	 rcx, 20
  00307	73 05		 jae	 SHORT $LN45@finalPermu
  00309	48 0f ba e8 1d	 bts	 rax, 29
$LN45@finalPermu:

; 366  : 	if (y & (1ULL << 19)) output |= (1ULL << (64 - 27)); //bit 45

  0030e	48 0f ba e1 13	 bt	 rcx, 19
  00313	73 03		 jae	 SHORT $LN46@finalPermu
  00315	49 0b c3	 or	 rax, r11
$LN46@finalPermu:

; 367  : 	if (y & (1ULL << 18)) output |= (1ULL << (64 - 19)); //bit 46

  00318	48 0f ba e1 12	 bt	 rcx, 18
  0031d	73 03		 jae	 SHORT $LN47@finalPermu
  0031f	49 0b c5	 or	 rax, r13
$LN47@finalPermu:

; 368  : 	if (y & (1ULL << 17)) output |= (1ULL << (64 - 11)); //bit 47

  00322	48 0f ba e1 11	 bt	 rcx, 17
  00327	73 0d		 jae	 SHORT $LN48@finalPermu
  00329	48 ba 00 00 00
	00 00 00 20 00	 mov	 rdx, 9007199254740992	; 0020000000000000H
  00333	48 0b c2	 or	 rax, rdx
$LN48@finalPermu:

; 369  : 	if (y & (1ULL << 16)) output |= (1ULL << (64 - 3));  //bit 48

  00336	48 0f ba e1 10	 bt	 rcx, 16
  0033b	73 0d		 jae	 SHORT $LN49@finalPermu
  0033d	48 ba 00 00 00
	00 00 00 00 20	 mov	 rdx, 2305843009213693952 ; 2000000000000000H
  00347	48 0b c2	 or	 rax, rdx
$LN49@finalPermu:

; 370  : 
; 371  : 	if (y & (1ULL << 15)) output |= (1ULL << (64 - 61)); //bit 49

  0034a	48 0f ba e1 0f	 bt	 rcx, 15
  0034f	73 04		 jae	 SHORT $LN50@finalPermu
  00351	48 83 c8 08	 or	 rax, 8
$LN50@finalPermu:

; 372  : 	if (y & (1ULL << 14)) output |= (1ULL << (64 - 53)); //bit 50

  00355	48 0f ba e1 0e	 bt	 rcx, 14
  0035a	73 05		 jae	 SHORT $LN51@finalPermu
  0035c	48 0f ba e8 0b	 bts	 rax, 11
$LN51@finalPermu:

; 373  : 	if (y & (1ULL << 13)) output |= (1ULL << (64 - 45)); //bit 51

  00361	48 0f ba e1 0d	 bt	 rcx, 13
  00366	73 05		 jae	 SHORT $LN52@finalPermu
  00368	48 0f ba e8 13	 bts	 rax, 19
$LN52@finalPermu:

; 374  : 	if (y & (1ULL << 12)) output |= (1ULL << (64 - 37)); //bit 52

  0036d	48 0f ba e1 0c	 bt	 rcx, 12
  00372	73 05		 jae	 SHORT $LN53@finalPermu
  00374	48 0f ba e8 1b	 bts	 rax, 27
$LN53@finalPermu:

; 375  : 	if (y & (1ULL << 11)) output |= (1ULL << (64 - 29)); //bit 53

  00379	48 0f ba e1 0b	 bt	 rcx, 11
  0037e	73 03		 jae	 SHORT $LN54@finalPermu
  00380	48 0b c3	 or	 rax, rbx
$LN54@finalPermu:

; 376  : 	if (y & (1ULL << 10)) output |= (1ULL << (64 - 21)); //bit 54

  00383	48 0f ba e1 0a	 bt	 rcx, 10
  00388	73 0d		 jae	 SHORT $LN55@finalPermu
  0038a	48 ba 00 00 00
	00 00 08 00 00	 mov	 rdx, 8796093022208	; 0000080000000000H
  00394	48 0b c2	 or	 rax, rdx
$LN55@finalPermu:

; 377  : 	if (y & (1ULL << 9))  output |= (1ULL << (64 - 13)); //bit 55

  00397	48 0f ba e1 09	 bt	 rcx, 9
  0039c	73 0d		 jae	 SHORT $LN56@finalPermu
  0039e	48 ba 00 00 00
	00 00 00 08 00	 mov	 rdx, 2251799813685248	; 0008000000000000H
  003a8	48 0b c2	 or	 rax, rdx
$LN56@finalPermu:

; 378  : 	if (y & (1ULL << 8))  output |= (1ULL << (64 - 5));  //bit 56

  003ab	48 0f ba e1 08	 bt	 rcx, 8
  003b0	73 0d		 jae	 SHORT $LN57@finalPermu
  003b2	48 ba 00 00 00
	00 00 00 00 08	 mov	 rdx, 576460752303423488	; 0800000000000000H
  003bc	48 0b c2	 or	 rax, rdx
$LN57@finalPermu:

; 379  : 	if (y & (1ULL << 7))  output |= (1ULL << (64 - 63)); //bit 57

  003bf	84 c9		 test	 cl, cl
  003c1	79 04		 jns	 SHORT $LN58@finalPermu
  003c3	48 83 c8 02	 or	 rax, 2
$LN58@finalPermu:

; 380  : 	if (y & (1ULL << 6))  output |= (1ULL << (64 - 55)); //bit 58

  003c7	f6 c1 40	 test	 cl, 64			; 00000040H
  003ca	74 05		 je	 SHORT $LN59@finalPermu
  003cc	48 0f ba e8 09	 bts	 rax, 9
$LN59@finalPermu:

; 381  : 	if (y & (1ULL << 5))  output |= (1ULL << (64 - 47)); //bit 59

  003d1	f6 c1 20	 test	 cl, 32			; 00000020H
  003d4	74 05		 je	 SHORT $LN60@finalPermu
  003d6	48 0f ba e8 11	 bts	 rax, 17
$LN60@finalPermu:

; 382  : 	if (y & (1ULL << 4))  output |= (1ULL << (64 - 39)); //bit 60

  003db	f6 c1 10	 test	 cl, 16
  003de	74 05		 je	 SHORT $LN61@finalPermu
  003e0	48 0f ba e8 19	 bts	 rax, 25
$LN61@finalPermu:

; 383  : 	if (y & (1ULL << 3))  output |= (1ULL << (64 - 31)); //bit 61

  003e5	f6 c1 08	 test	 cl, 8
  003e8	74 03		 je	 SHORT $LN62@finalPermu
  003ea	49 0b c0	 or	 rax, r8
$LN62@finalPermu:

; 384  : 	if (y & (1ULL << 2))  output |= (1ULL << (64 - 23)); //bit 62

  003ed	f6 c1 04	 test	 cl, 4
  003f0	74 0d		 je	 SHORT $LN63@finalPermu
  003f2	48 ba 00 00 00
	00 00 02 00 00	 mov	 rdx, 2199023255552	; 0000020000000000H
  003fc	48 0b c2	 or	 rax, rdx
$LN63@finalPermu:

; 385  : 	if (y & (1ULL << 1))  output |= (1ULL << (64 - 15)); //bit 63

  003ff	f6 c1 02	 test	 cl, 2
  00402	74 0d		 je	 SHORT $LN64@finalPermu
  00404	48 ba 00 00 00
	00 00 00 02 00	 mov	 rdx, 562949953421312	; 0002000000000000H
  0040e	48 0b c2	 or	 rax, rdx
$LN64@finalPermu:

; 386  : 	if (y & (1ULL << 0))  output |= (1ULL << (64 - 7));  //bit 64

  00411	f6 c1 01	 test	 cl, 1
  00414	74 0d		 je	 SHORT $LN67@finalPermu
  00416	48 b9 00 00 00
	00 00 00 00 02	 mov	 rcx, 144115188075855872	; 0200000000000000H
  00420	48 0b c1	 or	 rax, rcx
$LN67@finalPermu:

; 387  : 
; 388  : 	return output;
; 389  : }

  00423	48 8b 5c 24 28	 mov	 rbx, QWORD PTR [rsp+40]
  00428	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]
  0042d	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00432	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
  00437	41 5f		 pop	 r15
  00439	41 5e		 pop	 r14
  0043b	41 5d		 pop	 r13
  0043d	41 5c		 pop	 r12
  0043f	c3		 ret	 0
?finalPermutation@@YA_K_K@Z ENDP			; finalPermutation
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\coschm\desktop\fall-2016\security\des\des\des\main.cpp
_TEXT	SEGMENT
y$ = 40
?permutation1@@YA_K_K@Z PROC				; permutation1

; 242  : {

$LN69:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 54		 push	 r12
  00016	41 55		 push	 r13
  00018	41 56		 push	 r14
  0001a	41 57		 push	 r15

; 243  : 	uint64_t output = 0;

  0001c	33 c0		 xor	 eax, eax

; 244  : 	if (y & (1ULL << 63)) output |= (1ULL << (64 - 40)); //bit 1

  0001e	48 ba 00 00 00
	00 00 00 00 80	 mov	 rdx, -9223372036854775808 ; 8000000000000000H
  00028	48 85 ca	 test	 rcx, rdx

; 245  : 	if (y & (1ULL << 62)) output |= (1ULL << (64 - 8));  //bit 2

  0002b	49 b8 00 00 00
	00 00 00 00 40	 mov	 r8, 4611686018427387904	; 4000000000000000H
  00035	ba 00 00 00 01	 mov	 edx, 16777216		; 01000000H
  0003a	0f 45 c2	 cmovne	 eax, edx
  0003d	48 ba 00 00 00
	00 00 00 00 01	 mov	 rdx, 72057594037927936	; 0100000000000000H
  00047	49 85 c8	 test	 rcx, r8
  0004a	74 03		 je	 SHORT $LN3@permutatio
  0004c	48 0b c2	 or	 rax, rdx
$LN3@permutatio:

; 246  : 	if (y & (1ULL << 61)) output |= (1ULL << (64 - 48)); //bit 3

  0004f	49 b8 00 00 00
	00 00 00 00 20	 mov	 r8, 2305843009213693952	; 2000000000000000H
  00059	49 85 c8	 test	 rcx, r8
  0005c	74 05		 je	 SHORT $LN4@permutatio
  0005e	48 0f ba e8 10	 bts	 rax, 16
$LN4@permutatio:

; 247  : 	if (y & (1ULL << 60)) output |= (1ULL << (64 - 16)); //bit 4

  00063	49 bc 00 00 00
	00 00 00 00 10	 mov	 r12, 1152921504606846976 ; 1000000000000000H
  0006d	49 b9 00 00 00
	00 00 00 01 00	 mov	 r9, 281474976710656	; 0001000000000000H
  00077	49 85 cc	 test	 rcx, r12
  0007a	74 03		 je	 SHORT $LN5@permutatio
  0007c	49 0b c1	 or	 rax, r9
$LN5@permutatio:

; 248  : 	if (y & (1ULL << 59)) output |= (1ULL << (64 - 56)); //bit 5

  0007f	48 bf 00 00 00
	00 00 00 00 08	 mov	 rdi, 576460752303423488	; 0800000000000000H
  00089	48 85 cf	 test	 rcx, rdi
  0008c	74 05		 je	 SHORT $LN6@permutatio
  0008e	48 0f ba e8 08	 bts	 rax, 8
$LN6@permutatio:

; 249  : 	if (y & (1ULL << 58)) output |= (1ULL << (64 - 24)); //bit 6

  00093	49 ba 00 00 00
	00 00 00 00 04	 mov	 r10, 288230376151711744	; 0400000000000000H
  0009d	48 bb 00 00 00
	00 00 01 00 00	 mov	 rbx, 1099511627776	; 0000010000000000H
  000a7	49 85 ca	 test	 rcx, r10
  000aa	74 03		 je	 SHORT $LN7@permutatio
  000ac	48 0b c3	 or	 rax, rbx
$LN7@permutatio:

; 250  : 	if (y & (1ULL << 57)) output |= (1ULL << (64 - 64)); //bit 7

  000af	49 b8 00 00 00
	00 00 00 00 02	 mov	 r8, 144115188075855872	; 0200000000000000H
  000b9	49 85 c8	 test	 rcx, r8
  000bc	74 04		 je	 SHORT $LN8@permutatio
  000be	48 83 c8 01	 or	 rax, 1
$LN8@permutatio:

; 251  : 	if (y & (1ULL << 56)) output |= (1ULL << (64 - 32)); //bit 8

  000c2	49 be 00 00 00
	00 01 00 00 00	 mov	 r14, 4294967296		; 0000000100000000H
  000cc	48 85 ca	 test	 rcx, rdx
  000cf	74 03		 je	 SHORT $LN9@permutatio
  000d1	49 0b c6	 or	 rax, r14
$LN9@permutatio:

; 252  : 	if (y & (1ULL << 55)) output |= (1ULL << (64 - 39)); //bit 9

  000d4	48 ba 00 00 00
	00 00 00 80 00	 mov	 rdx, 36028797018963968	; 0080000000000000H
  000de	48 85 ca	 test	 rcx, rdx
  000e1	74 05		 je	 SHORT $LN10@permutatio
  000e3	48 0f ba e8 19	 bts	 rax, 25
$LN10@permutatio:

; 253  : 	if (y & (1ULL << 54)) output |= (1ULL << (64 - 7));  //bit 10

  000e8	48 ba 00 00 00
	00 00 00 40 00	 mov	 rdx, 18014398509481984	; 0040000000000000H
  000f2	48 85 ca	 test	 rcx, rdx
  000f5	74 03		 je	 SHORT $LN11@permutatio
  000f7	49 0b c0	 or	 rax, r8
$LN11@permutatio:

; 254  : 	if (y & (1ULL << 53)) output |= (1ULL << (64 - 47)); //bit 11

  000fa	48 ba 00 00 00
	00 00 00 20 00	 mov	 rdx, 9007199254740992	; 0020000000000000H
  00104	48 85 ca	 test	 rcx, rdx
  00107	74 05		 je	 SHORT $LN12@permutatio
  00109	48 0f ba e8 11	 bts	 rax, 17
$LN12@permutatio:

; 255  : 	if (y & (1ULL << 52)) output |= (1ULL << (64 - 15)); //bit 12

  0010e	49 bd 00 00 00
	00 00 00 10 00	 mov	 r13, 4503599627370496	; 0010000000000000H
  00118	48 ba 00 00 00
	00 00 00 02 00	 mov	 rdx, 562949953421312	; 0002000000000000H
  00122	49 85 cd	 test	 rcx, r13
  00125	74 03		 je	 SHORT $LN13@permutatio
  00127	48 0b c2	 or	 rax, rdx
$LN13@permutatio:

; 256  : 	if (y & (1ULL << 51)) output |= (1ULL << (64 - 55)); //bit 13

  0012a	48 be 00 00 00
	00 00 00 08 00	 mov	 rsi, 2251799813685248	; 0008000000000000H
  00134	48 85 ce	 test	 rcx, rsi
  00137	74 05		 je	 SHORT $LN14@permutatio
  00139	48 0f ba e8 09	 bts	 rax, 9
$LN14@permutatio:

; 257  : 	if (y & (1ULL << 50)) output |= (1ULL << (64 - 23)); //bit 14

  0013e	49 b8 00 00 00
	00 00 00 04 00	 mov	 r8, 1125899906842624	; 0004000000000000H
  00148	49 bb 00 00 00
	00 00 02 00 00	 mov	 r11, 2199023255552	; 0000020000000000H
  00152	49 85 c8	 test	 rcx, r8
  00155	74 03		 je	 SHORT $LN15@permutatio
  00157	49 0b c3	 or	 rax, r11
$LN15@permutatio:

; 258  : 	if (y & (1ULL << 49)) output |= (1ULL << (64 - 63)); //bit 15

  0015a	48 85 ca	 test	 rcx, rdx
  0015d	74 04		 je	 SHORT $LN16@permutatio
  0015f	48 83 c8 02	 or	 rax, 2
$LN16@permutatio:

; 259  : 	if (y & (1ULL << 48)) output |= (1ULL << (64 - 31)); //bit 16

  00163	48 bd 00 00 00
	00 02 00 00 00	 mov	 rbp, 8589934592		; 0000000200000000H
  0016d	49 85 c9	 test	 rcx, r9
  00170	74 03		 je	 SHORT $LN17@permutatio
  00172	48 0b c5	 or	 rax, rbp
$LN17@permutatio:

; 260  : 
; 261  : 	if (y & (1ULL << 47)) output |= (1ULL << (64 - 38)); //bit 17

  00175	48 ba 00 00 00
	00 00 80 00 00	 mov	 rdx, 140737488355328	; 0000800000000000H
  0017f	48 85 ca	 test	 rcx, rdx
  00182	74 05		 je	 SHORT $LN18@permutatio
  00184	48 0f ba e8 1a	 bts	 rax, 26
$LN18@permutatio:

; 262  : 	if (y & (1ULL << 46)) output |= (1ULL << (64 - 6));  //bit 18

  00189	48 ba 00 00 00
	00 00 40 00 00	 mov	 rdx, 70368744177664	; 0000400000000000H
  00193	48 85 ca	 test	 rcx, rdx
  00196	74 03		 je	 SHORT $LN19@permutatio
  00198	49 0b c2	 or	 rax, r10
$LN19@permutatio:

; 263  : 	if (y & (1ULL << 45)) output |= (1ULL << (64 - 46)); //bit 19

  0019b	48 ba 00 00 00
	00 00 20 00 00	 mov	 rdx, 35184372088832	; 0000200000000000H
  001a5	48 85 ca	 test	 rcx, rdx
  001a8	74 05		 je	 SHORT $LN20@permutatio
  001aa	48 0f ba e8 12	 bts	 rax, 18
$LN20@permutatio:

; 264  : 	if (y & (1ULL << 44)) output |= (1ULL << (64 - 14)); //bit 20

  001af	49 bf 00 00 00
	00 00 10 00 00	 mov	 r15, 17592186044416	; 0000100000000000H
  001b9	49 85 cf	 test	 rcx, r15
  001bc	74 03		 je	 SHORT $LN21@permutatio
  001be	49 0b c0	 or	 rax, r8
$LN21@permutatio:

; 265  : 	if (y & (1ULL << 43)) output |= (1ULL << (64 - 54)); //bit 21

  001c1	49 b9 00 00 00
	00 00 08 00 00	 mov	 r9, 8796093022208	; 0000080000000000H
  001cb	49 85 c9	 test	 rcx, r9
  001ce	74 05		 je	 SHORT $LN22@permutatio
  001d0	48 0f ba e8 0a	 bts	 rax, 10
$LN22@permutatio:

; 266  : 	if (y & (1ULL << 42)) output |= (1ULL << (64 - 22)); //bit 22

  001d5	48 ba 00 00 00
	00 00 04 00 00	 mov	 rdx, 4398046511104	; 0000040000000000H
  001df	48 85 ca	 test	 rcx, rdx
  001e2	74 03		 je	 SHORT $LN23@permutatio
  001e4	48 0b c2	 or	 rax, rdx
$LN23@permutatio:

; 267  : 	if (y & (1ULL << 41)) output |= (1ULL << (64 - 62)); //bit 23

  001e7	49 85 cb	 test	 rcx, r11
  001ea	74 04		 je	 SHORT $LN24@permutatio
  001ec	48 83 c8 04	 or	 rax, 4
$LN24@permutatio:

; 268  : 	if (y & (1ULL << 40)) output |= (1ULL << (64 - 30)); //bit 24

  001f0	49 b8 00 00 00
	00 04 00 00 00	 mov	 r8, 17179869184		; 0000000400000000H
  001fa	48 85 cb	 test	 rcx, rbx
  001fd	74 03		 je	 SHORT $LN25@permutatio
  001ff	49 0b c0	 or	 rax, r8
$LN25@permutatio:

; 269  : 	if (y & (1ULL << 39)) output |= (1ULL << (64 - 37)); //bit 25

  00202	48 ba 00 00 00
	00 80 00 00 00	 mov	 rdx, 549755813888	; 0000008000000000H
  0020c	48 85 ca	 test	 rcx, rdx
  0020f	74 05		 je	 SHORT $LN26@permutatio
  00211	48 0f ba e8 1b	 bts	 rax, 27
$LN26@permutatio:

; 270  : 	if (y & (1ULL << 38)) output |= (1ULL << (64 - 5));  //bit 26

  00216	48 bb 00 00 00
	00 40 00 00 00	 mov	 rbx, 274877906944	; 0000004000000000H
  00220	48 85 cb	 test	 rcx, rbx
  00223	74 03		 je	 SHORT $LN27@permutatio
  00225	48 0b c7	 or	 rax, rdi
$LN27@permutatio:

; 271  : 	if (y & (1ULL << 37)) output |= (1ULL << (64 - 45)); //bit 27

  00228	49 bb 00 00 00
	00 20 00 00 00	 mov	 r11, 137438953472	; 0000002000000000H
  00232	49 85 cb	 test	 rcx, r11
  00235	74 05		 je	 SHORT $LN28@permutatio
  00237	48 0f ba e8 13	 bts	 rax, 19
$LN28@permutatio:

; 272  : 	if (y & (1ULL << 36)) output |= (1ULL << (64 - 13)); //bit 28

  0023c	49 ba 00 00 00
	00 10 00 00 00	 mov	 r10, 68719476736	; 0000001000000000H
  00246	49 85 ca	 test	 rcx, r10
  00249	74 03		 je	 SHORT $LN29@permutatio
  0024b	48 0b c6	 or	 rax, rsi
$LN29@permutatio:

; 273  : 	if (y & (1ULL << 35)) output |= (1ULL << (64 - 53)); //bit 29

  0024e	48 ba 00 00 00
	00 08 00 00 00	 mov	 rdx, 34359738368	; 0000000800000000H
  00258	48 85 ca	 test	 rcx, rdx
  0025b	74 05		 je	 SHORT $LN30@permutatio
  0025d	48 0f ba e8 0b	 bts	 rax, 11
$LN30@permutatio:

; 274  : 	if (y & (1ULL << 34)) output |= (1ULL << (64 - 21)); //bit 30

  00262	49 85 c8	 test	 rcx, r8
  00265	74 03		 je	 SHORT $LN31@permutatio
  00267	49 0b c1	 or	 rax, r9
$LN31@permutatio:

; 275  : 	if (y & (1ULL << 33)) output |= (1ULL << (64 - 61)); //bit 31

  0026a	48 85 cd	 test	 rcx, rbp
  0026d	74 04		 je	 SHORT $LN32@permutatio
  0026f	48 83 c8 08	 or	 rax, 8
$LN32@permutatio:

; 276  : 	if (y & (1ULL << 32)) output |= (1ULL << (64 - 29)); //bit 32

  00273	49 85 ce	 test	 rcx, r14
  00276	74 03		 je	 SHORT $LN33@permutatio
  00278	48 0b c2	 or	 rax, rdx
$LN33@permutatio:

; 277  : 
; 278  : 	if (y & (1ULL << 31)) output |= (1ULL << (64 - 36)); //bit 33

  0027b	ba 00 00 00 80	 mov	 edx, -2147483648	; 80000000H
  00280	48 85 ca	 test	 rcx, rdx
  00283	74 05		 je	 SHORT $LN34@permutatio
  00285	48 0f ba e8 1c	 bts	 rax, 28
$LN34@permutatio:

; 279  : 	if (y & (1ULL << 30)) output |= (1ULL << (64 - 4));  //bit 34

  0028a	48 0f ba e1 1e	 bt	 rcx, 30
  0028f	73 03		 jae	 SHORT $LN35@permutatio
  00291	49 0b c4	 or	 rax, r12
$LN35@permutatio:

; 280  : 	if (y & (1ULL << 29)) output |= (1ULL << (64 - 44)); //bit 35

  00294	48 0f ba e1 1d	 bt	 rcx, 29
  00299	73 05		 jae	 SHORT $LN36@permutatio
  0029b	48 0f ba e8 14	 bts	 rax, 20
$LN36@permutatio:

; 281  : 	if (y & (1ULL << 28)) output |= (1ULL << (64 - 12)); //bit 36

  002a0	48 0f ba e1 1c	 bt	 rcx, 28
  002a5	73 03		 jae	 SHORT $LN37@permutatio
  002a7	49 0b c5	 or	 rax, r13
$LN37@permutatio:

; 282  : 	if (y & (1ULL << 27)) output |= (1ULL << (64 - 52)); //bit 37

  002aa	48 0f ba e1 1b	 bt	 rcx, 27
  002af	73 05		 jae	 SHORT $LN38@permutatio
  002b1	48 0f ba e8 0c	 bts	 rax, 12
$LN38@permutatio:

; 283  : 	if (y & (1ULL << 26)) output |= (1ULL << (64 - 20)); //bit 38

  002b6	48 0f ba e1 1a	 bt	 rcx, 26
  002bb	73 03		 jae	 SHORT $LN39@permutatio
  002bd	49 0b c7	 or	 rax, r15
$LN39@permutatio:

; 284  : 	if (y & (1ULL << 25)) output |= (1ULL << (64 - 60)); //bit 39

  002c0	48 0f ba e1 19	 bt	 rcx, 25
  002c5	73 04		 jae	 SHORT $LN40@permutatio
  002c7	48 83 c8 10	 or	 rax, 16
$LN40@permutatio:

; 285  : 	if (y & (1ULL << 24)) output |= (1ULL << (64 - 28)); //bit 40

  002cb	48 0f ba e1 18	 bt	 rcx, 24
  002d0	73 03		 jae	 SHORT $LN41@permutatio
  002d2	49 0b c2	 or	 rax, r10
$LN41@permutatio:

; 286  : 	if (y & (1ULL << 23)) output |= (1ULL << (64 - 35)); //bit 41

  002d5	48 0f ba e1 17	 bt	 rcx, 23
  002da	73 05		 jae	 SHORT $LN42@permutatio
  002dc	48 0f ba e8 1d	 bts	 rax, 29
$LN42@permutatio:

; 287  : 	if (y & (1ULL << 22)) output |= (1ULL << (64 - 3));  //bit 42

  002e1	48 0f ba e1 16	 bt	 rcx, 22
  002e6	73 0d		 jae	 SHORT $LN43@permutatio
  002e8	49 b8 00 00 00
	00 00 00 00 20	 mov	 r8, 2305843009213693952	; 2000000000000000H
  002f2	49 0b c0	 or	 rax, r8
$LN43@permutatio:

; 288  : 	if (y & (1ULL << 21)) output |= (1ULL << (64 - 43)); //bit 43

  002f5	48 0f ba e1 15	 bt	 rcx, 21
  002fa	73 05		 jae	 SHORT $LN44@permutatio
  002fc	48 0f ba e8 15	 bts	 rax, 21
$LN44@permutatio:

; 289  : 	if (y & (1ULL << 20)) output |= (1ULL << (64 - 11)); //bit 44

  00301	48 0f ba e1 14	 bt	 rcx, 20
  00306	73 0d		 jae	 SHORT $LN45@permutatio
  00308	49 b8 00 00 00
	00 00 00 20 00	 mov	 r8, 9007199254740992	; 0020000000000000H
  00312	49 0b c0	 or	 rax, r8
$LN45@permutatio:

; 290  : 	if (y & (1ULL << 19)) output |= (1ULL << (64 - 51)); //bit 45

  00315	48 0f ba e1 13	 bt	 rcx, 19
  0031a	73 05		 jae	 SHORT $LN46@permutatio
  0031c	48 0f ba e8 0d	 bts	 rax, 13
$LN46@permutatio:

; 291  : 	if (y & (1ULL << 18)) output |= (1ULL << (64 - 19)); //bit 46

  00321	48 0f ba e1 12	 bt	 rcx, 18
  00326	73 0d		 jae	 SHORT $LN47@permutatio
  00328	49 b8 00 00 00
	00 00 20 00 00	 mov	 r8, 35184372088832	; 0000200000000000H
  00332	49 0b c0	 or	 rax, r8
$LN47@permutatio:

; 292  : 	if (y & (1ULL << 17)) output |= (1ULL << (64 - 59)); //bit 47

  00335	48 0f ba e1 11	 bt	 rcx, 17
  0033a	73 04		 jae	 SHORT $LN48@permutatio
  0033c	48 83 c8 20	 or	 rax, 32			; 00000020H
$LN48@permutatio:

; 293  : 	if (y & (1ULL << 16)) output |= (1ULL << (64 - 27)); //bit 48

  00340	48 0f ba e1 10	 bt	 rcx, 16
  00345	73 03		 jae	 SHORT $LN49@permutatio
  00347	49 0b c3	 or	 rax, r11
$LN49@permutatio:

; 294  : 
; 295  : 	if (y & (1ULL << 15)) output |= (1ULL << (64 - 34)); //bit 49

  0034a	48 0f ba e1 0f	 bt	 rcx, 15
  0034f	73 05		 jae	 SHORT $LN50@permutatio
  00351	48 0f ba e8 1e	 bts	 rax, 30
$LN50@permutatio:

; 296  : 	if (y & (1ULL << 14)) output |= (1ULL << (64 - 2));  //bit 50

  00356	48 0f ba e1 0e	 bt	 rcx, 14
  0035b	73 0d		 jae	 SHORT $LN51@permutatio
  0035d	49 b8 00 00 00
	00 00 00 00 40	 mov	 r8, 4611686018427387904	; 4000000000000000H
  00367	49 0b c0	 or	 rax, r8
$LN51@permutatio:

; 297  : 	if (y & (1ULL << 13)) output |= (1ULL << (64 - 42)); //bit 51

  0036a	48 0f ba e1 0d	 bt	 rcx, 13
  0036f	73 05		 jae	 SHORT $LN52@permutatio
  00371	48 0f ba e8 16	 bts	 rax, 22
$LN52@permutatio:

; 298  : 	if (y & (1ULL << 12)) output |= (1ULL << (64 - 10)); //bit 52

  00376	48 0f ba e1 0c	 bt	 rcx, 12
  0037b	73 0d		 jae	 SHORT $LN53@permutatio
  0037d	49 b8 00 00 00
	00 00 00 40 00	 mov	 r8, 18014398509481984	; 0040000000000000H
  00387	49 0b c0	 or	 rax, r8
$LN53@permutatio:

; 299  : 	if (y & (1ULL << 11)) output |= (1ULL << (64 - 50)); //bit 53

  0038a	48 0f ba e1 0b	 bt	 rcx, 11
  0038f	73 05		 jae	 SHORT $LN54@permutatio
  00391	48 0f ba e8 0e	 bts	 rax, 14
$LN54@permutatio:

; 300  : 	if (y & (1ULL << 10)) output |= (1ULL << (64 - 18)); //bit 54

  00396	48 0f ba e1 0a	 bt	 rcx, 10
  0039b	73 0d		 jae	 SHORT $LN55@permutatio
  0039d	49 b8 00 00 00
	00 00 40 00 00	 mov	 r8, 70368744177664	; 0000400000000000H
  003a7	49 0b c0	 or	 rax, r8
$LN55@permutatio:

; 301  : 	if (y & (1ULL << 9))  output |= (1ULL << (64 - 58)); //bit 55

  003aa	48 0f ba e1 09	 bt	 rcx, 9
  003af	73 04		 jae	 SHORT $LN56@permutatio
  003b1	48 83 c8 40	 or	 rax, 64			; 00000040H
$LN56@permutatio:

; 302  : 	if (y & (1ULL << 8))  output |= (1ULL << (64 - 26)); //bit 56

  003b5	48 0f ba e1 08	 bt	 rcx, 8
  003ba	73 03		 jae	 SHORT $LN57@permutatio
  003bc	48 0b c3	 or	 rax, rbx
$LN57@permutatio:

; 303  : 	if (y & (1ULL << 7))  output |= (1ULL << (64 - 33)); //bit 57

  003bf	84 c9		 test	 cl, cl
  003c1	79 03		 jns	 SHORT $LN58@permutatio
  003c3	48 0b c2	 or	 rax, rdx
$LN58@permutatio:

; 304  : 	if (y & (1ULL << 6))  output |= (1ULL << (64 - 1));  //bit 58

  003c6	f6 c1 40	 test	 cl, 64			; 00000040H
  003c9	74 0d		 je	 SHORT $LN59@permutatio
  003cb	48 ba 00 00 00
	00 00 00 00 80	 mov	 rdx, -9223372036854775808 ; 8000000000000000H
  003d5	48 0b c2	 or	 rax, rdx
$LN59@permutatio:

; 305  : 	if (y & (1ULL << 5))  output |= (1ULL << (64 - 41)); //bit 59

  003d8	f6 c1 20	 test	 cl, 32			; 00000020H
  003db	74 05		 je	 SHORT $LN60@permutatio
  003dd	48 0f ba e8 17	 bts	 rax, 23
$LN60@permutatio:

; 306  : 	if (y & (1ULL << 4))  output |= (1ULL << (64 - 9));  //bit 60

  003e2	f6 c1 10	 test	 cl, 16
  003e5	74 0d		 je	 SHORT $LN61@permutatio
  003e7	48 ba 00 00 00
	00 00 00 80 00	 mov	 rdx, 36028797018963968	; 0080000000000000H
  003f1	48 0b c2	 or	 rax, rdx
$LN61@permutatio:

; 307  : 	if (y & (1ULL << 3))  output |= (1ULL << (64 - 49)); //bit 61

  003f4	f6 c1 08	 test	 cl, 8
  003f7	74 05		 je	 SHORT $LN62@permutatio
  003f9	48 0f ba e8 0f	 bts	 rax, 15
$LN62@permutatio:

; 308  : 	if (y & (1ULL << 2))  output |= (1ULL << (64 - 17)); //bit 62

  003fe	f6 c1 04	 test	 cl, 4
  00401	74 0d		 je	 SHORT $LN63@permutatio
  00403	48 ba 00 00 00
	00 00 80 00 00	 mov	 rdx, 140737488355328	; 0000800000000000H
  0040d	48 0b c2	 or	 rax, rdx
$LN63@permutatio:

; 309  : 	if (y & (1ULL << 1))  output |= (1ULL << (64 - 57)); //bit 63

  00410	f6 c1 02	 test	 cl, 2
  00413	74 05		 je	 SHORT $LN64@permutatio
  00415	48 0f ba e8 07	 bts	 rax, 7
$LN64@permutatio:

; 310  : 	if (y & (1ULL << 0))  output |= (1ULL << (64 - 25)); //bit 64

  0041a	f6 c1 01	 test	 cl, 1
  0041d	74 0d		 je	 SHORT $LN67@permutatio
  0041f	48 b9 00 00 00
	00 80 00 00 00	 mov	 rcx, 549755813888	; 0000008000000000H
  00429	48 0b c1	 or	 rax, rcx
$LN67@permutatio:

; 311  : 
; 312  : 	return output;
; 313  : // end of initial permutation
; 314  : }

  0042c	48 8b 5c 24 28	 mov	 rbx, QWORD PTR [rsp+40]
  00431	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]
  00436	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0043b	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
  00440	41 5f		 pop	 r15
  00442	41 5e		 pop	 r14
  00444	41 5d		 pop	 r13
  00446	41 5c		 pop	 r12
  00448	c3		 ret	 0
?permutation1@@YA_K_K@Z ENDP				; permutation1
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\coschm\desktop\fall-2016\security\des\des\des\main.cpp
_TEXT	SEGMENT
key$ = 8
?compressPermuteKey@@YA_K_K@Z PROC			; compressPermuteKey

; 177  : {

$LN53:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi

; 178  : 	//This part compresses the input key into Permuted 48 bit Key
; 179  : 	uint64_t permKey = 0ULL;

  00014	33 c0		 xor	 eax, eax

; 180  : 
; 181  : 	if (key & (1ULL << 55)) permKey |= (1ULL << (48 - 5));	

  00016	48 ba 00 00 00
	00 00 00 80 00	 mov	 rdx, 36028797018963968	; 0080000000000000H
  00020	48 85 ca	 test	 rcx, rdx
  00023	49 ba 00 00 00
	00 00 08 00 00	 mov	 r10, 8796093022208	; 0000080000000000H

; 182  : 	if (key & (1ULL << 54)) permKey |= (1ULL << (48 - 24)); 

  0002d	48 ba 00 00 00
	00 00 00 40 00	 mov	 rdx, 18014398509481984	; 0040000000000000H
  00037	49 0f 45 c2	 cmovne	 rax, r10
  0003b	48 85 ca	 test	 rcx, rdx
  0003e	74 05		 je	 SHORT $LN3@compressPe
  00040	48 0f ba e8 18	 bts	 rax, 24
$LN3@compressPe:

; 183  : 	if (key & (1ULL << 53)) permKey |= (1ULL << (48 - 7)); 

  00045	48 ba 00 00 00
	00 00 00 20 00	 mov	 rdx, 9007199254740992	; 0020000000000000H
  0004f	49 b9 00 00 00
	00 00 02 00 00	 mov	 r9, 2199023255552	; 0000020000000000H
  00059	48 85 ca	 test	 rcx, rdx
  0005c	74 03		 je	 SHORT $LN4@compressPe
  0005e	49 0b c1	 or	 rax, r9
$LN4@compressPe:

; 184  : 	if (key & (1ULL << 52)) permKey |= (1ULL << (48 - 16)); 

  00061	48 ba 00 00 00
	00 00 00 10 00	 mov	 rdx, 4503599627370496	; 0010000000000000H
  0006b	48 bd 00 00 00
	00 01 00 00 00	 mov	 rbp, 4294967296		; 0000000100000000H
  00075	48 85 ca	 test	 rcx, rdx
  00078	74 03		 je	 SHORT $LN5@compressPe
  0007a	48 0b c5	 or	 rax, rbp
$LN5@compressPe:

; 185  : 	if (key & (1ULL << 51)) permKey |= (1ULL << (48 - 6)); 

  0007d	48 ba 00 00 00
	00 00 00 08 00	 mov	 rdx, 2251799813685248	; 0008000000000000H
  00087	49 b8 00 00 00
	00 00 04 00 00	 mov	 r8, 4398046511104	; 0000040000000000H
  00091	48 85 ca	 test	 rcx, rdx
  00094	74 03		 je	 SHORT $LN6@compressPe
  00096	49 0b c0	 or	 rax, r8
$LN6@compressPe:

; 186  : 	if (key & (1ULL << 50)) permKey |= (1ULL << (48 - 10)); 

  00099	48 ba 00 00 00
	00 00 00 04 00	 mov	 rdx, 1125899906842624	; 0004000000000000H
  000a3	48 85 ca	 test	 rcx, rdx
  000a6	74 0d		 je	 SHORT $LN7@compressPe
  000a8	48 ba 00 00 00
	00 40 00 00 00	 mov	 rdx, 274877906944	; 0000004000000000H
  000b2	48 0b c2	 or	 rax, rdx
$LN7@compressPe:

; 187  : 	if (key & (1ULL << 49)) permKey |= (1ULL << (48 - 20)); //7

  000b5	48 ba 00 00 00
	00 00 00 02 00	 mov	 rdx, 562949953421312	; 0002000000000000H
  000bf	48 85 ca	 test	 rcx, rdx
  000c2	74 05		 je	 SHORT $LN8@compressPe
  000c4	48 0f ba e8 1c	 bts	 rax, 28
$LN8@compressPe:

; 188  : 	if (key & (1ULL << 48)) permKey |= (1ULL << (48 - 18));

  000c9	48 ba 00 00 00
	00 00 00 01 00	 mov	 rdx, 281474976710656	; 0001000000000000H
  000d3	48 85 ca	 test	 rcx, rdx
  000d6	74 05		 je	 SHORT $LN9@compressPe
  000d8	48 0f ba e8 1e	 bts	 rax, 30
$LN9@compressPe:

; 189  : 	//skip bit 9
; 190  : 	if (key & (1ULL << 46)) permKey |= (1ULL << (48 - 12)); 

  000dd	49 bb 00 00 00
	00 00 40 00 00	 mov	 r11, 70368744177664	; 0000400000000000H
  000e7	48 bb 00 00 00
	00 10 00 00 00	 mov	 rbx, 68719476736	; 0000001000000000H
  000f1	49 85 cb	 test	 rcx, r11
  000f4	74 03		 je	 SHORT $LN10@compressPe
  000f6	48 0b c3	 or	 rax, rbx
$LN10@compressPe:

; 191  : 	if (key & (1ULL << 45)) permKey |= (1ULL << (48 - 3)); 

  000f9	48 ba 00 00 00
	00 00 20 00 00	 mov	 rdx, 35184372088832	; 0000200000000000H
  00103	48 85 ca	 test	 rcx, rdx
  00106	74 03		 je	 SHORT $LN11@compressPe
  00108	48 0b c2	 or	 rax, rdx
$LN11@compressPe:

; 192  : 	if (key & (1ULL << 44)) permKey |= (1ULL << (48 - 15)); 

  0010b	48 be 00 00 00
	00 00 10 00 00	 mov	 rsi, 17592186044416	; 0000100000000000H
  00115	48 bf 00 00 00
	00 02 00 00 00	 mov	 rdi, 8589934592		; 0000000200000000H
  0011f	48 85 ce	 test	 rcx, rsi
  00122	74 03		 je	 SHORT $LN12@compressPe
  00124	48 0b c7	 or	 rax, rdi
$LN12@compressPe:

; 193  : 	if (key & (1ULL << 43)) permKey |= (1ULL << (48 - 23)); 

  00127	49 85 ca	 test	 rcx, r10
  0012a	74 05		 je	 SHORT $LN13@compressPe
  0012c	48 0f ba e8 19	 bts	 rax, 25
$LN13@compressPe:

; 194  : 	if (key & (1ULL << 42)) permKey |= (1ULL << (48 - 1)); //14

  00131	49 85 c8	 test	 rcx, r8
  00134	74 0d		 je	 SHORT $LN14@compressPe
  00136	48 ba 00 00 00
	00 00 80 00 00	 mov	 rdx, 140737488355328	; 0000800000000000H
  00140	48 0b c2	 or	 rax, rdx
$LN14@compressPe:

; 195  : 	if (key & (1ULL << 41)) permKey |= (1ULL << (48 - 9)); 

  00143	48 ba 00 00 00
	00 80 00 00 00	 mov	 rdx, 549755813888	; 0000008000000000H
  0014d	49 85 c9	 test	 rcx, r9
  00150	74 03		 je	 SHORT $LN15@compressPe
  00152	48 0b c2	 or	 rax, rdx
$LN15@compressPe:

; 196  : 	if (key & (1ULL << 40)) permKey |= (1ULL << (48 - 19)); 

  00155	49 b9 00 00 00
	00 00 01 00 00	 mov	 r9, 1099511627776	; 0000010000000000H
  0015f	49 85 c9	 test	 rcx, r9
  00162	74 05		 je	 SHORT $LN16@compressPe
  00164	48 0f ba e8 1d	 bts	 rax, 29
$LN16@compressPe:

; 197  : 	if (key & (1ULL << 39)) permKey |= (1ULL << (48 - 2));	

  00169	48 85 ca	 test	 rcx, rdx
  0016c	74 03		 je	 SHORT $LN17@compressPe
  0016e	49 0b c3	 or	 rax, r11
$LN17@compressPe:

; 198  : 	//bit 18 skip
; 199  : 	if (key & (1ULL << 37)) permKey |= (1ULL << (48 - 14)); 

  00171	49 b8 00 00 00
	00 20 00 00 00	 mov	 r8, 137438953472	; 0000002000000000H
  0017b	49 85 c8	 test	 rcx, r8
  0017e	74 0d		 je	 SHORT $LN18@compressPe
  00180	48 ba 00 00 00
	00 04 00 00 00	 mov	 rdx, 17179869184	; 0000000400000000H
  0018a	48 0b c2	 or	 rax, rdx
$LN18@compressPe:

; 200  : 	if (key & (1ULL << 36)) permKey |= (1ULL << (48 - 22)); 

  0018d	48 85 cb	 test	 rcx, rbx
  00190	74 05		 je	 SHORT $LN19@compressPe
  00192	48 0f ba e8 1a	 bts	 rax, 26
$LN19@compressPe:

; 201  : 	if (key & (1ULL << 35)) permKey |= (1ULL << (48 - 11)); //21

  00197	48 ba 00 00 00
	00 08 00 00 00	 mov	 rdx, 34359738368	; 0000000800000000H
  001a1	48 85 ca	 test	 rcx, rdx
  001a4	74 03		 je	 SHORT $LN20@compressPe
  001a6	49 0b c0	 or	 rax, r8
$LN20@compressPe:

; 202  : 	//bit 22 skip
; 203  : 	if (key & (1ULL << 33)) permKey |= (1ULL << (48 - 13)); 

  001a9	48 85 cf	 test	 rcx, rdi
  001ac	74 03		 je	 SHORT $LN21@compressPe
  001ae	48 0b c2	 or	 rax, rdx
$LN21@compressPe:

; 204  : 	if (key & (1ULL << 32)) permKey |= (1ULL << (48 - 4)); 

  001b1	48 85 cd	 test	 rcx, rbp
  001b4	74 03		 je	 SHORT $LN22@compressPe
  001b6	48 0b c6	 or	 rax, rsi
$LN22@compressPe:

; 205  : 	//bit 25 skip
; 206  : 	if (key & (1ULL << 30)) permKey |= (1ULL << (48 - 17)); 

  001b9	48 0f ba e1 1e	 bt	 rcx, 30
  001be	73 08		 jae	 SHORT $LN23@compressPe
  001c0	ba 00 00 00 80	 mov	 edx, -2147483648	; 80000000H
  001c5	48 0b c2	 or	 rax, rdx
$LN23@compressPe:

; 207  : 	if (key & (1ULL << 29)) permKey |= (1ULL << (48 - 21)); 

  001c8	48 0f ba e1 1d	 bt	 rcx, 29
  001cd	73 05		 jae	 SHORT $LN24@compressPe
  001cf	48 0f ba e8 1b	 bts	 rax, 27
$LN24@compressPe:

; 208  : 	if (key & (1ULL << 28)) permKey |= (1ULL << (48 - 8)); //28

  001d4	48 0f ba e1 1c	 bt	 rcx, 28
  001d9	73 03		 jae	 SHORT $LN25@compressPe
  001db	49 0b c1	 or	 rax, r9
$LN25@compressPe:

; 209  : 	if (key & (1ULL << 27)) permKey |= (1ULL << (48 - 47)); 

  001de	48 0f ba e1 1b	 bt	 rcx, 27
  001e3	73 04		 jae	 SHORT $LN26@compressPe
  001e5	48 83 c8 02	 or	 rax, 2
$LN26@compressPe:

; 210  : 	if (key & (1ULL << 26)) permKey |= (1ULL << (48 - 31)); 

  001e9	48 0f ba e1 1a	 bt	 rcx, 26
  001ee	73 05		 jae	 SHORT $LN27@compressPe
  001f0	48 0f ba e8 11	 bts	 rax, 17
$LN27@compressPe:

; 211  : 	if (key & (1ULL << 25)) permKey |= (1ULL << (48 - 27)); 

  001f5	48 0f ba e1 19	 bt	 rcx, 25
  001fa	73 05		 jae	 SHORT $LN28@compressPe
  001fc	48 0f ba e8 15	 bts	 rax, 21
$LN28@compressPe:

; 212  : 	if (key & (1ULL << 24)) permKey |= (1ULL << (48 - 48)); 

  00201	48 0f ba e1 18	 bt	 rcx, 24
  00206	73 04		 jae	 SHORT $LN29@compressPe
  00208	48 83 c8 01	 or	 rax, 1
$LN29@compressPe:

; 213  : 	if (key & (1ULL << 23)) permKey |= (1ULL << (48 - 35));	

  0020c	48 0f ba e1 17	 bt	 rcx, 23
  00211	73 05		 jae	 SHORT $LN30@compressPe
  00213	48 0f ba e8 0d	 bts	 rax, 13
$LN30@compressPe:

; 214  : 	if (key & (1ULL << 22)) permKey |= (1ULL << (48 - 41)); 

  00218	48 0f ba e1 16	 bt	 rcx, 22
  0021d	73 05		 jae	 SHORT $LN31@compressPe
  0021f	48 0f ba e8 07	 bts	 rax, 7
$LN31@compressPe:

; 215  : 	//bit 35 skip											//35
; 216  : 	if (key & (1ULL << 20)) permKey |= (1ULL << (48 - 46)); 

  00224	48 0f ba e1 14	 bt	 rcx, 20
  00229	73 04		 jae	 SHORT $LN32@compressPe
  0022b	48 83 c8 04	 or	 rax, 4
$LN32@compressPe:

; 217  : 	if (key & (1ULL << 19)) permKey |= (1ULL << (48 - 28)); 

  0022f	48 0f ba e1 13	 bt	 rcx, 19
  00234	73 05		 jae	 SHORT $LN33@compressPe
  00236	48 0f ba e8 14	 bts	 rax, 20
$LN33@compressPe:

; 218  : 	//bit 38 skip
; 219  : 	if (key & (1ULL << 17)) permKey |= (1ULL << (48 - 39)); 

  0023b	48 0f ba e1 11	 bt	 rcx, 17
  00240	73 05		 jae	 SHORT $LN34@compressPe
  00242	48 0f ba e8 09	 bts	 rax, 9
$LN34@compressPe:

; 220  : 	if (key & (1ULL << 16)) permKey |= (1ULL << (48 - 32)); 

  00247	48 0f ba e1 10	 bt	 rcx, 16
  0024c	73 05		 jae	 SHORT $LN35@compressPe
  0024e	48 0f ba e8 10	 bts	 rax, 16
$LN35@compressPe:

; 221  : 	if (key & (1ULL << 15)) permKey |= (1ULL << (48 - 25)); 

  00253	48 0f ba e1 0f	 bt	 rcx, 15
  00258	73 05		 jae	 SHORT $LN36@compressPe
  0025a	48 0f ba e8 17	 bts	 rax, 23
$LN36@compressPe:

; 222  : 	if (key & (1ULL << 14)) permKey |= (1ULL << (48 - 44)); //42

  0025f	48 0f ba e1 0e	 bt	 rcx, 14
  00264	73 04		 jae	 SHORT $LN37@compressPe
  00266	48 83 c8 10	 or	 rax, 16
$LN37@compressPe:

; 223  : 	//bit 43 skip
; 224  : 	if (key & (1ULL << 12)) permKey |= (1ULL << (48 - 37)); 

  0026a	48 0f ba e1 0c	 bt	 rcx, 12
  0026f	73 05		 jae	 SHORT $LN38@compressPe
  00271	48 0f ba e8 0b	 bts	 rax, 11
$LN38@compressPe:

; 225  : 	if (key & (1ULL << 11)) permKey |= (1ULL << (48 - 34)); 

  00276	48 0f ba e1 0b	 bt	 rcx, 11
  0027b	73 05		 jae	 SHORT $LN39@compressPe
  0027d	48 0f ba e8 0e	 bts	 rax, 14
$LN39@compressPe:

; 226  : 	if (key & (1ULL << 10)) permKey |= (1ULL << (48 - 43)); 

  00282	48 0f ba e1 0a	 bt	 rcx, 10
  00287	73 04		 jae	 SHORT $LN40@compressPe
  00289	48 83 c8 20	 or	 rax, 32			; 00000020H
$LN40@compressPe:

; 227  : 	if (key & (1ULL << 9))  permKey |= (1ULL << (48 - 29)); 

  0028d	48 0f ba e1 09	 bt	 rcx, 9
  00292	73 05		 jae	 SHORT $LN41@compressPe
  00294	48 0f ba e8 13	 bts	 rax, 19
$LN41@compressPe:

; 228  : 	if (key & (1ULL << 8))  permKey |= (1ULL << (48 - 36)); 

  00299	48 0f ba e1 08	 bt	 rcx, 8
  0029e	73 05		 jae	 SHORT $LN42@compressPe
  002a0	48 0f ba e8 0c	 bts	 rax, 12
$LN42@compressPe:

; 229  : 	if (key & (1ULL << 7))  permKey |= (1ULL << (48 - 38));	//49

  002a5	84 c9		 test	 cl, cl
  002a7	79 05		 jns	 SHORT $LN43@compressPe
  002a9	48 0f ba e8 0a	 bts	 rax, 10
$LN43@compressPe:

; 230  : 	if (key & (1ULL << 6))  permKey |= (1ULL << (48 - 45));  

  002ae	f6 c1 40	 test	 cl, 64			; 00000040H
  002b1	74 04		 je	 SHORT $LN44@compressPe
  002b3	48 83 c8 08	 or	 rax, 8
$LN44@compressPe:

; 231  : 	if (key & (1ULL << 5))  permKey |= (1ULL << (48 - 33)); 

  002b7	f6 c1 20	 test	 cl, 32			; 00000020H
  002ba	74 05		 je	 SHORT $LN45@compressPe
  002bc	48 0f ba e8 0f	 bts	 rax, 15
$LN45@compressPe:

; 232  : 	if (key & (1ULL << 4))  permKey |= (1ULL << (48 - 26)); 

  002c1	f6 c1 10	 test	 cl, 16
  002c4	74 05		 je	 SHORT $LN46@compressPe
  002c6	48 0f ba e8 16	 bts	 rax, 22
$LN46@compressPe:

; 233  : 	if (key & (1ULL << 3))  permKey |= (1ULL << (48 - 42)); 

  002cb	f6 c1 08	 test	 cl, 8
  002ce	74 04		 je	 SHORT $LN47@compressPe
  002d0	48 83 c8 40	 or	 rax, 64			; 00000040H
$LN47@compressPe:

; 234  : 	//bit 54 skip
; 235  : 	if (key & (1ULL << 1))  permKey |= (1ULL << (48 - 30)); 

  002d4	f6 c1 02	 test	 cl, 2
  002d7	74 05		 je	 SHORT $LN48@compressPe
  002d9	48 0f ba e8 12	 bts	 rax, 18
$LN48@compressPe:

; 236  : 	if (key & (1ULL << 0))  permKey |= (1ULL << (48 - 40)); //56

  002de	f6 c1 01	 test	 cl, 1
  002e1	74 05		 je	 SHORT $LN51@compressPe
  002e3	48 0f ba e8 08	 bts	 rax, 8
$LN51@compressPe:

; 237  : 
; 238  : 	return permKey;
; 239  : }

  002e8	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  002ed	48 8b 6c 24 10	 mov	 rbp, QWORD PTR [rsp+16]
  002f2	48 8b 74 24 18	 mov	 rsi, QWORD PTR [rsp+24]
  002f7	48 8b 7c 24 20	 mov	 rdi, QWORD PTR [rsp+32]
  002fc	c3		 ret	 0
?compressPermuteKey@@YA_K_K@Z ENDP			; compressPermuteKey
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\coschm\desktop\fall-2016\security\des\des\des\main.cpp
_TEXT	SEGMENT
key$ = 8
round$ = 16
?rotateBits@@YA_K_KH@Z PROC				; rotateBits

; 127  : 	uint32_t c, d = 0;
; 128  : 	d = (uint32_t)(key & 0x0FFFFFFF); //and the right half of the 56 input bits here

  00000	44 8b c1	 mov	 r8d, ecx

; 129  : 	c = (uint32_t)(key >> 28); //we want the left half of the 56 input bits here

  00003	48 c1 e9 1c	 shr	 rcx, 28
  00007	41 81 e0 ff ff
	ff 0f		 and	 r8d, 268435455		; 0fffffffH
  0000e	83 fa 10	 cmp	 edx, 16
  00011	77 43		 ja	 SHORT $LN10@rotateBits
  00013	b8 06 02 01 00	 mov	 eax, 66054		; 00010206H
  00018	0f a3 d0	 bt	 eax, edx
  0001b	73 39		 jae	 SHORT $LN10@rotateBits

; 130  : 
; 131  : 	uint8_t lowestC, lowestD = 0;
; 132  : 	//ROUNDS 1,2,9,16 rotate 1 bit
; 133  : 	if (round == 1 || round == 2 || round == 9 || round == 16)
; 134  : 	{
; 135  : 		lowestC = (c >> 27); //get the leftmost bit of the c value

  0001d	8b c1		 mov	 eax, ecx

; 136  : 		c = (c << 1); //shift the bits left 1 spot

  0001f	03 c9		 add	 ecx, ecx
  00021	c1 e8 1b	 shr	 eax, 27

; 137  : 		if (lowestC > 0)

  00024	84 c0		 test	 al, al
  00026	74 09		 je	 SHORT $LN5@rotateBits

; 138  : 		{
; 139  : 			c |= 0x1; //put a 1 in the rightmost spot
; 140  : 			c &= 0x0FFFFFFF; //this is to make sure the 29th bit is cleared

  00028	81 e1 fe ff ff
	0f		 and	 ecx, 268435454		; 0ffffffeH
  0002e	83 c9 01	 or	 ecx, 1
$LN5@rotateBits:

; 141  : 		}//else it already has a 0 in the lowest spot
; 142  : 
; 143  : 		lowestD = (d >> 27); //get the leftmost bit of the d value

  00031	41 8b c0	 mov	 eax, r8d

; 144  : 		d = (d << 1);

  00034	45 03 c0	 add	 r8d, r8d
  00037	c1 e8 1b	 shr	 eax, 27

; 145  : 		if (lowestD > 0)

  0003a	84 c0		 test	 al, al
  0003c	74 4a		 je	 SHORT $LN6@rotateBits

; 166  : 		}
; 167  : 	}
; 168  : 
; 169  : 	key = 0; //clear out everything in the key
; 170  : 	key |= ((uint64_t)c << 28) //put the new c back in the left 28bits

  0003e	41 81 e0 fe ff
	ff 0f		 and	 r8d, 268435454		; 0ffffffeH
  00045	8b c1		 mov	 eax, ecx
  00047	41 83 c8 01	 or	 r8d, 1
  0004b	48 c1 e0 1c	 shl	 rax, 28
  0004f	41 8b c8	 mov	 ecx, r8d
  00052	48 0b c1	 or	 rax, rcx

; 171  : 		| (uint64_t)d; //and the new d back in the right 28bits;
; 172  : 
; 173  : 	return key;
; 174  : }

  00055	c3		 ret	 0
$LN10@rotateBits:

; 146  : 		{
; 147  : 			d |= 0x1; //put a 1 in the rightmost spot
; 148  : 			d &= 0x0FFFFFFF; //this is to make sure the 29th bit is cleared
; 149  : 		}
; 150  : 	}
; 151  : 	else //ROUNDS 3,4,5,6,7,8,10,11,12,13,14,15 all rotate 2 bits
; 152  : 	{
; 153  : 		lowestC = (c >> 26); //get the 2 leftmost bits of the c value

  00056	8b c1		 mov	 eax, ecx

; 154  : 		c = (c << 2); //shift left 2 bits

  00058	c1 e1 02	 shl	 ecx, 2
  0005b	c1 e8 1a	 shr	 eax, 26

; 155  : 		if (lowestC > 0)

  0005e	84 c0		 test	 al, al
  00060	74 0b		 je	 SHORT $LN7@rotateBits

; 156  : 		{
; 157  : 			c |= lowestC; //slide the 2 bits over to complete the rotation

  00062	0f b6 c0	 movzx	 eax, al

; 158  : 			c &= 0x0FFFFFFF; //this is to make sure the 29th & 30th bits are cleared

  00065	0b c8		 or	 ecx, eax
  00067	81 e1 ff ff ff
	0f		 and	 ecx, 268435455		; 0fffffffH
$LN7@rotateBits:

; 159  : 		}
; 160  : 		lowestD = (d >> 26); //get the 2 leftmost bits of the d value

  0006d	41 8b c0	 mov	 eax, r8d

; 161  : 		d = (d << 2); //shift left 2 bits

  00070	41 c1 e0 02	 shl	 r8d, 2
  00074	c1 e8 1a	 shr	 eax, 26

; 162  : 		if (lowestD > 0)

  00077	84 c0		 test	 al, al
  00079	74 0d		 je	 SHORT $LN6@rotateBits

; 163  : 		{
; 164  : 			d |= lowestD; //slide the 2 bits over to complete the rotation

  0007b	0f b6 c0	 movzx	 eax, al

; 165  : 			d &= 0x0FFFFFFF; //this is to make sure the 29th & 30th bits are cleared

  0007e	44 0b c0	 or	 r8d, eax
  00081	41 81 e0 ff ff
	ff 0f		 and	 r8d, 268435455		; 0fffffffH
$LN6@rotateBits:

; 166  : 		}
; 167  : 	}
; 168  : 
; 169  : 	key = 0; //clear out everything in the key
; 170  : 	key |= ((uint64_t)c << 28) //put the new c back in the left 28bits

  00088	8b c1		 mov	 eax, ecx
  0008a	48 c1 e0 1c	 shl	 rax, 28
  0008e	41 8b c8	 mov	 ecx, r8d
  00091	48 0b c1	 or	 rax, rcx

; 171  : 		| (uint64_t)d; //and the new d back in the right 28bits;
; 172  : 
; 173  : 	return key;
; 174  : }

  00094	c3		 ret	 0
?rotateBits@@YA_K_KH@Z ENDP				; rotateBits
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\coschm\desktop\fall-2016\security\des\des\des\main.cpp
_TEXT	SEGMENT
value$ = 8
output$ = 16
?convertToChar@@YAX_KQEAD@Z PROC			; convertToChar

; 115  : 	output[0] = ((char)(value >> 56));

  00000	48 8b c1	 mov	 rax, rcx

; 116  : 	output[1] = ((char)(value >> 48));
; 117  : 	output[2] = ((char)(value >> 40));
; 118  : 	output[3] = ((char)(value >> 32));
; 119  : 	output[4] = ((char)(value >> 24));
; 120  : 	output[5] = ((char)(value >> 16));
; 121  : 	output[6] = ((char)(value >> 8));
; 122  : 	output[7] = ((char)(value));

  00003	88 4a 07	 mov	 BYTE PTR [rdx+7], cl
  00006	48 c1 e8 38	 shr	 rax, 56			; 00000038H
  0000a	88 02		 mov	 BYTE PTR [rdx], al
  0000c	48 8b c1	 mov	 rax, rcx
  0000f	48 c1 e8 30	 shr	 rax, 48			; 00000030H
  00013	88 42 01	 mov	 BYTE PTR [rdx+1], al
  00016	48 8b c1	 mov	 rax, rcx
  00019	48 c1 e8 28	 shr	 rax, 40			; 00000028H
  0001d	88 42 02	 mov	 BYTE PTR [rdx+2], al
  00020	48 8b c1	 mov	 rax, rcx
  00023	48 c1 e8 20	 shr	 rax, 32			; 00000020H
  00027	88 42 03	 mov	 BYTE PTR [rdx+3], al
  0002a	48 8b c1	 mov	 rax, rcx
  0002d	48 c1 e8 18	 shr	 rax, 24
  00031	88 42 04	 mov	 BYTE PTR [rdx+4], al
  00034	48 8b c1	 mov	 rax, rcx
  00037	48 c1 e8 10	 shr	 rax, 16
  0003b	88 42 05	 mov	 BYTE PTR [rdx+5], al
  0003e	48 8b c1	 mov	 rax, rcx
  00041	48 c1 e8 08	 shr	 rax, 8
  00045	88 42 06	 mov	 BYTE PTR [rdx+6], al

; 123  : }

  00048	c3		 ret	 0
?convertToChar@@YAX_KQEAD@Z ENDP			; convertToChar
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\coschm\desktop\fall-2016\security\des\des\des\main.cpp
_TEXT	SEGMENT
argc$ = 48
argv$ = 56
?init@@YAXHQEAPEAD@Z PROC				; init

; 87   : {

$LN27:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00004	4c 8b c2	 mov	 r8, rdx

; 88   : 	if (argc != 6)

  00007	83 f9 06	 cmp	 ecx, 6
  0000a	0f 85 04 01 00
	00		 jne	 $LN22@init

; 91   : 	}
; 92   : 
; 93   : 	if (!(strcmp(argv[1],"-d") == 0 || strcmp(argv[1], "-D") == 0 || strcmp(argv[1], "-e") == 0 || strcmp(argv[1], "-E") == 0)) //action check

  00010	48 8b 4a 08	 mov	 rcx, QWORD PTR [rdx+8]
  00014	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00017	3a 05 00 00 00
	00		 cmp	 al, BYTE PTR ??_C@_02DBLKFNPN@?9d?$AA@
  0001d	75 18		 jne	 SHORT $LN20@init
  0001f	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  00023	3a 05 01 00 00
	00		 cmp	 al, BYTE PTR ??_C@_02DBLKFNPN@?9d?$AA@+1
  00029	75 0c		 jne	 SHORT $LN20@init
  0002b	0f b6 41 02	 movzx	 eax, BYTE PTR [rcx+2]
  0002f	3a 05 02 00 00
	00		 cmp	 al, BYTE PTR ??_C@_02DBLKFNPN@?9d?$AA@+2
  00035	74 75		 je	 SHORT $LN3@init
$LN20@init:
  00037	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  0003a	3a 05 00 00 00
	00		 cmp	 al, BYTE PTR ??_C@_02KEDOHJFP@?9D?$AA@
  00040	75 18		 jne	 SHORT $LN19@init
  00042	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  00046	3a 05 01 00 00
	00		 cmp	 al, BYTE PTR ??_C@_02KEDOHJFP@?9D?$AA@+1
  0004c	75 0c		 jne	 SHORT $LN19@init
  0004e	0f b6 41 02	 movzx	 eax, BYTE PTR [rcx+2]
  00052	3a 05 02 00 00
	00		 cmp	 al, BYTE PTR ??_C@_02KEDOHJFP@?9D?$AA@+2
  00058	74 52		 je	 SHORT $LN3@init
$LN19@init:
  0005a	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  0005d	3a 05 00 00 00
	00		 cmp	 al, BYTE PTR ??_C@_02CIKBGMLM@?9e?$AA@
  00063	75 18		 jne	 SHORT $LN18@init
  00065	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  00069	3a 05 01 00 00
	00		 cmp	 al, BYTE PTR ??_C@_02CIKBGMLM@?9e?$AA@+1
  0006f	75 0c		 jne	 SHORT $LN18@init
  00071	0f b6 41 02	 movzx	 eax, BYTE PTR [rcx+2]
  00075	3a 05 02 00 00
	00		 cmp	 al, BYTE PTR ??_C@_02CIKBGMLM@?9e?$AA@+2
  0007b	74 2f		 je	 SHORT $LN3@init
$LN18@init:
  0007d	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  00080	3a 05 00 00 00
	00		 cmp	 al, BYTE PTR ??_C@_02LNCFEIBO@?9E?$AA@
  00086	0f 85 bc 00 00
	00		 jne	 $LN17@init
  0008c	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  00090	3a 05 01 00 00
	00		 cmp	 al, BYTE PTR ??_C@_02LNCFEIBO@?9E?$AA@+1
  00096	0f 85 ac 00 00
	00		 jne	 $LN17@init
  0009c	0f b6 41 02	 movzx	 eax, BYTE PTR [rcx+2]
  000a0	3a 05 02 00 00
	00		 cmp	 al, BYTE PTR ??_C@_02LNCFEIBO@?9E?$AA@+2
  000a6	0f 85 9c 00 00
	00		 jne	 $LN17@init
$LN3@init:

; 96   : 	}
; 97   : 
; 98   : 	if (!(strlen(argv[2]) == 10 || strlen(argv[2]) == 16)) //key check

  000ac	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  000b0	48 83 c8 ff	 or	 rax, -1
  000b4	48 8b c8	 mov	 rcx, rax
$LL16@init:
  000b7	48 ff c1	 inc	 rcx
  000ba	80 3c 0a 00	 cmp	 BYTE PTR [rdx+rcx], 0
  000be	75 f7		 jne	 SHORT $LL16@init
  000c0	48 83 f9 0a	 cmp	 rcx, 10
  000c4	74 19		 je	 SHORT $LN4@init
  000c6	48 8b c8	 mov	 rcx, rax
  000c9	0f 1f 80 00 00
	00 00		 npad	 7
$LL15@init:
  000d0	48 ff c1	 inc	 rcx
  000d3	80 3c 0a 00	 cmp	 BYTE PTR [rdx+rcx], 0
  000d7	75 f7		 jne	 SHORT $LL15@init
  000d9	48 83 f9 10	 cmp	 rcx, 16
  000dd	75 42		 jne	 SHORT $LN24@init
$LN4@init:

; 101  : 	}
; 102  : 
; 103  : 	if (strlen(argv[3]) != 3) errorWithMessage("Incorrect Mode"); //needs to be 3 bytes long

  000df	49 8b 48 18	 mov	 rcx, QWORD PTR [r8+24]
$LL14@init:
  000e3	48 ff c0	 inc	 rax
  000e6	80 3c 01 00	 cmp	 BYTE PTR [rcx+rax], 0
  000ea	75 f7		 jne	 SHORT $LL14@init
  000ec	48 83 f8 03	 cmp	 rax, 3
  000f0	75 3c		 jne	 SHORT $LN25@init
  000f2	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  000f5	2c 45		 sub	 al, 69			; 00000045H
  000f7	a8 df		 test	 al, 223			; 000000dfH
  000f9	75 40		 jne	 SHORT $LN26@init
  000fb	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]
  000ff	2c 43		 sub	 al, 67			; 00000043H
  00101	a8 df		 test	 al, 223			; 000000dfH
  00103	75 36		 jne	 SHORT $LN26@init
  00105	0f b6 41 02	 movzx	 eax, BYTE PTR [rcx+2]
  00109	2c 42		 sub	 al, 66			; 00000042H
  0010b	a8 df		 test	 al, 223			; 000000dfH
  0010d	75 2c		 jne	 SHORT $LN26@init
$LN6@init:

; 110  : 	}
; 111  : }

  0010f	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00113	c3		 ret	 0
$LN22@init:

; 89   : 	{
; 90   : 		errorWithMessage("Incorrect number of arguments.");

  00114	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BP@IOHJEBAL@Incorrect?5number?5of?5arguments?4?$AA@
  0011b	e8 00 00 00 00	 call	 ?errorWithMessage@@YAXPEAD@Z ; errorWithMessage
  00120	cc		 int	 3
$LN24@init:

; 99   : 	{
; 100  : 		errorWithMessage("Bad key.");

  00121	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_08DPLLBGKL@Bad?5key?4?$AA@
  00128	e8 00 00 00 00	 call	 ?errorWithMessage@@YAXPEAD@Z ; errorWithMessage
  0012d	cc		 int	 3
$LN25@init:

; 101  : 	}
; 102  : 
; 103  : 	if (strlen(argv[3]) != 3) errorWithMessage("Incorrect Mode"); //needs to be 3 bytes long

  0012e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@KNIHKEND@Incorrect?5Mode?$AA@
  00135	e8 00 00 00 00	 call	 ?errorWithMessage@@YAXPEAD@Z ; errorWithMessage
  0013a	cc		 int	 3
$LN26@init:

; 104  : 
; 105  : 	if (!(((argv[3][0] == 'e') || (argv[3][0] == 'E')) &&
; 106  : 		  ((argv[3][1] == 'c') || (argv[3][1] == 'C')) &&
; 107  : 		  ((argv[3][2] == 'b') || (argv[3][2] == 'B')))) //mode check
; 108  : 	{
; 109  : 		errorWithMessage("Incorrect Mode");

  0013b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0P@KNIHKEND@Incorrect?5Mode?$AA@
  00142	e8 00 00 00 00	 call	 ?errorWithMessage@@YAXPEAD@Z ; errorWithMessage
  00147	cc		 int	 3
$LN17@init:

; 94   : 	{
; 95   : 		errorWithMessage("Incorrect action.");

  00148	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BC@LDCMBOAO@Incorrect?5action?4?$AA@
  0014f	e8 00 00 00 00	 call	 ?errorWithMessage@@YAXPEAD@Z ; errorWithMessage
  00154	cc		 int	 3
$LN21@init:
?init@@YAXHQEAPEAD@Z ENDP				; init
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Ostr$ = 48
??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z PROC ; std::endl<char,std::char_traits<char> >, COMDAT

; 991  : 	{	// insert newline and flush stream

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 992  : 	_Ostr.put(_Ostr.widen('\n'));

  00006	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00009	48 8b d9	 mov	 rbx, rcx
  0000c	b2 0a		 mov	 dl, 10
  0000e	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00012	48 03 cb	 add	 rcx, rbx
  00015	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADD@Z
  0001b	0f b6 d0	 movzx	 edx, al
  0001e	48 8b cb	 mov	 rcx, rbx
  00021	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@D@Z

; 993  : 	_Ostr.flush();

  00027	48 8b cb	 mov	 rcx, rbx
  0002a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ

; 994  : 	return (_Ostr);

  00030	48 8b c3	 mov	 rax, rbx

; 995  : 	}

  00033	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00037	5b		 pop	 rbx
  00038	c3		 ret	 0
??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ENDP ; std::endl<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
_TEXT	SEGMENT
$T1 = 32
_Ok$ = 40
_Ostr$ = 112
_State$ = 120
_Val$ = 120
??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z PROC ; std::operator<<<std::char_traits<char> >, COMDAT

; 780  : 	{	// insert NTBS into char stream

$LN113:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	41 54		 push	 r12
  00009	41 56		 push	 r14
  0000b	41 57		 push	 r15
  0000d	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00011	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  0001a	48 89 9c 24 80
	00 00 00	 mov	 QWORD PTR [rsp+128], rbx
  00022	4c 8b fa	 mov	 r15, rdx
  00025	48 8b f1	 mov	 rsi, rcx

; 781  : 	typedef char _Elem;
; 782  : 	typedef basic_ostream<_Elem, _Traits> _Myos;
; 783  : 	ios_base::iostate _State = ios_base::goodbit;

  00028	33 db		 xor	 ebx, ebx
  0002a	89 5c 24 78	 mov	 DWORD PTR _State$[rsp], ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

  0002e	38 1a		 cmp	 BYTE PTR [rdx], bl
  00030	75 05		 jne	 SHORT $LN26@operator
  00032	45 33 f6	 xor	 r14d, r14d
  00035	eb 12		 jmp	 SHORT $LN27@operator
$LN26@operator:
  00037	49 83 ce ff	 or	 r14, -1
  0003b	0f 1f 44 00 00	 npad	 5
$LL108@operator:
  00040	49 ff c6	 inc	 r14
  00043	42 38 1c 32	 cmp	 BYTE PTR [rdx+r14], bl
  00047	75 f7		 jne	 SHORT $LL108@operator
$LN27@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 785  : 	streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count

  00049	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  0004c	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 423  : 		return (_Wide);

  00050	48 8b 7c 31 28	 mov	 rdi, QWORD PTR [rcx+rsi+40]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 785  : 	streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count

  00055	48 85 ff	 test	 rdi, rdi
  00058	7e 0a		 jle	 SHORT $LN17@operator
  0005a	49 3b fe	 cmp	 rdi, r14
  0005d	7e 05		 jle	 SHORT $LN17@operator
  0005f	49 2b fe	 sub	 rdi, r14
  00062	eb 02		 jmp	 SHORT $LN18@operator
$LN17@operator:
  00064	33 ff		 xor	 edi, edi
$LN18@operator:

; 99   : 			: _Myostr(_Ostr)

  00066	4c 8b e6	 mov	 r12, rsi
  00069	48 89 74 24 28	 mov	 QWORD PTR _Ok$[rsp], rsi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 92   : 		return (_Mystrbuf);

  0006e	48 8b 4c 31 48	 mov	 rcx, QWORD PTR [rcx+rsi+72]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 101  : 			if (_Myostr.rdbuf() != 0)

  00073	48 85 c9	 test	 rcx, rcx
  00076	74 07		 je	 SHORT $LN39@operator

; 102  : 				_Myostr.rdbuf()->_Lock();

  00078	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  0007b	ff 50 08	 call	 QWORD PTR [rax+8]
  0007e	90		 npad	 1
$LN39@operator:

; 124  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

  0007f	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  00082	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 339  : 		return (rdstate() == goodbit);

  00086	83 7c 31 10 00	 cmp	 DWORD PTR [rcx+rsi+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 124  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

  0008b	75 15		 jne	 SHORT $LN35@operator
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 80   : 		return (_Tiestr);

  0008d	48 8b 4c 31 50	 mov	 rcx, QWORD PTR [rcx+rsi+80]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 124  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

  00092	48 85 c9	 test	 rcx, rcx
  00095	74 0b		 je	 SHORT $LN35@operator
  00097	48 3b ce	 cmp	 rcx, rsi
  0009a	74 06		 je	 SHORT $LN35@operator

; 125  : 				_Ostr.tie()->flush();

  0009c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ
$LN35@operator:

; 126  : 			_Ok = _Ostr.good();	// store test only after flushing tie

  000a2	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  000a5	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 339  : 		return (rdstate() == goodbit);

  000a9	83 7c 31 10 00	 cmp	 DWORD PTR [rcx+rsi+16], 0
  000ae	0f 94 c0	 sete	 al
  000b1	88 44 24 30	 mov	 BYTE PTR _Ok$[rsp+8], al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 789  : 	if (!_Ok)

  000b5	84 c0		 test	 al, al
  000b7	75 0a		 jne	 SHORT $LN8@operator

; 790  : 		_State |= ios_base::badbit;

  000b9	bb 04 00 00 00	 mov	 ebx, 4

; 791  : 	else

  000be	e9 b4 00 00 00	 jmp	 $LN22@operator
$LN8@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 378  : 		return (_Fmtfl);

  000c3	8b 44 31 18	 mov	 eax, DWORD PTR [rcx+rsi+24]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 794  : 		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)

  000c7	25 c0 01 00 00	 and	 eax, 448		; 000001c0H
  000cc	83 f8 40	 cmp	 eax, 64			; 00000040H
  000cf	74 33		 je	 SHORT $LN105@operator
$LL4@operator:

; 795  : 			for (; 0 < _Pad; --_Pad)	// pad on left

  000d1	48 85 ff	 test	 rdi, rdi
  000d4	7e 2a		 jle	 SHORT $LN3@operator

; 796  : 				if (_Traits::eq_int_type(_Traits::eof(),

  000d6	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  000d9	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  000dd	0f b6 54 31 58	 movzx	 edx, BYTE PTR [rcx+rsi+88]
  000e2	48 8b 4c 31 48	 mov	 rcx, QWORD PTR [rcx+rsi+72]
  000e7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 595  : 		return (_Left == _Right);

  000ed	83 f8 ff	 cmp	 eax, -1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 796  : 				if (_Traits::eq_int_type(_Traits::eof(),

  000f0	75 09		 jne	 SHORT $LN2@operator

; 797  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))
; 798  : 					{	// insertion failed, quit
; 799  : 					_State |= ios_base::badbit;

  000f2	83 cb 04	 or	 ebx, 4
  000f5	89 5c 24 78	 mov	 DWORD PTR _State$[rsp], ebx

; 800  : 					break;

  000f9	eb 05		 jmp	 SHORT $LN3@operator
$LN2@operator:

; 795  : 			for (; 0 < _Pad; --_Pad)	// pad on left

  000fb	48 ff cf	 dec	 rdi
  000fe	eb d1		 jmp	 SHORT $LL4@operator
$LN3@operator:

; 801  : 					}
; 802  : 
; 803  : 		if (_State == ios_base::goodbit
; 804  : 			&& _Ostr.rdbuf()->sputn(_Val, _Count) != _Count)

  00100	85 db		 test	 ebx, ebx
  00102	75 53		 jne	 SHORT $LN6@operator
$LN105@operator:
  00104	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  00107	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  0010b	4d 8b c6	 mov	 r8, r14
  0010e	49 8b d7	 mov	 rdx, r15
  00111	48 8b 4c 31 48	 mov	 rcx, QWORD PTR [rcx+rsi+72]
  00116	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAA_JPEBD_J@Z
  0011c	49 3b c6	 cmp	 rax, r14
  0011f	74 07		 je	 SHORT $LL109@operator

; 805  : 			_State |= ios_base::badbit;

  00121	bb 04 00 00 00	 mov	 ebx, 4

; 806  : 
; 807  : 		if (_State == ios_base::goodbit)

  00126	eb 2b		 jmp	 SHORT $LN111@operator
$LL109@operator:

; 808  : 			for (; 0 < _Pad; --_Pad)	// pad on right

  00128	48 85 ff	 test	 rdi, rdi
  0012b	7e 2a		 jle	 SHORT $LN6@operator

; 809  : 				if (_Traits::eq_int_type(_Traits::eof(),

  0012d	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  00130	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00134	0f b6 54 31 58	 movzx	 edx, BYTE PTR [rcx+rsi+88]
  00139	48 8b 4c 31 48	 mov	 rcx, QWORD PTR [rcx+rsi+72]
  0013e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 595  : 		return (_Left == _Right);

  00144	83 f8 ff	 cmp	 eax, -1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 809  : 				if (_Traits::eq_int_type(_Traits::eof(),

  00147	75 05		 jne	 SHORT $LN5@operator

; 810  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))
; 811  : 					{	// insertion failed, quit
; 812  : 					_State |= ios_base::badbit;

  00149	83 cb 04	 or	 ebx, 4

; 813  : 					break;

  0014c	eb 05		 jmp	 SHORT $LN111@operator
$LN5@operator:

; 808  : 			for (; 0 < _Pad; --_Pad)	// pad on right

  0014e	48 ff cf	 dec	 rdi
  00151	eb d5		 jmp	 SHORT $LL109@operator
$LN111@operator:

; 805  : 			_State |= ios_base::badbit;

  00153	89 5c 24 78	 mov	 DWORD PTR _State$[rsp], ebx
$LN6@operator:

; 814  : 					}
; 815  : 		_Ostr.width(0);

  00157	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  0015a	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 429  : 		_Wide = _Newwidth;

  0015e	48 c7 44 31 28
	00 00 00 00	 mov	 QWORD PTR [rcx+rsi+40], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
  00167	eb 0e		 jmp	 SHORT $LN22@operator
$LN23@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
  00169	48 8b 74 24 70	 mov	 rsi, QWORD PTR _Ostr$[rsp]
  0016e	8b 5c 24 78	 mov	 ebx, DWORD PTR _State$[rsp]
  00172	4c 8b 64 24 28	 mov	 r12, QWORD PTR _Ok$[rsp]
$LN22@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 819  : 	_Ostr.setstate(_State);

  00177	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  0017a	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  0017e	48 03 ce	 add	 rcx, rsi
  00181	45 33 c0	 xor	 r8d, r8d
  00184	8b d3		 mov	 edx, ebx
  00186	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
  0018c	90		 npad	 1

; 132  : 			if (!_XSTD uncaught_exception())

  0018d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?uncaught_exception@std@@YA_NXZ
  00193	84 c0		 test	 al, al
  00195	75 0a		 jne	 SHORT $LN88@operator

; 133  : 				this->_Myostr._Osfx();

  00197	49 8b cc	 mov	 rcx, r12
  0019a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ
  001a0	90		 npad	 1
$LN88@operator:

; 107  : 			if (_Myostr.rdbuf() != 0)

  001a1	49 8b 04 24	 mov	 rax, QWORD PTR [r12]
  001a5	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 92   : 		return (_Mystrbuf);

  001a9	4a 8b 4c 21 48	 mov	 rcx, QWORD PTR [rcx+r12+72]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 107  : 			if (_Myostr.rdbuf() != 0)

  001ae	48 85 c9	 test	 rcx, rcx
  001b1	74 07		 je	 SHORT $LN92@operator

; 108  : 				_Myostr.rdbuf()->_Unlock();

  001b3	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  001b6	ff 50 10	 call	 QWORD PTR [rax+16]
  001b9	90		 npad	 1
$LN92@operator:

; 820  : 	return (_Ostr);

  001ba	48 8b c6	 mov	 rax, rsi

; 821  : 	}

  001bd	48 8b 9c 24 80
	00 00 00	 mov	 rbx, QWORD PTR [rsp+128]
  001c5	48 83 c4 40	 add	 rsp, 64			; 00000040H
  001c9	41 5f		 pop	 r15
  001cb	41 5e		 pop	 r14
  001cd	41 5c		 pop	 r12
  001cf	5f		 pop	 rdi
  001d0	5e		 pop	 rsi
  001d1	c3		 ret	 0
??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ENDP ; std::operator<<<std::char_traits<char> >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_Ok$ = 40
_Ostr$ = 112
_State$ = 120
_Val$ = 120
?dtor$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$1
  00000	48 8d 8a 28 00
	00 00		 lea	 rcx, QWORD PTR _Ok$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
?dtor$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$1
$T1 = 32
_Ok$ = 40
_Ostr$ = 112
_State$ = 120
_Val$ = 120
?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$0
  0000c	48 8d 8a 28 00
	00 00		 lea	 rcx, QWORD PTR _Ok$[rdx]
  00013	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$0
$T1 = 32
_Ok$ = 40
_Ostr$ = 112
_State$ = 120
_Val$ = 120
?catch$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::catch$0

; 816  : 		_CATCH_IO_(_Ostr)

  00018	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0001d	55		 push	 rbp
  0001e	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00022	48 8b ea	 mov	 rbp, rdx
__catch$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z$0:
  00025	48 8b 55 70	 mov	 rdx, QWORD PTR _Ostr$[rbp]
  00029	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  0002c	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00030	48 03 ca	 add	 rcx, rdx
  00033	41 b0 01	 mov	 r8b, 1
  00036	ba 04 00 00 00	 mov	 edx, 4
  0003b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
  00041	90		 npad	 1
  00042	48 8d 05 00 00
	00 00		 lea	 rax, $LN23@catch$0
  00049	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004d	5d		 pop	 rbp
  0004e	c3		 ret	 0
  0004f	cc		 int	 3
?catch$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::catch$0
$T1 = 32
_Ok$ = 40
_Ostr$ = 112
_State$ = 120
_Val$ = 120
?dtor$6@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$6
  00050	e9 00 00 00 00	 jmp	 __std_terminate
?dtor$6@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$6
$T1 = 32
_Ok$ = 40
_Ostr$ = 112
_State$ = 120
_Val$ = 120
?dtor$7@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$7
  00055	e9 00 00 00 00	 jmp	 __std_terminate
?dtor$7@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$7
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_Ok$ = 40
_Ostr$ = 112
_State$ = 120
_Val$ = 120
?dtor$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$1
  00000	48 8d 8a 28 00
	00 00		 lea	 rcx, QWORD PTR _Ok$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
?dtor$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_Ok$ = 40
_Ostr$ = 112
_State$ = 120
_Val$ = 120
?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$0
  0000c	48 8d 8a 28 00
	00 00		 lea	 rcx, QWORD PTR _Ok$[rdx]
  00013	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_Ok$ = 40
_Ostr$ = 112
_State$ = 120
_Val$ = 120
?catch$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::catch$0

; 816  : 		_CATCH_IO_(_Ostr)

  00018	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0001d	55		 push	 rbp
  0001e	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00022	48 8b ea	 mov	 rbp, rdx
__catch$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z$0:
  00025	48 8b 55 70	 mov	 rdx, QWORD PTR _Ostr$[rbp]
  00029	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  0002c	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00030	48 03 ca	 add	 rcx, rdx
  00033	41 b0 01	 mov	 r8b, 1
  00036	ba 04 00 00 00	 mov	 edx, 4
  0003b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
  00041	90		 npad	 1
  00042	48 8d 05 00 00
	00 00		 lea	 rax, $LN23@catch$0
  00049	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004d	5d		 pop	 rbp
  0004e	c3		 ret	 0
  0004f	cc		 int	 3
?catch$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_Ok$ = 40
_Ostr$ = 112
_State$ = 120
_Val$ = 120
?dtor$6@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$6
  00050	e9 00 00 00 00	 jmp	 __std_terminate
?dtor$6@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
_Ok$ = 40
_Ostr$ = 112
_State$ = 120
_Val$ = 120
?dtor$7@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$7
  00055	e9 00 00 00 00	 jmp	 __std_terminate
?dtor$7@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$7
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\users\coschm\desktop\fall-2016\security\des\des\des\main.cpp
_TEXT	SEGMENT
err$ = 48
?errorWithMessage@@YAXPEAD@Z PROC			; errorWithMessage

; 80   : {

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 81   : 	cout << "ERROR. " << err << endl;

  00009	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07BCFMPKIE@ERROR?4?5?$AA@
  00010	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00017	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  0001c	48 8b c8	 mov	 rcx, rax
  0001f	48 8b d3	 mov	 rdx, rbx
  00022	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00027	48 8b c8	 mov	 rcx, rax
  0002a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 82   : 	Sleep(2000);

  00037	b9 d0 07 00 00	 mov	 ecx, 2000		; 000007d0H
  0003c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_Sleep

; 83   : 	exit(0);

  00042	33 c9		 xor	 ecx, ecx
  00044	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_exit
  0004a	cc		 int	 3
$LN3@errorWithM:
?errorWithMessage@@YAXPEAD@Z ENDP			; errorWithMessage
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\time.h
;	COMDAT time
_TEXT	SEGMENT
_Time$ = 8
time	PROC						; COMDAT

; 535  :             return _time64(_Time);

  00000	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp__time64
time	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
;	COMDAT ??$_Ungetc@D@std@@YA_NAEBDPEAU_iobuf@@@Z
_TEXT	SEGMENT
_Byte$ = 48
_File$ = 56
??$_Ungetc@D@std@@YA_NAEBDPEAU_iobuf@@@Z PROC		; std::_Ungetc<char>, COMDAT

; 106  : 	{	// put back a char element to a C stream

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 107  : 	return (ungetc((unsigned char)_Byte, _File) != EOF);

  00004	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00007	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ungetc
  0000d	83 f8 ff	 cmp	 eax, -1
  00010	0f 95 c0	 setne	 al

; 108  : 	}

  00013	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00017	c3		 ret	 0
??$_Ungetc@D@std@@YA_NAEBDPEAU_iobuf@@@Z ENDP		; std::_Ungetc<char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
;	COMDAT ??$_Fputc@D@std@@YA_NDPEAU_iobuf@@@Z
_TEXT	SEGMENT
_Byte$ = 48
_File$ = 56
??$_Fputc@D@std@@YA_NDPEAU_iobuf@@@Z PROC		; std::_Fputc<char>, COMDAT

; 82   : 	{	// put a char element to a C stream

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 83   : 	return (fputc(_Byte, _File) != EOF);

  00004	0f be c9	 movsx	 ecx, cl
  00007	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fputc
  0000d	83 f8 ff	 cmp	 eax, -1
  00010	0f 95 c0	 setne	 al

; 84   : 	}

  00013	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00017	c3		 ret	 0
??$_Fputc@D@std@@YA_NDPEAU_iobuf@@@Z ENDP		; std::_Fputc<char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\fstream
;	COMDAT ??$_Fgetc@D@std@@YA_NAEADPEAU_iobuf@@@Z
_TEXT	SEGMENT
_Byte$ = 48
_File$ = 56
??$_Fgetc@D@std@@YA_NAEADPEAU_iobuf@@@Z PROC		; std::_Fgetc<char>, COMDAT

; 37   : 	{	// get a char element from a C stream

$LN6:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 38   : 	int _Meta;
; 39   : 	if ((_Meta = fgetc(_File)) == EOF)

  00009	48 8b ca	 mov	 rcx, rdx
  0000c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fgetc
  00012	83 f8 ff	 cmp	 eax, -1
  00015	75 08		 jne	 SHORT $LN2@Fgetc

; 40   : 		return (false);

  00017	32 c0		 xor	 al, al

; 45   : 		}
; 46   : 	}

  00019	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001d	5b		 pop	 rbx
  0001e	c3		 ret	 0
$LN2@Fgetc:

; 41   : 	else
; 42   : 		{	// got one, convert to char
; 43   : 		_Byte = (char)_Meta;

  0001f	88 03		 mov	 BYTE PTR [rbx], al

; 44   : 		return (true);

  00021	b0 01		 mov	 al, 1

; 45   : 		}
; 46   : 	}

  00023	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00027	5b		 pop	 rbx
  00028	c3		 ret	 0
??$_Fgetc@D@std@@YA_NAEADPEAU_iobuf@@@Z ENDP		; std::_Fgetc<char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ?_Getfacet@locale@std@@QEBAPEBVfacet@12@_K@Z
_TEXT	SEGMENT
this$ = 48
_Id$ = 56
?_Getfacet@locale@std@@QEBAPEBVfacet@12@_K@Z PROC	; std::locale::_Getfacet, COMDAT

; 458  : 		{	// look up a facet in locale object

$LN12:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b da	 mov	 rbx, rdx

; 459  : 		const facet *_Facptr = _Id < _Ptr->_Facetcount

  0000d	33 ff		 xor	 edi, edi
  0000f	48 8b 51 08	 mov	 rdx, QWORD PTR [rcx+8]
  00013	48 3b 5a 18	 cmp	 rbx, QWORD PTR [rdx+24]
  00017	73 0f		 jae	 SHORT $LN6@Getfacet
  00019	48 8b 42 10	 mov	 rax, QWORD PTR [rdx+16]
  0001d	48 8b 04 d8	 mov	 rax, QWORD PTR [rax+rbx*8]

; 460  : 			? _Ptr->_Facetvec[_Id] : 0;	// null if id off end
; 461  : 		if (_Facptr != 0 || !_Ptr->_Xparent)

  00021	48 85 c0	 test	 rax, rax
  00024	75 22		 jne	 SHORT $LN4@Getfacet
  00026	eb 03		 jmp	 SHORT $LN10@Getfacet
$LN6@Getfacet:

; 459  : 		const facet *_Facptr = _Id < _Ptr->_Facetcount

  00028	48 8b c7	 mov	 rax, rdi
$LN10@Getfacet:

; 460  : 			? _Ptr->_Facetvec[_Id] : 0;	// null if id off end
; 461  : 		if (_Facptr != 0 || !_Ptr->_Xparent)

  0002b	40 38 7a 24	 cmp	 BYTE PTR [rdx+36], dil
  0002f	74 17		 je	 SHORT $LN4@Getfacet

; 462  : 			return (_Facptr);	// found facet or not transparent
; 463  : 		else
; 464  : 			{	// look in current locale
; 465  : 			locale::_Locimp *_Ptr0 = _Getgloballocale();

  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Getgloballocale@locale@std@@CAPEAV_Locimp@12@XZ

; 466  : 			return (_Id < _Ptr0->_Facetcount

  00037	48 3b 58 18	 cmp	 rbx, QWORD PTR [rax+24]
  0003b	73 08		 jae	 SHORT $LN8@Getfacet
  0003d	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00041	48 8b 3c d8	 mov	 rdi, QWORD PTR [rax+rbx*8]
$LN8@Getfacet:
  00045	48 8b c7	 mov	 rax, rdi
$LN4@Getfacet:

; 467  : 				? _Ptr0->_Facetvec[_Id]	// get from current locale
; 468  : 				: 0);	// no entry in current locale
; 469  : 			}
; 470  : 		}

  00048	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0004d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00051	5f		 pop	 rdi
  00052	c3		 ret	 0
?_Getfacet@locale@std@@QEBAPEBVfacet@12@_K@Z ENDP	; std::locale::_Getfacet
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xlocale
;	COMDAT ??1locale@std@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
??1locale@std@@QEAA@XZ PROC				; std::locale::~locale, COMDAT

; 430  : 		{	// destroy the object

$LN6:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00004	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2

; 431  : 		if (_Ptr != 0)

  0000d	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00011	48 85 c9	 test	 rcx, rcx
  00014	74 1e		 je	 SHORT $LN4@locale

; 432  : 			delete _Ptr->_Decref();

  00016	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00019	ff 50 10	 call	 QWORD PTR [rax+16]
  0001c	90		 npad	 1
  0001d	48 85 c0	 test	 rax, rax
  00020	74 12		 je	 SHORT $LN4@locale
  00022	4c 8b 00	 mov	 r8, QWORD PTR [rax]
  00025	ba 01 00 00 00	 mov	 edx, 1
  0002a	48 8b c8	 mov	 rcx, rax

; 433  : 		}

  0002d	48 83 c4 38	 add	 rsp, 56			; 00000038H

; 432  : 			delete _Ptr->_Decref();

  00031	49 ff 20	 rex_jmp QWORD PTR [r8]
$LN4@locale:

; 433  : 		}

  00034	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00038	c3		 ret	 0
??1locale@std@@QEAA@XZ ENDP				; std::locale::~locale
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_exception.h
;	COMDAT ??_Gbad_cast@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gbad_cast@std@@UEAAPEAXI@Z PROC			; std::bad_cast::`scalar deleting destructor', COMDAT
$LN11:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 83   :     {

  0000a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7exception@std@@6B@
  00011	48 8b f9	 mov	 rdi, rcx
  00014	48 89 01	 mov	 QWORD PTR [rcx], rax
  00017	8b da		 mov	 ebx, edx

; 84   :         __std_exception_destroy(&_Data);

  00019	48 83 c1 08	 add	 rcx, 8
  0001d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___std_exception_destroy
  00023	f6 c3 01	 test	 bl, 1
  00026	74 0d		 je	 SHORT $LN9@scalar
  00028	ba 18 00 00 00	 mov	 edx, 24
  0002d	48 8b cf	 mov	 rcx, rdi
  00030	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN9@scalar:
  00035	48 8b c7	 mov	 rax, rdi
  00038	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0003d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00041	5f		 pop	 rdi
  00042	c3		 ret	 0
??_Gbad_cast@std@@UEAAPEAXI@Z ENDP			; std::bad_cast::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_exception.h
;	COMDAT ??0bad_cast@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0bad_cast@std@@QEAA@AEBV01@@Z PROC			; std::bad_cast::bad_cast, COMDAT
$LN6:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx
  00009	48 8b c2	 mov	 rax, rdx

; 65   :         : _Data()

  0000c	48 8d 53 08	 lea	 rdx, QWORD PTR [rbx+8]

; 66   :     {

  00010	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_7exception@std@@6B@
  00017	48 89 0b	 mov	 QWORD PTR [rbx], rcx
  0001a	33 c9		 xor	 ecx, ecx
  0001c	48 89 0a	 mov	 QWORD PTR [rdx], rcx
  0001f	48 89 4a 08	 mov	 QWORD PTR [rdx+8], rcx

; 67   :         __std_exception_copy(&_Other._Data, &_Data);

  00023	48 8d 48 08	 lea	 rcx, QWORD PTR [rax+8]
  00027	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___std_exception_copy
  0002d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7bad_cast@std@@6B@
  00034	48 89 03	 mov	 QWORD PTR [rbx], rax
  00037	48 8b c3	 mov	 rax, rbx
  0003a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003e	5b		 pop	 rbx
  0003f	c3		 ret	 0
??0bad_cast@std@@QEAA@AEBV01@@Z ENDP			; std::bad_cast::bad_cast
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_exception.h
;	COMDAT ??1bad_cast@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1bad_cast@std@@UEAA@XZ PROC				; std::bad_cast::~bad_cast, COMDAT

; 83   :     {

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7exception@std@@6B@
  00007	48 89 01	 mov	 QWORD PTR [rcx], rax

; 84   :         __std_exception_destroy(&_Data);

  0000a	48 83 c1 08	 add	 rcx, 8
  0000e	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp___std_exception_destroy
??1bad_cast@std@@UEAA@XZ ENDP				; std::bad_cast::~bad_cast
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_typeinfo.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_exception.h
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_typeinfo.h
;	COMDAT ??0bad_cast@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0bad_cast@std@@QEAA@XZ PROC				; std::bad_cast::bad_cast, COMDAT
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_exception.h

; 59   :         : _Data()

  00000	33 c0		 xor	 eax, eax
  00002	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 60   :     {
; 61   :         _Data._What = _Message;

  00006	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_08EPJLHIJG@bad?5cast?$AA@
  0000d	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_typeinfo.h

; 125  :     {

  00011	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7bad_cast@std@@6B@
  00018	48 89 01	 mov	 QWORD PTR [rcx], rax

; 126  :     }

  0001b	48 8b c1	 mov	 rax, rcx
  0001e	c3		 ret	 0
??0bad_cast@std@@QEAA@XZ ENDP				; std::bad_cast::bad_cast
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAXXZ
_TEXT	SEGMENT
this$ = 48
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran, COMDAT

; 2277 : 		{	// report an out_of_range error

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2278 : 		_Xout_of_range("invalid string position");

  00004	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  0000b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Xout_of_range@std@@YAXPEBD@Z
  00011	cc		 int	 3
$LN3@Xran:
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Check_offset@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Off$ = 56
?_Check_offset@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAX_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Check_offset, COMDAT

; 2265 : 		{	// checks whether _Off is in the bounds of [0, this->size()]

$LN18:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2266 : 		if (this->_Mysize() < _Off)

  00004	48 39 51 18	 cmp	 QWORD PTR [rcx+24], rdx
  00008	73 0e		 jae	 SHORT $LN2@Check_offs

; 2278 : 		_Xout_of_range("invalid string position");

  0000a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  00011	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Xout_of_range@std@@YAXPEBD@Z
  00017	cc		 int	 3
$LN2@Check_offs:

; 2267 : 			_Xran();
; 2268 : 		}

  00018	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001c	c3		 ret	 0
$LN17@Check_offs:
?_Check_offset@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAX_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Check_offset
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAXXZ
_TEXT	SEGMENT
this$ = 48
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT

; 2260 : 		{	// report a length_error

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2261 : 		_Xlength_error("string too long");

  00004	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  0000b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
  00011	cc		 int	 3
$LN3@Xlen:
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_N_K@Z
_TEXT	SEGMENT
this$ = 48
_Built$ = 56
_Newsize$ = 64
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_N_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT

; 2243 : 		{	// initialize buffer, deallocating any storage

$LN120:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	49 8b f8	 mov	 rdi, r8
  0000d	48 8b d9	 mov	 rbx, rcx

; 2244 : 		if (!_Built)

  00010	84 d2		 test	 dl, dl
  00012	74 3a		 je	 SHORT $LN4@Tidy

; 2245 : 			;
; 2246 : 		else if (this->_BUF_SIZE <= this->_Myres())

  00014	48 83 79 20 10	 cmp	 QWORD PTR [rcx+32], 16
  00019	72 33		 jb	 SHORT $LN4@Tidy

; 2247 : 			{	// copy any leftovers to small buffer and deallocate
; 2248 : 			pointer _Ptr = this->_Bx()._Ptr;

  0001b	48 83 c1 08	 add	 rcx, 8
  0001f	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  00024	48 8b 31	 mov	 rsi, QWORD PTR [rcx]

; 2249 : 			this->_Getal().destroy(&this->_Bx()._Ptr);
; 2250 : 			if (0 < _Newsize)

  00027	4d 85 c0	 test	 r8, r8
  0002a	74 08		 je	 SHORT $LN58@Tidy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 530  : 		return (_Count == 0 ? _First1

  0002c	48 8b d6	 mov	 rdx, rsi
  0002f	e8 00 00 00 00	 call	 memcpy
$LN58@Tidy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2253 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

  00034	48 8b 53 20	 mov	 rdx, QWORD PTR [rbx+32]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 620  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00038	41 b8 01 00 00
	00		 mov	 r8d, 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2253 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

  0003e	48 ff c2	 inc	 rdx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 620  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00041	48 8b ce	 mov	 rcx, rsi
  00044	e8 00 00 00 00	 call	 ?_Deallocate@std@@YAXPEAX_K1@Z ; std::_Deallocate
  00049	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
$LN4@Tidy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2255 : 		this->_Myres() = this->_BUF_SIZE - 1;

  0004e	48 c7 43 20 0f
	00 00 00	 mov	 QWORD PTR [rbx+32], 15

; 2214 : 		_Traits::assign(this->_Myptr()[this->_Mysize() = _Newsize], _Elem());

  00056	48 89 7b 18	 mov	 QWORD PTR [rbx+24], rdi

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  0005a	48 83 7b 20 10	 cmp	 QWORD PTR [rbx+32], 16
  0005f	72 13		 jb	 SHORT $LN108@Tidy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 708  : 	return (reinterpret_cast<_Ty *>(

  00061	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  00065	c6 04 38 00	 mov	 BYTE PTR [rax+rdi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2257 : 		}

  00069	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0006e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00072	5f		 pop	 rdi
  00073	c3		 ret	 0
$LN108@Tidy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  00074	c6 44 3b 08 00	 mov	 BYTE PTR [rbx+rdi+8], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2257 : 		}

  00079	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0007e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00082	5f		 pop	 rdi
  00083	c3		 ret	 0
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_N_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA_N_K_N@Z
_TEXT	SEGMENT
this$ = 48
_Newsize$ = 56
_Trim$ = 64
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA_N_K_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT

; 2219 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

$LN104:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b da	 mov	 rbx, rdx

; 2220 : 		if (max_size() < _Newsize)

  00009	48 83 fa fe	 cmp	 rdx, -2
  0000d	76 0e		 jbe	 SHORT $LN2@Grow

; 2261 : 		_Xlength_error("string too long");

  0000f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00016	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
  0001c	cc		 int	 3
$LN2@Grow:
  0001d	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi

; 2221 : 			_Xlen();	// result too long
; 2222 : 		if (this->_Myres() < _Newsize)

  00022	33 ff		 xor	 edi, edi
  00024	48 39 51 20	 cmp	 QWORD PTR [rcx+32], rdx
  00028	73 1a		 jae	 SHORT $LN3@Grow

; 2223 : 			_Copy(_Newsize, this->_Mysize());	// reallocate to grow

  0002a	4c 8b 41 18	 mov	 r8, QWORD PTR [rcx+24]
  0002e	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
  00033	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 2229 : 		return (0 < _Newsize);	// return true only if more work to do

  00038	48 85 db	 test	 rbx, rbx
  0003b	0f 95 c0	 setne	 al

; 2230 : 		}

  0003e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00042	5b		 pop	 rbx
  00043	c3		 ret	 0
$LN3@Grow:

; 2224 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)

  00044	45 84 c0	 test	 r8b, r8b
  00047	74 29		 je	 SHORT $LN5@Grow
  00049	48 83 fa 10	 cmp	 rdx, 16
  0004d	73 23		 jae	 SHORT $LN5@Grow

; 2225 : 			_Tidy(true,	// copy and deallocate if trimming to small string

  0004f	4c 8b 41 18	 mov	 r8, QWORD PTR [rcx+24]
  00053	49 3b d0	 cmp	 rdx, r8
  00056	4c 0f 42 c2	 cmovb	 r8, rdx
  0005a	b2 01		 mov	 dl, 1
  0005c	e8 00 00 00 00	 call	 ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_N_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
  00061	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 2229 : 		return (0 < _Newsize);	// return true only if more work to do

  00066	48 85 db	 test	 rbx, rbx
  00069	0f 95 c0	 setne	 al

; 2230 : 		}

  0006c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00070	5b		 pop	 rbx
  00071	c3		 ret	 0
$LN5@Grow:

; 2226 : 				_Newsize < this->_Mysize() ? _Newsize : this->_Mysize());
; 2227 : 		else if (_Newsize == 0)

  00072	48 85 d2	 test	 rdx, rdx
  00075	75 18		 jne	 SHORT $LN100@Grow

; 2214 : 		_Traits::assign(this->_Myptr()[this->_Mysize() = _Newsize], _Elem());

  00077	48 89 79 18	 mov	 QWORD PTR [rcx+24], rdi

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  0007b	48 83 79 20 10	 cmp	 QWORD PTR [rcx+32], 16
  00080	72 06		 jb	 SHORT $LN91@Grow
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 708  : 	return (reinterpret_cast<_Ty *>(

  00082	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  00086	eb 04		 jmp	 SHORT $LN92@Grow
$LN91@Grow:
  00088	48 83 c1 08	 add	 rcx, 8
$LN92@Grow:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  0008c	40 88 39	 mov	 BYTE PTR [rcx], dil
$LN100@Grow:
  0008f	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2229 : 		return (0 < _Newsize);	// return true only if more work to do

  00094	48 85 db	 test	 rbx, rbx
  00097	0f 95 c0	 setne	 al

; 2230 : 		}

  0009a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0009e	5b		 pop	 rbx
  0009f	c3		 ret	 0
$LN103@Grow:
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA_N_K_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
_Newsize$ = 16
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT

; 2214 : 		_Traits::assign(this->_Myptr()[this->_Mysize() = _Newsize], _Elem());

  00000	48 89 51 18	 mov	 QWORD PTR [rcx+24], rdx

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  00004	48 83 79 20 10	 cmp	 QWORD PTR [rcx+32], 16
  00009	72 09		 jb	 SHORT $LN22@Eos
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 708  : 	return (reinterpret_cast<_Ty *>(

  0000b	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  0000f	c6 04 10 00	 mov	 BYTE PTR [rax+rdx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2215 : 		}

  00013	c3		 ret	 0
$LN22@Eos:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  00014	c6 44 11 08 00	 mov	 BYTE PTR [rcx+rdx+8], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2215 : 		}

  00019	c3		 ret	 0
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 96
_Newres$ = 104
_Newsize$ = 104
_Oldlen$ = 112
_Ptr$ = 120
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT

; 2178 : 		{	// copy _Oldlen elements to newly allocated buffer

$LN480:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	53		 push	 rbx
  00010	56		 push	 rsi
  00011	57		 push	 rdi
  00012	41 56		 push	 r14
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00018	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  00021	49 8b f0	 mov	 rsi, r8
  00024	48 8b d9	 mov	 rbx, rcx

; 2179 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

  00027	48 8b fa	 mov	 rdi, rdx
  0002a	48 83 cf 0f	 or	 rdi, 15

; 2180 : 		if (max_size() < _Newres)

  0002e	48 83 ff fe	 cmp	 rdi, -2
  00032	76 05		 jbe	 SHORT $LN2@Copy

; 2181 : 			_Newres = _Newsize;	// undo roundup if too big

  00034	48 8b fa	 mov	 rdi, rdx

; 2182 : 		else if (this->_Myres() / 2 <= _Newres / 3)

  00037	eb 35		 jmp	 SHORT $LN108@Copy
$LN2@Copy:
  00039	4c 8b 41 20	 mov	 r8, QWORD PTR [rcx+32]
  0003d	49 8b c8	 mov	 rcx, r8
  00040	48 d1 e9	 shr	 rcx, 1
  00043	48 b8 ab aa aa
	aa aa aa aa aa	 mov	 rax, -6148914691236517205 ; aaaaaaaaaaaaaaabH
  0004d	48 f7 e7	 mul	 rdi
  00050	48 d1 ea	 shr	 rdx, 1
  00053	48 3b ca	 cmp	 rcx, rdx
  00056	76 16		 jbe	 SHORT $LN108@Copy

; 2183 : 			;
; 2184 : 		else if (this->_Myres() <= max_size() - this->_Myres() / 2)

  00058	48 c7 c7 fe ff
	ff ff		 mov	 rdi, -2
  0005f	48 8b c7	 mov	 rax, rdi
  00062	48 2b c1	 sub	 rax, rcx
  00065	4c 3b c0	 cmp	 r8, rax
  00068	77 04		 ja	 SHORT $LN108@Copy

; 2185 : 			_Newres = this->_Myres()

  0006a	4a 8d 3c 01	 lea	 rdi, QWORD PTR [rcx+r8]
$LN108@Copy:

; 2186 : 				+ this->_Myres() / 2;	// grow exponentially if possible
; 2187 : 		else
; 2188 : 			_Newres = max_size();	// settle for max_size()
; 2189 : 
; 2190 : 		_Elem *_Ptr;
; 2191 : 		_TRY_BEGIN
; 2192 : 			_Ptr = this->_Getal().allocate(_Newres + 1);

  0006e	48 8d 4f 01	 lea	 rcx, QWORD PTR [rdi+1]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 625  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

  00072	41 b0 01	 mov	 r8b, 1
  00075	ba 01 00 00 00	 mov	 edx, 1
  0007a	e8 00 00 00 00	 call	 ?_Allocate@std@@YAPEAX_K0_N@Z ; std::_Allocate
  0007f	4c 8b f0	 mov	 r14, rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
  00082	eb 14		 jmp	 SHORT $LN18@Copy
$LN19@Copy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
  00084	48 8b 5c 24 60	 mov	 rbx, QWORD PTR this$[rsp]
  00089	48 8b 74 24 70	 mov	 rsi, QWORD PTR _Oldlen$[rsp]
  0008e	48 8b 7c 24 68	 mov	 rdi, QWORD PTR _Newres$[rsp]
  00093	4c 8b 74 24 78	 mov	 r14, QWORD PTR _Ptr$[rsp]
$LN18@Copy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2203 : 		if (0 < _Oldlen)

  00098	48 85 f6	 test	 rsi, rsi
  0009b	74 21		 je	 SHORT $LN284@Copy

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  0009d	48 83 7b 20 10	 cmp	 QWORD PTR [rbx+32], 16
  000a2	72 06		 jb	 SHORT $LN273@Copy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 716  : 	return (_Addressof(_Val, is_function<_Ty>()));

  000a4	48 8b 53 08	 mov	 rdx, QWORD PTR [rbx+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  000a8	eb 04		 jmp	 SHORT $LN274@Copy
$LN273@Copy:
  000aa	48 8d 53 08	 lea	 rdx, QWORD PTR [rbx+8]
$LN274@Copy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 530  : 		return (_Count == 0 ? _First1

  000ae	48 85 f6	 test	 rsi, rsi
  000b1	74 0b		 je	 SHORT $LN284@Copy
  000b3	4c 8b c6	 mov	 r8, rsi
  000b6	49 8b ce	 mov	 rcx, r14
  000b9	e8 00 00 00 00	 call	 memcpy
$LN284@Copy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2246 : 		else if (this->_BUF_SIZE <= this->_Myres())

  000be	48 8b 53 20	 mov	 rdx, QWORD PTR [rbx+32]
  000c2	48 83 fa 10	 cmp	 rdx, 16
  000c6	72 12		 jb	 SHORT $LN288@Copy

; 2247 : 			{	// copy any leftovers to small buffer and deallocate
; 2248 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2249 : 			this->_Getal().destroy(&this->_Bx()._Ptr);
; 2250 : 			if (0 < _Newsize)
; 2251 : 				_Traits::copy(this->_Bx()._Buf,
; 2252 : 					_STD addressof(*_Ptr), _Newsize);
; 2253 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

  000c8	48 ff c2	 inc	 rdx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 620  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  000cb	41 b8 01 00 00
	00		 mov	 r8d, 1
  000d1	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
  000d5	e8 00 00 00 00	 call	 ?_Deallocate@std@@YAXPEAX_K1@Z ; std::_Deallocate
$LN288@Copy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2255 : 		this->_Myres() = this->_BUF_SIZE - 1;

  000da	48 c7 43 20 0f
	00 00 00	 mov	 QWORD PTR [rbx+32], 15

; 2214 : 		_Traits::assign(this->_Myptr()[this->_Mysize() = _Newsize], _Elem());

  000e2	48 c7 43 18 00
	00 00 00	 mov	 QWORD PTR [rbx+24], 0

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  000ea	48 8d 43 08	 lea	 rax, QWORD PTR [rbx+8]
  000ee	48 83 7b 20 10	 cmp	 QWORD PTR [rbx+32], 16
  000f3	72 05		 jb	 SHORT $LN392@Copy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 708  : 	return (reinterpret_cast<_Ty *>(

  000f5	48 8b 08	 mov	 rcx, QWORD PTR [rax]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  000f8	eb 03		 jmp	 SHORT $LN393@Copy
$LN392@Copy:
  000fa	48 8b c8	 mov	 rcx, rax
$LN393@Copy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  000fd	c6 01 00	 mov	 BYTE PTR [rcx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 637  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00100	48 85 c0	 test	 rax, rax
  00103	74 03		 je	 SHORT $LN430@Copy
  00105	4c 89 30	 mov	 QWORD PTR [rax], r14
$LN430@Copy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2208 : 		this->_Myres() = _Newres;

  00108	48 89 7b 20	 mov	 QWORD PTR [rbx+32], rdi

; 2214 : 		_Traits::assign(this->_Myptr()[this->_Mysize() = _Newsize], _Elem());

  0010c	48 89 73 18	 mov	 QWORD PTR [rbx+24], rsi

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  00110	48 83 7b 20 10	 cmp	 QWORD PTR [rbx+32], 16
  00115	72 03		 jb	 SHORT $LN468@Copy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 708  : 	return (reinterpret_cast<_Ty *>(

  00117	48 8b 00	 mov	 rax, QWORD PTR [rax]
$LN468@Copy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  0011a	c6 04 30 00	 mov	 BYTE PTR [rax+rsi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2210 : 		}

  0011e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00122	41 5e		 pop	 r14
  00124	5f		 pop	 rdi
  00125	5e		 pop	 rsi
  00126	5b		 pop	 rbx
  00127	c3		 ret	 0
$LN478@Copy:
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 96
_Newres$ = 104
_Newsize$ = 104
_Oldlen$ = 112
_Ptr$ = 120
?catch$1@?0??_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z@4HA PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy'::`1'::catch$1

; 2193 : 		_CATCH_ALL

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	55		 push	 rbp
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b ea	 mov	 rbp, rdx
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z$0:

; 2193 : 		_CATCH_ALL
; 2194 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

  0000d	48 8b 4d 68	 mov	 rcx, QWORD PTR _Newsize$[rbp]
  00011	48 89 4d 68	 mov	 QWORD PTR _Newres$[rbp], rcx

; 2193 : 		_CATCH_ALL
; 2194 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2195 : 			_TRY_BEGIN
; 2196 : 				_Ptr = this->_Getal().allocate(_Newres + 1);

  00015	48 ff c1	 inc	 rcx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 625  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

  00018	41 b0 01	 mov	 r8b, 1
  0001b	ba 01 00 00 00	 mov	 edx, 1
  00020	e8 00 00 00 00	 call	 ?_Allocate@std@@YAPEAX_K0_N@Z ; std::_Allocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2193 : 		_CATCH_ALL
; 2194 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2195 : 			_TRY_BEGIN
; 2196 : 				_Ptr = this->_Getal().allocate(_Newres + 1);

  00025	48 89 45 78	 mov	 QWORD PTR _Ptr$[rbp], rax

; 2193 : 		_CATCH_ALL
; 2194 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2195 : 			_TRY_BEGIN
; 2196 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2197 : 			_CATCH_ALL
; 2198 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2199 : 			_RERAISE;
; 2200 : 			_CATCH_END
; 2201 : 		_CATCH_END

  00029	48 8d 05 00 00
	00 00		 lea	 rax, $LN19@catch$1
  00030	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00034	5d		 pop	 rbp
  00035	c3		 ret	 0
  00036	cc		 int	 3
?catch$1@?0??_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z@4HA ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy'::`1'::catch$1
$T1 = 32
this$ = 96
_Newres$ = 104
_Newsize$ = 104
_Oldlen$ = 112
_Ptr$ = 120
?catch$0@?0??_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z@4HA PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy'::`1'::catch$0

; 2193 : 		_CATCH_ALL
; 2194 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2195 : 			_TRY_BEGIN
; 2196 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2197 : 			_CATCH_ALL

  00037	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0003c	53		 push	 rbx
  0003d	55		 push	 rbp
  0003e	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00042	48 8b ea	 mov	 rbp, rdx
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z$1:

; 728  : 		return (_Get_data()._Myres);

  00045	48 8b 5d 60	 mov	 rbx, QWORD PTR this$[rbp]

; 2246 : 		else if (this->_BUF_SIZE <= this->_Myres())

  00049	48 8b 53 20	 mov	 rdx, QWORD PTR [rbx+32]
  0004d	48 83 fa 10	 cmp	 rdx, 16
  00051	72 12		 jb	 SHORT $LN148@catch$0

; 2247 : 			{	// copy any leftovers to small buffer and deallocate
; 2248 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2249 : 			this->_Getal().destroy(&this->_Bx()._Ptr);
; 2250 : 			if (0 < _Newsize)
; 2251 : 				_Traits::copy(this->_Bx()._Buf,
; 2252 : 					_STD addressof(*_Ptr), _Newsize);
; 2253 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

  00053	48 ff c2	 inc	 rdx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 620  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00056	41 b8 01 00 00
	00		 mov	 r8d, 1
  0005c	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
  00060	e8 00 00 00 00	 call	 ?_Deallocate@std@@YAXPEAX_K1@Z ; std::_Deallocate
$LN148@catch$0:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2255 : 		this->_Myres() = this->_BUF_SIZE - 1;

  00065	48 c7 43 20 0f
	00 00 00	 mov	 QWORD PTR [rbx+32], 15

; 2214 : 		_Traits::assign(this->_Myptr()[this->_Mysize() = _Newsize], _Elem());

  0006d	48 c7 43 18 00
	00 00 00	 mov	 QWORD PTR [rbx+24], 0

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  00075	48 83 7b 20 10	 cmp	 QWORD PTR [rbx+32], 16
  0007a	72 06		 jb	 SHORT $LN252@catch$0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 708  : 	return (reinterpret_cast<_Ty *>(

  0007c	48 8b 5b 08	 mov	 rbx, QWORD PTR [rbx+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  00080	eb 04		 jmp	 SHORT $LN253@catch$0
$LN252@catch$0:
  00082	48 83 c3 08	 add	 rbx, 8
$LN253@catch$0:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  00086	c6 03 00	 mov	 BYTE PTR [rbx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2193 : 		_CATCH_ALL
; 2194 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2195 : 			_TRY_BEGIN
; 2196 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2197 : 			_CATCH_ALL
; 2198 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2199 : 			_RERAISE;

  00089	33 d2		 xor	 edx, edx
  0008b	33 c9		 xor	 ecx, ecx
  0008d	e8 00 00 00 00	 call	 _CxxThrowException
  00092	90		 npad	 1
?catch$0@?0??_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z@4HA ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 96
_Newres$ = 104
_Newsize$ = 104
_Oldlen$ = 112
_Ptr$ = 120
?catch$1@?0??_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z@4HA PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy'::`1'::catch$1

; 2193 : 		_CATCH_ALL

  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	55		 push	 rbp
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b ea	 mov	 rbp, rdx
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z$0:

; 2194 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

  0000d	48 8b 4d 68	 mov	 rcx, QWORD PTR _Newsize$[rbp]
  00011	48 89 4d 68	 mov	 QWORD PTR _Newres$[rbp], rcx

; 2196 : 				_Ptr = this->_Getal().allocate(_Newres + 1);

  00015	48 ff c1	 inc	 rcx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 625  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

  00018	41 b0 01	 mov	 r8b, 1
  0001b	ba 01 00 00 00	 mov	 edx, 1
  00020	e8 00 00 00 00	 call	 ?_Allocate@std@@YAPEAX_K0_N@Z ; std::_Allocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2196 : 				_Ptr = this->_Getal().allocate(_Newres + 1);

  00025	48 89 45 78	 mov	 QWORD PTR _Ptr$[rbp], rax

; 2197 : 			_CATCH_ALL
; 2198 : 			_Tidy(true);	// failed again, discard storage and reraise
; 2199 : 			_RERAISE;
; 2200 : 			_CATCH_END
; 2201 : 		_CATCH_END

  00029	48 8d 05 00 00
	00 00		 lea	 rax, $LN19@catch$1
  00030	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00034	5d		 pop	 rbp
  00035	c3		 ret	 0
  00036	cc		 int	 3
?catch$1@?0??_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z@4HA ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy'::`1'::catch$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 96
_Newres$ = 104
_Newsize$ = 104
_Oldlen$ = 112
_Ptr$ = 120
?catch$0@?0??_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z@4HA PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy'::`1'::catch$0

; 729  : 		}
; 730  : 
; 731  : 	const size_type& _Myres() const _NOEXCEPT
; 732  : 		{	// return const reference to _Myres
; 733  : 		return (_Get_data()._Myres);
; 734  : 		}
; 735  : 
; 736  : private:
; 737  : 	_Compressed_pair<_Alty, _String_val<_Val_types> > _Mypair;
; 738  : 	};
; 739  : 
; 740  : 		// TEMPLATE CLASS basic_string
; 741  : template<class _Elem,
; 742  : 	class _Traits,
; 743  : 	class _Alloc>
; 744  : 	class basic_string
; 745  : 		: public _String_alloc<_String_base_types<_Elem, _Alloc> >
; 746  : 	{	// null-terminated transparent array of elements
; 747  : public:
; 748  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Myt;
; 749  : 	typedef _String_alloc<_String_base_types<_Elem, _Alloc> > _Mybase;
; 750  : 	typedef _Traits traits_type;
; 751  : 	typedef _Alloc allocator_type;
; 752  : 
; 753  : 	typedef typename _Mybase::_Alty _Alty;
; 754  : 
; 755  : 	typedef typename _Mybase::value_type value_type;
; 756  : 	typedef typename _Mybase::size_type size_type;
; 757  : 	typedef typename _Mybase::difference_type difference_type;
; 758  : 	typedef typename _Mybase::pointer pointer;
; 759  : 	typedef typename _Mybase::const_pointer const_pointer;
; 760  : 	typedef typename _Mybase::reference reference;
; 761  : 	typedef typename _Mybase::const_reference const_reference;
; 762  : 
; 763  : 	typedef typename _Mybase::iterator iterator;
; 764  : 	typedef typename _Mybase::const_iterator const_iterator;
; 765  : 
; 766  : 	typedef _STD reverse_iterator<iterator> reverse_iterator;
; 767  : 	typedef _STD reverse_iterator<const_iterator> const_reverse_iterator;
; 768  : 
; 769  : 	basic_string(const _Myt& _Right)
; 770  : 
; 771  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())
; 772  : 
; 773  : 
; 774  : 		{	// construct by copying _Right
; 775  : 		_Tidy();
; 776  : 		assign(_Right, 0, npos);
; 777  : 		}
; 778  : 
; 779  : 	basic_string(const _Myt& _Right, const _Alloc& _Al)
; 780  : 		: _Mybase(_Al)
; 781  : 		{	// construct by copying with allocator
; 782  : 		_Tidy();
; 783  : 		assign(_Right, 0, npos);
; 784  : 		}
; 785  : 
; 786  : 	basic_string() _NOEXCEPT_OP(is_nothrow_default_constructible<_Alloc>::value)
; 787  : 		: _Mybase()
; 788  : 		{	// construct empty string
; 789  : 		_Tidy();
; 790  : 		}
; 791  : 
; 792  : 	explicit basic_string(const _Alloc& _Al) _NOEXCEPT
; 793  : 		: _Mybase(_Al)
; 794  : 		{	// construct empty string with allocator
; 795  : 		_Tidy();
; 796  : 		}
; 797  : 
; 798  : 	basic_string(const _Myt& _Right, size_type _Roff,
; 799  : 		size_type _Count = npos)
; 800  : 		: _Mybase(_Right._Getal())
; 801  : 		{	// construct from _Right [_Roff, _Roff + _Count)
; 802  : 		_Tidy();
; 803  : 		assign(_Right, _Roff, _Count);
; 804  : 		}
; 805  : 
; 806  : 	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
; 807  : 		const _Alloc& _Al)
; 808  : 		: _Mybase(_Al)
; 809  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator
; 810  : 		_Tidy();
; 811  : 		assign(_Right, _Roff, _Count);
; 812  : 		}
; 813  : 
; 814  : 	basic_string(const _Elem *_Ptr, size_type _Count)
; 815  : 		: _Mybase()
; 816  : 		{	// construct from [_Ptr, _Ptr + _Count)
; 817  : 		_Tidy();
; 818  : 		assign(_Ptr, _Count);
; 819  : 		}
; 820  : 
; 821  : 	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
; 822  : 		: _Mybase(_Al)
; 823  : 		{	// construct from [_Ptr, _Ptr + _Count) with allocator
; 824  : 		_Tidy();
; 825  : 		assign(_Ptr, _Count);
; 826  : 		}
; 827  : 
; 828  : 	basic_string(const _Elem *_Ptr)
; 829  : 		: _Mybase()
; 830  : 		{	// construct from [_Ptr, <null>)
; 831  : 		_Tidy();
; 832  : 		assign(_Ptr);
; 833  : 		}
; 834  : 
; 835  : 	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
; 836  : 		: _Mybase(_Al)
; 837  : 		{	// construct from [_Ptr, <null>) with allocator
; 838  : 		_Tidy();
; 839  : 		assign(_Ptr);
; 840  : 		}
; 841  : 
; 842  : 	basic_string(size_type _Count, _Elem _Ch)
; 843  : 		: _Mybase()
; 844  : 		{	// construct from _Count * _Ch
; 845  : 		_Tidy();
; 846  : 		assign(_Count, _Ch);
; 847  : 		}
; 848  : 
; 849  : 	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
; 850  : 		: _Mybase(_Al)
; 851  : 		{	// construct from _Count * _Ch with allocator
; 852  : 		_Tidy();
; 853  : 		assign(_Count, _Ch);
; 854  : 		}
; 855  : 
; 856  : 	template<class _Iter,
; 857  : 		class = typename enable_if<_Is_iterator<_Iter>::value,
; 858  : 			void>::type>
; 859  : 		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al = _Alloc())
; 860  : 		: _Mybase(_Al)
; 861  : 		{	// construct from [_First, _Last) with optional allocator
; 862  : 		_DEBUG_RANGE(_First, _Last);
; 863  : 		_Tidy();
; 864  : 		_Construct(_Unchecked(_First), _Unchecked(_Last), _Iter_cat(_First));
; 865  : 		}
; 866  : 
; 867  : 	template<class _Iter>
; 868  : 		void _Construct(_Iter _First,
; 869  : 			_Iter _Last, input_iterator_tag)
; 870  : 		{	// initialize from [_First, _Last), input iterators
; 871  : 		_TRY_BEGIN
; 872  : 		for (; _First != _Last; ++_First)
; 873  : 			append((size_type)1, (_Elem)*_First);
; 874  : 		_CATCH_ALL
; 875  : 		_Tidy(true);
; 876  : 		_RERAISE;
; 877  : 		_CATCH_END
; 878  : 		}
; 879  : 
; 880  : 	template<class _Iter>
; 881  : 		void _Construct(_Iter _First,
; 882  : 			_Iter _Last, forward_iterator_tag)
; 883  : 		{	// initialize from [_First, _Last), forward iterators
; 884  : 		size_type _Count = 0;
; 885  : 		_Distance(_First, _Last, _Count);
; 886  : 		reserve(_Count);
; 887  : 		_Construct(_First, _Last, input_iterator_tag());
; 888  : 		}
; 889  : 
; 890  : 	void _Construct(_Elem *_First,
; 891  : 		_Elem *_Last, random_access_iterator_tag)
; 892  : 		{	// initialize from [_First, _Last), pointers
; 893  : 		if (_First != _Last)
; 894  : 			assign(_First, _Last - _First);
; 895  : 		}
; 896  : 
; 897  : 	void _Construct(const _Elem *_First,
; 898  : 		const _Elem *_Last, random_access_iterator_tag)
; 899  : 		{	// initialize from [_First, _Last), const pointers
; 900  : 		if (_First != _Last)
; 901  : 			assign(_First, _Last - _First);
; 902  : 		}
; 903  : 
; 904  : 	basic_string(_Myt&& _Right) _NOEXCEPT
; 905  : 		: _Mybase(_STD move(_Right._Getal()))
; 906  : 		{	// construct by moving _Right
; 907  : 		_Tidy();
; 908  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 909  : 		}
; 910  : 
; 911  : 	basic_string(_Myt&& _Right, const _Alloc& _Al)
; 912  : 		: _Mybase(_Al)
; 913  : 		{	// construct by moving _Right, allocator
; 914  : 		if (this->_Getal() != _Right._Getal())
; 915  : 			assign(_Right.begin(), _Right.end());
; 916  : 		else
; 917  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 918  : 		}
; 919  : 
; 920  : 	_Myt& operator=(_Myt&& _Right)
; 921  : 		_NOEXCEPT_OP(_Alty::propagate_on_container_move_assignment::value
; 922  : 			|| _Alty::is_always_equal::value)
; 923  : 		{	// assign by moving _Right
; 924  : 		if (this != &_Right)
; 925  : 			{	// different, assign it
; 926  : 			_Tidy(true);
; 927  : 
; 928  : 			if (_Alty::propagate_on_container_move_assignment::value
; 929  : 				&& this->_Getal() != _Right._Getal())
; 930  : 				this->_Move_alloc(_Right._Getal());
; 931  : 
; 932  : 			if (this->_Getal() != _Right._Getal())
; 933  : 				assign(_Right.begin(), _Right.end());
; 934  : 			else
; 935  : 				_Assign_rv(_STD forward<_Myt>(_Right));
; 936  : 			}
; 937  : 		return (*this);
; 938  : 		}
; 939  : 
; 940  : 	_Myt& assign(_Myt&& _Right) _NOEXCEPT
; 941  : 		{	// assign by moving _Right
; 942  : 		if (this == &_Right)
; 943  : 			;
; 944  : 		else if (get_allocator() != _Right.get_allocator()
; 945  : 			&& this->_BUF_SIZE <= _Right._Myres())
; 946  : 			*this = _Right;
; 947  : 		else
; 948  : 			{	// not same, clear this and steal from _Right
; 949  : 			_Tidy(true);
; 950  : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 951  : 			}
; 952  : 		return (*this);
; 953  : 		}
; 954  : 
; 955  : 	void _Assign_rv(_Myt&& _Right)
; 956  : 		{	// assign by moving _Right
; 957  : 		if (_Right._Myres() < this->_BUF_SIZE)
; 958  : 			_Traits::move(this->_Bx()._Buf, _Right._Bx()._Buf,
; 959  : 				_Right._Mysize() + 1);
; 960  : 		else
; 961  : 			{	// copy pointer
; 962  : 			this->_Getal().construct(&this->_Bx()._Ptr, _Right._Bx()._Ptr);
; 963  : 			_Right._Bx()._Ptr = pointer();
; 964  : 			}
; 965  : 		this->_Mysize() = _Right._Mysize();
; 966  : 		this->_Myres() = _Right._Myres();
; 967  : 		_Right._Tidy();
; 968  : 		}
; 969  : 
; 970  : 	basic_string(_XSTD initializer_list<_Elem> _Ilist,
; 971  : 		const _Alloc& _Al = allocator_type())
; 972  : 		: _Mybase(_Al)
; 973  : 		{	// construct from initializer_list
; 974  : 		_Tidy();
; 975  : 		assign(_Ilist.begin(), _Ilist.end());
; 976  : 		}
; 977  : 
; 978  : 	_Myt& operator=(_XSTD initializer_list<_Elem> _Ilist)
; 979  : 		{	// assign initializer_list
; 980  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 981  : 		}
; 982  : 
; 983  : 	_Myt& operator+=(_XSTD initializer_list<_Elem> _Ilist)
; 984  : 		{	// append initializer_list
; 985  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 986  : 		}
; 987  : 
; 988  : 	_Myt& assign(_XSTD initializer_list<_Elem> _Ilist)
; 989  : 		{	// assign initializer_list
; 990  : 		return (assign(_Ilist.begin(), _Ilist.end()));
; 991  : 		}
; 992  : 
; 993  : 	_Myt& append(_XSTD initializer_list<_Elem> _Ilist)
; 994  : 		{	// append initializer_list
; 995  : 		return (append(_Ilist.begin(), _Ilist.end()));
; 996  : 		}
; 997  : 
; 998  : 	iterator insert(const_iterator _Where,
; 999  : 		_XSTD initializer_list<_Elem> _Ilist)
; 1000 : 		{	// insert initializer_list
; 1001 : 		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
; 1002 : 		}
; 1003 : 
; 1004 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1005 : 		_XSTD initializer_list<_Elem> _Ilist)
; 1006 : 		{	// replace with initializer_list
; 1007 : 		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
; 1008 : 		}
; 1009 : 
; 1010 : 	~basic_string() _NOEXCEPT
; 1011 : 		{	// destroy the string
; 1012 : 		_Tidy(true);
; 1013 : 		}
; 1014 : 
; 1015 : 	_PGLOBAL static const size_type npos;	// bad/missing length/position
; 1016 : 
; 1017 : 	_Myt& operator=(const _Myt& _Right)
; 1018 : 		{	// assign _Right
; 1019 : 		if (this != &_Right)
; 1020 : 			{	// different, assign it
; 1021 : 			if (this->_Getal() != _Right._Getal()
; 1022 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1023 : 				{	// change allocator before copying
; 1024 : 				_Tidy(true);
; 1025 : 				this->_Copy_alloc(_Right._Getal());
; 1026 : 				}
; 1027 : 
; 1028 : 			assign(_Right);
; 1029 : 			}
; 1030 : 		return (*this);
; 1031 : 		}
; 1032 : 
; 1033 : 	_Myt& operator=(const _Elem *_Ptr)
; 1034 : 		{	// assign [_Ptr, <null>)
; 1035 : 		return (assign(_Ptr));
; 1036 : 		}
; 1037 : 
; 1038 : 	_Myt& operator=(_Elem _Ch)
; 1039 : 		{	// assign 1 * _Ch
; 1040 : 		return (assign(1, _Ch));
; 1041 : 		}
; 1042 : 
; 1043 : 	_Myt& operator+=(const _Myt& _Right)
; 1044 : 		{	// append _Right
; 1045 : 		return (append(_Right));
; 1046 : 		}
; 1047 : 
; 1048 : 	_Myt& operator+=(const _Elem *_Ptr)
; 1049 : 		{	// append [_Ptr, <null>)
; 1050 : 		return (append(_Ptr));
; 1051 : 		}
; 1052 : 
; 1053 : 	_Myt& operator+=(_Elem _Ch)
; 1054 : 		{	// append 1 * _Ch
; 1055 : 		return (append((size_type)1, _Ch));
; 1056 : 		}
; 1057 : 
; 1058 : 	_Myt& append(const _Myt& _Right)
; 1059 : 		{	// append _Right
; 1060 : 		return (append(_Right, 0, npos));
; 1061 : 		}
; 1062 : 
; 1063 : 	_Myt& append(const _Myt& _Right,
; 1064 : 		size_type _Roff, size_type _Count = npos)
; 1065 : 		{	// append _Right [_Roff, _Roff + _Count)
; 1066 : 		_Right._Check_offset(_Roff);
; 1067 : 		_Count = _Right._Clamp_suffix_size(_Roff, _Count);
; 1068 : 		if (npos - this->_Mysize() <= _Count)
; 1069 : 			_Xlen();	// result too long
; 1070 : 
; 1071 : 		const size_type _Num = this->_Mysize() + _Count;
; 1072 : 		if (0 < _Count && _Grow(_Num))
; 1073 : 			{	// make room and append new stuff
; 1074 : 			_Traits::copy(this->_Myptr() + this->_Mysize(),
; 1075 : 				_Right._Myptr() + _Roff, _Count);
; 1076 : 			_Eos(_Num);
; 1077 : 			}
; 1078 : 		return (*this);
; 1079 : 		}
; 1080 : 
; 1081 : 	_Myt& append(const _Elem *_Ptr, size_type _Count)
; 1082 : 		{	// append [_Ptr, _Ptr + _Count)
; 1083 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1084 : 		if (_Inside(_Ptr))
; 1085 : 			return (append(*this,
; 1086 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1087 : 		if (npos - this->_Mysize() <= _Count)
; 1088 : 			_Xlen();	// result too long
; 1089 : 
; 1090 : 		const size_type _Num = this->_Mysize() + _Count;
; 1091 : 		if (0 < _Count && _Grow(_Num))
; 1092 : 			{	// make room and append new stuff
; 1093 : 			_Traits::copy(this->_Myptr() + this->_Mysize(), _Ptr, _Count);
; 1094 : 			_Eos(_Num);
; 1095 : 			}
; 1096 : 		return (*this);
; 1097 : 		}
; 1098 : 
; 1099 : 	_Myt& append(const _Elem *_Ptr)
; 1100 : 		{	// append [_Ptr, <null>)
; 1101 : 		_DEBUG_POINTER(_Ptr);
; 1102 : 		return (append(_Ptr, _Traits::length(_Ptr)));
; 1103 : 		}
; 1104 : 
; 1105 : 	_Myt& append(size_type _Count, _Elem _Ch)
; 1106 : 		{	// append _Count * _Ch
; 1107 : 		if (npos - this->_Mysize() <= _Count)
; 1108 : 			_Xlen();	// result too long
; 1109 : 
; 1110 : 		const size_type _Num = this->_Mysize() + _Count;
; 1111 : 		if (0 < _Count && _Grow(_Num))
; 1112 : 			{	// make room and append new stuff using assign
; 1113 : 			_Chassign(this->_Mysize(), _Count, _Ch);
; 1114 : 			_Eos(_Num);
; 1115 : 			}
; 1116 : 		return (*this);
; 1117 : 		}
; 1118 : 
; 1119 : 	template<class _Iter>
; 1120 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1121 : 			_Myt&>::type
; 1122 : 		append(_Iter _First, _Iter _Last)
; 1123 : 		{	// append [_First, _Last), input iterators
; 1124 : 		return (replace(end(), end(), _First, _Last));
; 1125 : 		}
; 1126 : 
; 1127 : 	_Myt& append(const_pointer _First, const_pointer _Last)
; 1128 : 		{	// append [_First, _Last), const pointers
; 1129 : 		return (replace(end(), end(), _First, _Last));
; 1130 : 		}
; 1131 : 
; 1132 : 	_Myt& append(const_iterator _First, const_iterator _Last)
; 1133 : 		{	// append [_First, _Last), const_iterators
; 1134 : 		return (replace(end(), end(), _First, _Last));
; 1135 : 		}
; 1136 : 
; 1137 : 	_Myt& assign(const _Myt& _Right)
; 1138 : 		{	// assign _Right
; 1139 : 		return (assign(_Right, 0, npos));
; 1140 : 		}
; 1141 : 
; 1142 : 	_Myt& assign(const _Myt& _Right,
; 1143 : 		size_type _Roff, size_type _Count = npos)
; 1144 : 		{	// assign _Right [_Roff, _Roff + _Count)
; 1145 : 		_Right._Check_offset(_Roff);
; 1146 : 		_Count = _Right._Clamp_suffix_size(_Roff, _Count);
; 1147 : 
; 1148 : 		if (this == &_Right)
; 1149 : 			erase((size_type)(_Roff + _Count)), erase(0, _Roff);	// substring
; 1150 : 		else if (_Grow(_Count))
; 1151 : 			{	// make room and assign new stuff
; 1152 : 			_Traits::copy(this->_Myptr(),
; 1153 : 				_Right._Myptr() + _Roff, _Count);
; 1154 : 			_Eos(_Count);
; 1155 : 			}
; 1156 : 		return (*this);
; 1157 : 		}
; 1158 : 
; 1159 : 	_Myt& assign(const _Elem *_Ptr, size_type _Count)
; 1160 : 		{	// assign [_Ptr, _Ptr + _Count)
; 1161 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1162 : 		if (_Inside(_Ptr))
; 1163 : 			return (assign(*this,
; 1164 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1165 : 
; 1166 : 		if (_Grow(_Count))
; 1167 : 			{	// make room and assign new stuff
; 1168 : 			_Traits::copy(this->_Myptr(), _Ptr, _Count);
; 1169 : 			_Eos(_Count);
; 1170 : 			}
; 1171 : 		return (*this);
; 1172 : 		}
; 1173 : 
; 1174 : 	_Myt& assign(const _Elem *_Ptr)
; 1175 : 		{	// assign [_Ptr, <null>)
; 1176 : 		_DEBUG_POINTER(_Ptr);
; 1177 : 		return (assign(_Ptr, _Traits::length(_Ptr)));
; 1178 : 		}
; 1179 : 
; 1180 : 	_Myt& assign(size_type _Count, _Elem _Ch)
; 1181 : 		{	// assign _Count * _Ch
; 1182 : 		if (_Count == npos)
; 1183 : 			_Xlen();	// result too long
; 1184 : 
; 1185 : 		if (_Grow(_Count))
; 1186 : 			{	// make room and assign new stuff
; 1187 : 			_Chassign(0, _Count, _Ch);
; 1188 : 			_Eos(_Count);
; 1189 : 			}
; 1190 : 		return (*this);
; 1191 : 		}
; 1192 : 
; 1193 : 	template<class _Iter>
; 1194 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1195 : 			_Myt&>::type
; 1196 : 		assign(_Iter _First, _Iter _Last)
; 1197 : 		{	// assign [_First, _Last), input iterators
; 1198 : 		return (replace(begin(), end(), _First, _Last));
; 1199 : 		}
; 1200 : 
; 1201 : 	_Myt& assign(const_pointer _First, const_pointer _Last)
; 1202 : 		{	// assign [_First, _Last), const pointers
; 1203 : 		return (replace(begin(), end(), _First, _Last));
; 1204 : 		}
; 1205 : 
; 1206 : 	_Myt& assign(const_iterator _First, const_iterator _Last)
; 1207 : 		{	// assign [_First, _Last), const_iterators
; 1208 : 		return (replace(begin(), end(), _First, _Last));
; 1209 : 		}
; 1210 : 
; 1211 : 	_Myt& insert(size_type _Off, const _Myt& _Right)
; 1212 : 		{	// insert _Right at _Off
; 1213 : 		return (insert(_Off, _Right, 0, npos));
; 1214 : 		}
; 1215 : 
; 1216 : 	_Myt& insert(size_type _Off,
; 1217 : 		const _Myt& _Right, size_type _Roff, size_type _Count = npos)
; 1218 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off
; 1219 : 		_Check_offset(_Off);
; 1220 : 		_Right._Check_offset(_Roff);
; 1221 : 		_Count = _Right._Clamp_suffix_size(_Roff, _Count);
; 1222 : 		if (npos - this->_Mysize() <= _Count)
; 1223 : 			_Xlen();	// result too long
; 1224 : 
; 1225 : 		const size_type _Num = this->_Mysize() + _Count;
; 1226 : 		if (0 < _Count && _Grow(_Num))
; 1227 : 			{	// make room and insert new stuff
; 1228 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1229 : 				this->_Myptr() + _Off,
; 1230 : 				this->_Mysize() - _Off);	// empty out hole
; 1231 : 			if (this == &_Right)
; 1232 : 				_Traits::move(this->_Myptr() + _Off,
; 1233 : 					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
; 1234 : 						_Count);	// substring
; 1235 : 			else
; 1236 : 				_Traits::copy(this->_Myptr() + _Off,
; 1237 : 					_Right._Myptr() + _Roff, _Count);	// fill hole
; 1238 : 			_Eos(_Num);
; 1239 : 			}
; 1240 : 		return (*this);
; 1241 : 		}
; 1242 : 
; 1243 : 	_Myt& insert(size_type _Off,
; 1244 : 		const _Elem *_Ptr, size_type _Count)
; 1245 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off
; 1246 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1247 : 		if (_Inside(_Ptr))
; 1248 : 			return (insert(_Off, *this,
; 1249 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1250 : 		_Check_offset(_Off);
; 1251 : 		if (npos - this->_Mysize() <= _Count)
; 1252 : 			_Xlen();	// result too long
; 1253 : 		const size_type _Num = this->_Mysize() + _Count;
; 1254 : 		if (0 < _Count && _Grow(_Num))
; 1255 : 			{	// make room and insert new stuff
; 1256 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1257 : 				this->_Myptr() + _Off,
; 1258 : 				this->_Mysize() - _Off);	// empty out hole
; 1259 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1260 : 			_Eos(_Num);
; 1261 : 			}
; 1262 : 		return (*this);
; 1263 : 		}
; 1264 : 
; 1265 : 	_Myt& insert(size_type _Off, const _Elem *_Ptr)
; 1266 : 		{	// insert [_Ptr, <null>) at _Off
; 1267 : 		_DEBUG_POINTER(_Ptr);
; 1268 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
; 1269 : 		}
; 1270 : 
; 1271 : 	_Myt& insert(size_type _Off,
; 1272 : 		size_type _Count, _Elem _Ch)
; 1273 : 		{	// insert _Count * _Ch at _Off
; 1274 : 		_Check_offset(_Off);
; 1275 : 		if (npos - this->_Mysize() <= _Count)
; 1276 : 			_Xlen();	// result too long
; 1277 : 		const size_type _Num = this->_Mysize() + _Count;
; 1278 : 		if (0 < _Count && _Grow(_Num))
; 1279 : 			{	// make room and insert new stuff
; 1280 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1281 : 				this->_Myptr() + _Off,
; 1282 : 				this->_Mysize() - _Off);	// empty out hole
; 1283 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1284 : 			_Eos(_Num);
; 1285 : 			}
; 1286 : 		return (*this);
; 1287 : 		}
; 1288 : 
; 1289 : 	iterator insert(const_iterator _Where)
; 1290 : 		{	// insert <null> at _Where
; 1291 : 		return (insert(_Where, _Elem()));
; 1292 : 		}
; 1293 : 
; 1294 : 	iterator insert(const_iterator _Where, _Elem _Ch)
; 1295 : 		{	// insert _Ch at _Where
; 1296 : 		size_type _Off = _Where - begin();
; 1297 : 		insert(_Off, 1, _Ch);
; 1298 : 		return (begin() + _Off);
; 1299 : 		}
; 1300 : 
; 1301 : 	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
; 1302 : 		{	// insert _Count * _Elem at _Where
; 1303 : 		size_type _Off = _Where - begin();
; 1304 : 		insert(_Off, _Count, _Ch);
; 1305 : 		return (begin() + _Off);
; 1306 : 		}
; 1307 : 
; 1308 : 	template<class _Iter>
; 1309 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1310 : 			iterator>::type
; 1311 : 		insert(const_iterator _Where, _Iter _First, _Iter _Last)
; 1312 : 		{	// insert [_First, _Last) at _Where, input iterators
; 1313 : 		size_type _Off = _Where - begin();
; 1314 : 		replace(_Where, _Where, _First, _Last);
; 1315 : 		return (begin() + _Off);
; 1316 : 		}
; 1317 : 
; 1318 : 	iterator insert(const_iterator _Where,
; 1319 : 		const_pointer _First, const_pointer _Last)
; 1320 : 		{	// insert [_First, _Last) at _Where, const pointers
; 1321 : 		size_type _Off = _Where - begin();
; 1322 : 		replace(_Where, _Where, _First, _Last);
; 1323 : 		return (begin() + _Off);
; 1324 : 		}
; 1325 : 
; 1326 : 	iterator insert(const_iterator _Where,
; 1327 : 		const_iterator _First, const_iterator _Last)
; 1328 : 		{	// insert [_First, _Last) at _Where, const_iterators
; 1329 : 		size_type _Off = _Where - begin();
; 1330 : 		replace(_Where, _Where, _First, _Last);
; 1331 : 		return (begin() + _Off);
; 1332 : 		}
; 1333 : 
; 1334 : 	_Myt& erase(size_type _Off = 0)
; 1335 : 		{	// erase elements [_Off, ...)
; 1336 : 		_Check_offset(_Off);
; 1337 : 		_Eos(_Off);
; 1338 : 		return (*this);
; 1339 : 		}
; 1340 : 
; 1341 : 	_Myt& erase(size_type _Off, size_type _Count)
; 1342 : 		{	// erase elements [_Off, _Off + _Count)
; 1343 : 		_Check_offset(_Off);
; 1344 : 		if (this->_Mysize() - _Off <= _Count)
; 1345 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1346 : 		else if (0 < _Count)
; 1347 : 			{	// move elements down
; 1348 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1349 : 			size_type _Newsize = this->_Mysize() - _Count;
; 1350 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
; 1351 : 			_Eos(_Newsize);
; 1352 : 			}
; 1353 : 		return (*this);
; 1354 : 		}
; 1355 : 
; 1356 : 	iterator erase(const_iterator _Where)
; 1357 : 		{	// erase element at _Where
; 1358 : 		size_type _Count = _Where - begin();
; 1359 : 		erase(_Count, 1);
; 1360 : 		return (begin() + _Count);
; 1361 : 		}
; 1362 : 
; 1363 : 	iterator erase(const_iterator _First, const_iterator _Last)
; 1364 : 		{	// erase substring [_First, _Last)
; 1365 : 		_DEBUG_RANGE(_First, _Last);
; 1366 : 		size_type _Count = _First - begin();
; 1367 : 		erase(_Count, _Last - _First);
; 1368 : 		return (begin() + _Count);
; 1369 : 		}
; 1370 : 
; 1371 : 	void clear() _NOEXCEPT
; 1372 : 		{	// erase all
; 1373 : 		_Eos(0);
; 1374 : 		}
; 1375 : 
; 1376 : 	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
; 1377 : 		{	// replace [_Off, _Off + _N0) with _Right
; 1378 : 		return (replace(_Off, _N0, _Right, 0, npos));
; 1379 : 		}
; 1380 : 
; 1381 : 	_Myt& replace(size_type _Off,
; 1382 : 		size_type _N0, const _Myt& _Right, size_type _Roff,
; 1383 : 			size_type _Count = npos)
; 1384 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 1385 : 		_Check_offset(_Off);
; 1386 : 		_Right._Check_offset(_Roff);
; 1387 : 		_N0 = _Clamp_suffix_size(_Off, _N0);
; 1388 : 		_Count = _Right._Clamp_suffix_size(_Roff, _Count);
; 1389 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1390 : 			_Xlen();	// result too long
; 1391 : 
; 1392 : 		const size_type _Nm = this->_Mysize() - _N0 - _Off;	// length of kept tail
; 1393 : 		const size_type _Newsize = this->_Mysize() + _Count - _N0;
; 1394 : 		if (this->_Mysize() < _Newsize)
; 1395 : 			_Grow(_Newsize);
; 1396 : 
; 1397 : 		if (_Count == _N0)
; 1398 : 			{	// only one movement required, so _Traits::move handles any overlap
; 1399 : 			_Traits::move(this->_Myptr() + _Off,
; 1400 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1401 : 			}
; 1402 : 		else if (this != &_Right)
; 1403 : 			{	// no overlap, just move down and copy in new stuff
; 1404 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1405 : 				this->_Myptr() + _Off + _N0, _Nm);	// empty hole
; 1406 : 			_Traits::copy(this->_Myptr() + _Off,
; 1407 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1408 : 			}
; 1409 : 		else if (_Count < _N0)
; 1410 : 			{	// hole doesn't get larger, just copy in substring
; 1411 : 			_Traits::move(this->_Myptr() + _Off,
; 1412 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1413 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1414 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1415 : 			}
; 1416 : 		else if (_Roff <= _Off)
; 1417 : 			{	// hole gets larger, substring begins before hole
; 1418 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1419 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1420 : 			_Traits::move(this->_Myptr() + _Off,
; 1421 : 				this->_Myptr() + _Roff, _Count);	// fill hole
; 1422 : 			}
; 1423 : 		else if (_Off + _N0 <= _Roff)
; 1424 : 			{	// hole gets larger, substring begins after hole
; 1425 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1426 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1427 : 			_Traits::move(this->_Myptr() + _Off,
; 1428 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1429 : 				_Count);	// fill hole
; 1430 : 			}
; 1431 : 		else
; 1432 : 			{	// hole gets larger, substring begins in hole
; 1433 : 			_Traits::move(this->_Myptr() + _Off,
; 1434 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1435 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1436 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1437 : 			_Traits::move(this->_Myptr() + _Off + _N0,
; 1438 : 				this->_Myptr() + _Roff + _Count,
; 1439 : 				_Count - _N0);	// fill rest of new hole
; 1440 : 			}
; 1441 : 
; 1442 : 		_Eos(_Newsize);
; 1443 : 		return (*this);
; 1444 : 		}
; 1445 : 
; 1446 : 	_Myt& replace(size_type _Off,
; 1447 : 		size_type _N0, const _Elem *_Ptr, size_type _Count)
; 1448 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 1449 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1450 : 		if (_Inside(_Ptr))
; 1451 : 			return (replace(_Off, _N0, *this,
; 1452 : 				_Ptr - this->_Myptr(),
; 1453 : 				_Count));	// substring, replace carefully
; 1454 : 		_Check_offset(_Off);
; 1455 : 		_N0 = _Clamp_suffix_size(_Off, _N0);
; 1456 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1457 : 			_Xlen();	// result too long
; 1458 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;
; 1459 : 
; 1460 : 		if (_Count < _N0)
; 1461 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1462 : 				this->_Myptr() + _Off + _N0,
; 1463 : 				_Nm);	// smaller hole, move tail up
; 1464 : 		const size_type _Num = this->_Mysize() + _Count - _N0;
; 1465 : 		if ((0 < _Count || 0 < _N0)
; 1466 : 			&& _Grow(_Num))
; 1467 : 			{	// make room and rearrange
; 1468 : 			if (_N0 < _Count)
; 1469 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1470 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1471 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole
; 1472 : 			_Eos(_Num);
; 1473 : 			}
; 1474 : 		return (*this);
; 1475 : 		}
; 1476 : 
; 1477 : 	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
; 1478 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, <null>)
; 1479 : 		_DEBUG_POINTER(_Ptr);
; 1480 : 		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
; 1481 : 		}
; 1482 : 
; 1483 : 	_Myt& replace(size_type _Off,
; 1484 : 		size_type _N0, size_type _Count, _Elem _Ch)
; 1485 : 		{	// replace [_Off, _Off + _N0) with _Count * _Ch
; 1486 : 		_Check_offset(_Off);
; 1487 : 		_N0 = _Clamp_suffix_size(_Off, _N0);
; 1488 : 		if (npos - _Count <= this->_Mysize() - _N0)
; 1489 : 			_Xlen();	// result too long
; 1490 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;
; 1491 : 
; 1492 : 		if (_Count < _N0)
; 1493 : 			_Traits::move(this->_Myptr() + _Off + _Count,
; 1494 : 				this->_Myptr() + _Off + _N0,
; 1495 : 				_Nm);	// smaller hole, move tail up
; 1496 : 		const size_type _Num = this->_Mysize() + _Count - _N0;
; 1497 : 		if ((0 < _Count || 0 < _N0)
; 1498 : 			&& _Grow(_Num))
; 1499 : 			{	// make room and rearrange
; 1500 : 			if (_N0 < _Count)
; 1501 : 				_Traits::move(this->_Myptr() + _Off + _Count,
; 1502 : 					this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1503 : 			_Chassign(_Off, _Count, _Ch);	// fill hole
; 1504 : 			_Eos(_Num);
; 1505 : 			}
; 1506 : 		return (*this);
; 1507 : 		}
; 1508 : 
; 1509 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1510 : 		const _Myt& _Right)
; 1511 : 		{	// replace [_First, _Last) with _Right
; 1512 : 		return (replace(_First - begin(), _Last - _First, _Right));
; 1513 : 		}
; 1514 : 
; 1515 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1516 : 		const _Elem *_Ptr, size_type _Count)
; 1517 : 		{	// replace [_First, _Last) with [_Ptr, _Ptr + _Count)
; 1518 : 		return (replace(_First - begin(), _Last - _First, _Ptr, _Count));
; 1519 : 		}
; 1520 : 
; 1521 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1522 : 		const _Elem *_Ptr)
; 1523 : 		{	// replace [_First, _Last) with [_Ptr, <null>)
; 1524 : 		return (replace(_First - begin(), _Last - _First, _Ptr));
; 1525 : 		}
; 1526 : 
; 1527 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1528 : 		size_type _Count, _Elem _Ch)
; 1529 : 		{	// replace [_First, _Last) with _Count * _Ch
; 1530 : 		return (replace(_First - begin(), _Last - _First, _Count, _Ch));
; 1531 : 		}
; 1532 : 
; 1533 : 	template<class _Iter>
; 1534 : 		typename enable_if<_Is_iterator<_Iter>::value,
; 1535 : 			_Myt&>::type
; 1536 : 		replace(const_iterator _First, const_iterator _Last,
; 1537 : 			_Iter _First2, _Iter _Last2)
; 1538 : 		{	// replace [_First, _Last) with [_First2, _Last2), input iterators
; 1539 : 		_Myt _Right(_First2, _Last2);
; 1540 : 		replace(_First, _Last, _Right);
; 1541 : 		return (*this);
; 1542 : 		}
; 1543 : 
; 1544 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1545 : 		const_pointer _First2, const_pointer _Last2)
; 1546 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1547 : 		if (_First2 == _Last2)
; 1548 : 			erase(_First - begin(), _Last - _First);
; 1549 : 		else
; 1550 : 			replace(_First - begin(), _Last - _First,
; 1551 : 				&*_First2, _Last2 - _First2);
; 1552 : 		return (*this);
; 1553 : 		}
; 1554 : 
; 1555 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1556 : 		pointer _First2, pointer _Last2)
; 1557 : 		{	// replace [_First, _Last) with [_First2, _Last2), const pointers
; 1558 : 		if (_First2 == _Last2)
; 1559 : 			erase(_First - begin(), _Last - _First);
; 1560 : 		else
; 1561 : 			replace(_First - begin(), _Last - _First,
; 1562 : 				&*_First2, _Last2 - _First2);
; 1563 : 		return (*this);
; 1564 : 		}
; 1565 : 
; 1566 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1567 : 		const_iterator _First2, const_iterator _Last2)
; 1568 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1569 : 		if (_First2 == _Last2)
; 1570 : 			erase(_First - begin(), _Last - _First);
; 1571 : 		else
; 1572 : 			replace(_First - begin(), _Last - _First,
; 1573 : 				&*_First2, _Last2 - _First2);
; 1574 : 		return (*this);
; 1575 : 		}
; 1576 : 
; 1577 : 	_Myt& replace(const_iterator _First, const_iterator _Last,
; 1578 : 		iterator _First2, iterator _Last2)
; 1579 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators
; 1580 : 		if (_First2 == _Last2)
; 1581 : 			erase(_First - begin(), _Last - _First);
; 1582 : 		else
; 1583 : 			replace(_First - begin(), _Last - _First,
; 1584 : 				&*_First2, _Last2 - _First2);
; 1585 : 		return (*this);
; 1586 : 		}
; 1587 : 
; 1588 : 	iterator begin() _NOEXCEPT
; 1589 : 		{	// return iterator for beginning of mutable sequence
; 1590 : 		return (iterator(this->_Myptr(), &this->_Get_data()));
; 1591 : 		}
; 1592 : 
; 1593 : 	const_iterator begin() const _NOEXCEPT
; 1594 : 		{	// return iterator for beginning of nonmutable sequence
; 1595 : 		return (const_iterator(this->_Myptr(), &this->_Get_data()));
; 1596 : 		}
; 1597 : 
; 1598 : 	iterator end() _NOEXCEPT
; 1599 : 		{	// return iterator for end of mutable sequence
; 1600 : 		return (iterator(this->_Myptr() + this->_Mysize(), &this->_Get_data()));
; 1601 : 		}
; 1602 : 
; 1603 : 	const_iterator end() const _NOEXCEPT
; 1604 : 		{	// return iterator for end of nonmutable sequence
; 1605 : 		return (const_iterator(this->_Myptr() + this->_Mysize(), &this->_Get_data()));
; 1606 : 		}
; 1607 : 
; 1608 : 	reverse_iterator rbegin() _NOEXCEPT
; 1609 : 		{	// return iterator for beginning of reversed mutable sequence
; 1610 : 		return (reverse_iterator(end()));
; 1611 : 		}
; 1612 : 
; 1613 : 	const_reverse_iterator rbegin() const _NOEXCEPT
; 1614 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1615 : 		return (const_reverse_iterator(end()));
; 1616 : 		}
; 1617 : 
; 1618 : 	reverse_iterator rend() _NOEXCEPT
; 1619 : 		{	// return iterator for end of reversed mutable sequence
; 1620 : 		return (reverse_iterator(begin()));
; 1621 : 		}
; 1622 : 
; 1623 : 	const_reverse_iterator rend() const _NOEXCEPT
; 1624 : 		{	// return iterator for end of reversed nonmutable sequence
; 1625 : 		return (const_reverse_iterator(begin()));
; 1626 : 		}
; 1627 : 
; 1628 : 	const_iterator cbegin() const _NOEXCEPT
; 1629 : 		{	// return iterator for beginning of nonmutable sequence
; 1630 : 		return (begin());
; 1631 : 		}
; 1632 : 
; 1633 : 	const_iterator cend() const _NOEXCEPT
; 1634 : 		{	// return iterator for end of nonmutable sequence
; 1635 : 		return (end());
; 1636 : 		}
; 1637 : 
; 1638 : 	const_reverse_iterator crbegin() const _NOEXCEPT
; 1639 : 		{	// return iterator for beginning of reversed nonmutable sequence
; 1640 : 		return (rbegin());
; 1641 : 		}
; 1642 : 
; 1643 : 	const_reverse_iterator crend() const _NOEXCEPT
; 1644 : 		{	// return iterator for end of reversed nonmutable sequence
; 1645 : 		return (rend());
; 1646 : 		}
; 1647 : 
; 1648 : 	void shrink_to_fit()
; 1649 : 		{	// reduce capacity
; 1650 : 		if ((size() | this->_ALLOC_MASK) < capacity())
; 1651 : 			{	// worth shrinking, do it
; 1652 : 			_Myt _Tmp(*this);
; 1653 : 			swap(_Tmp);
; 1654 : 			}
; 1655 : 		}
; 1656 : 
; 1657 : 	reference at(size_type _Off)
; 1658 : 		{	// subscript mutable sequence with checking
; 1659 : 		_Check_offset_exclusive(_Off);
; 1660 : 		return (this->_Myptr()[_Off]);
; 1661 : 		}
; 1662 : 
; 1663 : 	const_reference at(size_type _Off) const
; 1664 : 		{	// subscript nonmutable sequence with checking
; 1665 : 		_Check_offset_exclusive(_Off);
; 1666 : 		return (this->_Myptr()[_Off]);
; 1667 : 		}
; 1668 : 
; 1669 : 	reference operator[](size_type _Off)
; 1670 : 		{	// subscript mutable sequence
; 1671 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1672 : 		if (this->_Mysize() < _Off)	// sic
; 1673 : 			_DEBUG_ERROR("string subscript out of range");
; 1674 : 
; 1675 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1676 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize());	// sic
; 1677 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1678 : 
; 1679 : 		return (this->_Myptr()[_Off]);
; 1680 : 		}
; 1681 : 
; 1682 : 	const_reference operator[](size_type _Off) const
; 1683 : 		{	// subscript nonmutable sequence
; 1684 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1685 : 		if (this->_Mysize() < _Off)	// sic
; 1686 : 			_DEBUG_ERROR("string subscript out of range");
; 1687 : 
; 1688 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1689 : 		_SCL_SECURE_VALIDATE_RANGE(_Off <= this->_Mysize());	// sic
; 1690 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1691 : 
; 1692 : 		return (this->_Myptr()[_Off]);
; 1693 : 		}
; 1694 : 
; 1695 : 	void push_back(_Elem _Ch)
; 1696 : 		{	// insert element at end
; 1697 : 		append(1, _Ch);
; 1698 : 		}
; 1699 : 
; 1700 : 	void pop_back()
; 1701 : 		{	// erase element at end
; 1702 : 		erase(this->_Mysize() - 1);	// throws if _Mysize() == 0
; 1703 : 		}
; 1704 : 
; 1705 : 	reference front()
; 1706 : 		{	// return first element of mutable sequence
; 1707 : 		return (*begin());
; 1708 : 		}
; 1709 : 
; 1710 : 	const_reference front() const
; 1711 : 		{	// return first element of nonmutable sequence
; 1712 : 		return (*begin());
; 1713 : 		}
; 1714 : 
; 1715 : 	reference back()
; 1716 : 		{	// return last element of mutable sequence
; 1717 : 		return (*(end() - 1));
; 1718 : 		}
; 1719 : 
; 1720 : 	const_reference back() const
; 1721 : 		{	// return last element of nonmutable sequence
; 1722 : 		return (*(end() - 1));
; 1723 : 		}
; 1724 : 
; 1725 : 	const _Elem *c_str() const _NOEXCEPT
; 1726 : 		{	// return pointer to null-terminated nonmutable array
; 1727 : 		return (this->_Myptr());
; 1728 : 		}
; 1729 : 
; 1730 : 	const _Elem *data() const _NOEXCEPT
; 1731 : 		{	// return pointer to nonmutable array
; 1732 : 		return (c_str());
; 1733 : 		}
; 1734 : 
; 1735 : 	size_type length() const _NOEXCEPT
; 1736 : 		{	// return length of sequence
; 1737 : 		return (this->_Mysize());
; 1738 : 		}
; 1739 : 
; 1740 : 	size_type size() const _NOEXCEPT
; 1741 : 		{	// return length of sequence
; 1742 : 		return (this->_Mysize());
; 1743 : 		}
; 1744 : 
; 1745 : 	size_type max_size() const _NOEXCEPT
; 1746 : 		{	// return maximum possible length of sequence
; 1747 : 		const size_type _Num = this->_Getal().max_size();
; 1748 : 		return (_Num <= 1 ? 1 : _Num - 1);
; 1749 : 		}
; 1750 : 
; 1751 : 	void resize(size_type _Newsize)
; 1752 : 		{	// determine new length, padding with null elements as needed
; 1753 : 		resize(_Newsize, _Elem());
; 1754 : 		}
; 1755 : 
; 1756 : 	void resize(size_type _Newsize, _Elem _Ch)
; 1757 : 		{	// determine new length, padding with _Ch elements as needed
; 1758 : 		if (_Newsize <= this->_Mysize())
; 1759 : 			_Eos(_Newsize);
; 1760 : 		else
; 1761 : 			append(_Newsize - this->_Mysize(), _Ch);
; 1762 : 		}
; 1763 : 
; 1764 : 	size_type capacity() const _NOEXCEPT
; 1765 : 		{	// return current length of allocated storage
; 1766 : 		return (this->_Myres());
; 1767 : 		}
; 1768 : 
; 1769 : 	void reserve(size_type _Newcap = 0)
; 1770 : 		{	// determine new minimum length of allocated storage
; 1771 : 		if (this->_Mysize() <= _Newcap && this->_Myres() != _Newcap)
; 1772 : 			{	// change reservation
; 1773 : 			size_type _Size = this->_Mysize();
; 1774 : 			if (_Grow(_Newcap, true))
; 1775 : 				_Eos(_Size);
; 1776 : 			}
; 1777 : 		}
; 1778 : 
; 1779 : 	bool empty() const _NOEXCEPT
; 1780 : 		{	// test if sequence is empty
; 1781 : 		return (this->_Mysize() == 0);
; 1782 : 		}
; 1783 : 
; 1784 : 	_SCL_INSECURE_DEPRECATE
; 1785 : 
; 1786 : 	size_type copy(_Elem *_Ptr,
; 1787 : 		size_type _Count, size_type _Off = 0) const
; 1788 : 		{	// copy [_Off, _Off + _Count) to [_Ptr, _Ptr + _Count)
; 1789 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1790 : 		_Check_offset(_Off);
; 1791 : 		_Count = _Clamp_suffix_size(_Off, _Count);
; 1792 : 		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
; 1793 : 		return (_Count);
; 1794 : 		}
; 1795 : 
; 1796 : 	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
; 1797 : 		size_type _Count, size_type _Off = 0) const
; 1798 : 		{	// copy [_Off, _Off + _Count) to [_Dest, _Dest + _Count)
; 1799 : 		_DEBUG_POINTER_IF(_Count != 0, _Dest);
; 1800 : 		_Check_offset(_Off);
; 1801 : 		_Count = _Clamp_suffix_size(_Off, _Count);
; 1802 : 		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
; 1803 : 		return (_Count);
; 1804 : 		}
; 1805 : 
; 1806 : 	void _Swap_bx(_Myt& _Right)
; 1807 : 		{	// exchange _Bx() with _Right._Bx()
; 1808 : 		if (this->_BUF_SIZE <= this->_Myres())
; 1809 : 			if (this->_BUF_SIZE <= _Right._Myres())
; 1810 : 				_Swap_adl(this->_Bx()._Ptr, _Right._Bx()._Ptr);
; 1811 : 			else
; 1812 : 				{	// swap large with small
; 1813 : 				pointer _Ptr = this->_Bx()._Ptr;
; 1814 : 				this->_Getal().destroy(&this->_Bx()._Ptr);
; 1815 : 				_Traits::copy(this->_Bx()._Buf,
; 1816 : 					_Right._Bx()._Buf, _Right._Mysize() + 1);
; 1817 : 				this->_Getal().construct(&_Right._Bx()._Ptr, _Ptr);
; 1818 : 				}
; 1819 : 		else
; 1820 : 			if (_Right._Myres() < this->_BUF_SIZE)
; 1821 : 				_STD swap(this->_Bx()._Buf, _Right._Bx()._Buf);
; 1822 : 			else
; 1823 : 				{	// swap small with large
; 1824 : 				pointer _Ptr = _Right._Bx()._Ptr;
; 1825 : 				this->_Getal().destroy(&_Right._Bx()._Ptr);
; 1826 : 				_Traits::copy(_Right._Bx()._Buf,
; 1827 : 					this->_Bx()._Buf, this->_Mysize() + 1);
; 1828 : 				this->_Getal().construct(&this->_Bx()._Ptr, _Ptr);
; 1829 : 				}
; 1830 : 		}
; 1831 : 
; 1832 : 	void swap(_Myt& _Right)
; 1833 : 		_NOEXCEPT_OP(_Alty::propagate_on_container_swap::value
; 1834 : 			|| _Alty::is_always_equal::value)
; 1835 : 		{	// exchange contents with _Right
; 1836 : 		if (this == &_Right)
; 1837 : 			;	// same object, do nothing
; 1838 : 		else if (this->_Getal() == _Right._Getal())
; 1839 : 			{	// same allocator, swap control information
; 1840 : 			this->_Swap_all(_Right);
; 1841 : 			_Swap_bx(_Right);
; 1842 : 			_STD swap(this->_Mysize(), _Right._Mysize());
; 1843 : 			_STD swap(this->_Myres(), _Right._Myres());
; 1844 : 			}
; 1845 : 
; 1846 : 		else if (_Alty::propagate_on_container_swap::value)
; 1847 : 			{	// swap allocators and control information
; 1848 : 				// assumes pointer is bitwise copyable
; 1849 : 			this->_Swap_alloc(_Right);
; 1850 : 			_Swap_bx(_Right);
; 1851 : 			_STD swap(this->_Bx(), _Right._Bx());
; 1852 : 			_STD swap(this->_Mysize(), _Right._Mysize());
; 1853 : 			_STD swap(this->_Myres(), _Right._Myres());
; 1854 : 			}
; 1855 : 
; 1856 : 		else
; 1857 : 			{	// different allocator, do multiple assigns
; 1858 : 			_Myt _Tmp = *this;
; 1859 : 
; 1860 : 			*this = _Right;
; 1861 : 			_Right = _Tmp;
; 1862 : 			}
; 1863 : 		}
; 1864 : 
; 1865 : 	size_type find(const _Myt& _Right, size_type _Off = 0) const _NOEXCEPT
; 1866 : 		{	// look for _Right beginning at or after _Off
; 1867 : 		return (find(_Right._Myptr(), _Off, _Right.size()));
; 1868 : 		}
; 1869 : 
; 1870 : 	size_type find(const _Elem *_Ptr,
; 1871 : 		size_type _Off, size_type _Count) const
; 1872 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off
; 1873 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1874 : 		if (_Count == 0 && _Off <= this->_Mysize())
; 1875 : 			return (_Off);	// null string always matches (if inside string)
; 1876 : 
; 1877 : 		size_type _Nm;
; 1878 : 		if (_Off < this->_Mysize() && _Count <= (_Nm = this->_Mysize() - _Off))
; 1879 : 			{	// room for match, look for it
; 1880 : 			const _Elem *_Uptr, *_Vptr;
; 1881 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
; 1882 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
; 1883 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
; 1884 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1885 : 					return (_Uptr - this->_Myptr());	// found a match
; 1886 : 			}
; 1887 : 
; 1888 : 		return (npos);	// no match
; 1889 : 		}
; 1890 : 
; 1891 : 	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
; 1892 : 		{	// look for [_Ptr, <null>) beginning at or after _Off
; 1893 : 		_DEBUG_POINTER(_Ptr);
; 1894 : 		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
; 1895 : 		}
; 1896 : 
; 1897 : 	size_type find(_Elem _Ch, size_type _Off = 0) const
; 1898 : 		{	// look for _Ch at or after _Off
; 1899 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1900 : 		}
; 1901 : 
; 1902 : 	size_type rfind(const _Myt& _Right, size_type _Off = npos) const _NOEXCEPT
; 1903 : 		{	// look for _Right beginning before _Off
; 1904 : 		return (rfind(_Right._Myptr(), _Off, _Right.size()));
; 1905 : 		}
; 1906 : 
; 1907 : 	size_type rfind(const _Elem *_Ptr,
; 1908 : 		size_type _Off, size_type _Count) const
; 1909 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off
; 1910 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1911 : 		if (_Count == 0)
; 1912 : 			return (_Off < this->_Mysize() ? _Off
; 1913 : 				: this->_Mysize());	// null always matches
; 1914 : 		if (_Count <= this->_Mysize())
; 1915 : 			{	// room for match, look for it
; 1916 : 			const _Elem *_Uptr = this->_Myptr() +
; 1917 : 				(_Off < this->_Mysize() - _Count ? _Off
; 1918 : 					: this->_Mysize() - _Count);
; 1919 : 			for (; ; --_Uptr)
; 1920 : 				if (_Traits::eq(*_Uptr, *_Ptr)
; 1921 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
; 1922 : 					return (_Uptr - this->_Myptr());	// found a match
; 1923 : 				else if (_Uptr == this->_Myptr())
; 1924 : 					break;	// at beginning, no more chance for match
; 1925 : 			}
; 1926 : 
; 1927 : 		return (npos);	// no match
; 1928 : 		}
; 1929 : 
; 1930 : 	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
; 1931 : 		{	// look for [_Ptr, <null>) beginning before _Off
; 1932 : 		_DEBUG_POINTER(_Ptr);
; 1933 : 		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
; 1934 : 		}
; 1935 : 
; 1936 : 	size_type rfind(_Elem _Ch, size_type _Off = npos) const
; 1937 : 		{	// look for _Ch before _Off
; 1938 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 1939 : 		}
; 1940 : 
; 1941 : 	size_type find_first_of(const _Myt& _Right,
; 1942 : 		size_type _Off = 0) const _NOEXCEPT
; 1943 : 		{	// look for one of _Right at or after _Off
; 1944 : 		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
; 1945 : 		}
; 1946 : 
; 1947 : 	size_type find_first_of(const _Elem *_Ptr,
; 1948 : 		size_type _Off, size_type _Count) const
; 1949 : 		{	// look for one of [_Ptr, _Ptr + _Count) at or after _Off
; 1950 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1951 : 		if (0 < _Count && _Off < this->_Mysize())
; 1952 : 			{	// room for match, look for it
; 1953 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize();
; 1954 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 1955 : 				_Uptr < _Vptr; ++_Uptr)
; 1956 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1957 : 					return (_Uptr - this->_Myptr());	// found a match
; 1958 : 			}
; 1959 : 
; 1960 : 		return (npos);	// no match
; 1961 : 		}
; 1962 : 
; 1963 : 	size_type find_first_of(const _Elem *_Ptr,
; 1964 : 		size_type _Off = 0) const
; 1965 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 1966 : 		_DEBUG_POINTER(_Ptr);
; 1967 : 		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 1968 : 		}
; 1969 : 
; 1970 : 	size_type find_first_of(_Elem _Ch,
; 1971 : 		size_type _Off = 0) const
; 1972 : 		{	// look for _Ch at or after _Off
; 1973 : 		return (find((const _Elem *)&_Ch, _Off, 1));
; 1974 : 		}
; 1975 : 
; 1976 : 	size_type find_last_of(const _Myt& _Right,
; 1977 : 		size_type _Off = npos) const _NOEXCEPT
; 1978 : 		{	// look for one of _Right before _Off
; 1979 : 		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
; 1980 : 		}
; 1981 : 
; 1982 : 	size_type find_last_of(const _Elem *_Ptr,
; 1983 : 		size_type _Off, size_type _Count) const
; 1984 : 		{	// look for one of [_Ptr, _Ptr + _Count) before _Off
; 1985 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1986 : 		if (0 < _Count && 0 < this->_Mysize())
; 1987 : 			{	// worth searching, do it
; 1988 : 			const _Elem *_Uptr = this->_Myptr()
; 1989 : 				+ (_Off < this->_Mysize() ? _Off : this->_Mysize() - 1);
; 1990 : 			for (; ; --_Uptr)
; 1991 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
; 1992 : 					return (_Uptr - this->_Myptr());	// found a match
; 1993 : 				else if (_Uptr == this->_Myptr())
; 1994 : 					break;	// at beginning, no more chance for match
; 1995 : 			}
; 1996 : 
; 1997 : 		return (npos);	// no match
; 1998 : 		}
; 1999 : 
; 2000 : 	size_type find_last_of(const _Elem *_Ptr,
; 2001 : 		size_type _Off = npos) const
; 2002 : 		{	// look for one of [_Ptr, <null>) before _Off
; 2003 : 		_DEBUG_POINTER(_Ptr);
; 2004 : 		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2005 : 		}
; 2006 : 
; 2007 : 	size_type find_last_of(_Elem _Ch,
; 2008 : 		size_type _Off = npos) const
; 2009 : 		{	// look for _Ch before _Off
; 2010 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));
; 2011 : 		}
; 2012 : 
; 2013 : 	size_type find_first_not_of(const _Myt& _Right,
; 2014 : 		size_type _Off = 0) const _NOEXCEPT
; 2015 : 		{	// look for none of _Right at or after _Off
; 2016 : 		return (find_first_not_of(_Right._Myptr(), _Off,
; 2017 : 			_Right.size()));
; 2018 : 		}
; 2019 : 
; 2020 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2021 : 		size_type _Off, size_type _Count) const
; 2022 : 		{	// look for none of [_Ptr, _Ptr + _Count) at or after _Off
; 2023 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2024 : 		if (_Off < this->_Mysize())
; 2025 : 			{	// room for match, look for it
; 2026 : 			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize();
; 2027 : 			for (const _Elem *_Uptr = this->_Myptr() + _Off;
; 2028 : 				_Uptr < _Vptr; ++_Uptr)
; 2029 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2030 : 					return (_Uptr - this->_Myptr());
; 2031 : 			}
; 2032 : 		return (npos);
; 2033 : 		}
; 2034 : 
; 2035 : 	size_type find_first_not_of(const _Elem *_Ptr,
; 2036 : 		size_type _Off = 0) const
; 2037 : 		{	// look for one of [_Ptr, <null>) at or after _Off
; 2038 : 		_DEBUG_POINTER(_Ptr);
; 2039 : 		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2040 : 		}
; 2041 : 
; 2042 : 	size_type find_first_not_of(_Elem _Ch,
; 2043 : 		size_type _Off = 0) const
; 2044 : 		{	// look for non _Ch at or after _Off
; 2045 : 		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
; 2046 : 		}
; 2047 : 
; 2048 : 	size_type find_last_not_of(const _Myt& _Right,
; 2049 : 		size_type _Off = npos) const _NOEXCEPT
; 2050 : 		{	// look for none of _Right before _Off
; 2051 : 		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
; 2052 : 		}
; 2053 : 
; 2054 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2055 : 		size_type _Off, size_type _Count) const
; 2056 : 		{	// look for none of [_Ptr, _Ptr + _Count) before _Off
; 2057 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2058 : 		if (0 < this->_Mysize())
; 2059 : 			{	// worth searching, do it
; 2060 : 			const _Elem *_Uptr = this->_Myptr()
; 2061 : 				+ (_Off < this->_Mysize() ? _Off : this->_Mysize() - 1);
; 2062 : 			for (; ; --_Uptr)
; 2063 : 				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
; 2064 : 					return (_Uptr - this->_Myptr());
; 2065 : 				else if (_Uptr == this->_Myptr())
; 2066 : 					break;
; 2067 : 			}
; 2068 : 		return (npos);
; 2069 : 		}
; 2070 : 
; 2071 : 	size_type find_last_not_of(const _Elem *_Ptr,
; 2072 : 		size_type _Off = npos) const
; 2073 : 		{	// look for none of [_Ptr, <null>) before _Off
; 2074 : 		_DEBUG_POINTER(_Ptr);
; 2075 : 		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
; 2076 : 		}
; 2077 : 
; 2078 : 	size_type find_last_not_of(_Elem _Ch,
; 2079 : 		size_type _Off = npos) const
; 2080 : 		{	// look for non _Ch before _Off
; 2081 : 		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
; 2082 : 		}
; 2083 : 
; 2084 : 	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
; 2085 : 		{	// return [_Off, _Off + _Count) as new string
; 2086 : 		return (_Myt(*this, _Off, _Count, get_allocator()));
; 2087 : 		}
; 2088 : 
; 2089 : 	static int _Traits_compare(const _Elem * const _Left, const size_type _Left_size,
; 2090 : 		const _Elem * const _Right, const size_type _Right_size)
; 2091 : 		{	// compare [_Left, _Left + _Left_size) to [_Right, _Right + _Right_size) using _Traits
; 2092 : 		const size_type _Min_size = _Left_size < _Right_size ? _Left_size : _Right_size;
; 2093 : 		const int _Ans = _Traits::compare(_Left, _Right, _Min_size);
; 2094 : 
; 2095 : 		if (_Ans != 0)
; 2096 : 			return (_Ans);
; 2097 : 
; 2098 : 		if (_Left_size < _Right_size)
; 2099 : 			return (-1);
; 2100 : 
; 2101 : 		if (_Left_size > _Right_size)
; 2102 : 			return (1);
; 2103 : 
; 2104 : 		return (0);
; 2105 : 		}
; 2106 : 
; 2107 : 	size_type _Clamp_suffix_size(const size_type _Off, const size_type _Size) const
; 2108 : 		{	// trims _Size to the longest it can be assuming a string starting at _Off
; 2109 : 		const size_type _Max_effective_size = this->_Mysize() - _Off;
; 2110 : 		if (_Size <= _Max_effective_size)
; 2111 : 			return (_Size);
; 2112 : 		else
; 2113 : 			return (_Max_effective_size);
; 2114 : 		}
; 2115 : 
; 2116 : 	int compare(const _Myt& _Right) const _NOEXCEPT
; 2117 : 		{	// compare [0, _Mysize()) with _Right
; 2118 : 		return (_Traits_compare(this->_Myptr(), this->_Mysize(),
; 2119 : 			_Right._Myptr(), _Right._Mysize()));
; 2120 : 		}
; 2121 : 
; 2122 : 	int compare(size_type _Off,
; 2123 : 		size_type _N0, const _Myt& _Right) const
; 2124 : 		{	// compare [_Off, _Off + _N0) with _Right
; 2125 : 		_Check_offset(_Off);
; 2126 : 		return (_Traits_compare(this->_Myptr() + _Off, _Clamp_suffix_size(_Off, _N0),
; 2127 : 			_Right._Myptr(), _Right._Mysize()));
; 2128 : 		}
; 2129 : 
; 2130 : 	int compare(size_type _Off,
; 2131 : 		size_type _N0, const _Myt& _Right,
; 2132 : 		size_type _Roff, size_type _Count = npos) const
; 2133 : 		{	// compare [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)
; 2134 : 		_Check_offset(_Off);
; 2135 : 		_Right._Check_offset(_Roff);
; 2136 : 		return (_Traits_compare(this->_Myptr() + _Off, _Clamp_suffix_size(_Off, _N0),
; 2137 : 			_Right._Myptr() + _Roff, _Right._Clamp_suffix_size(_Roff, _Count)));
; 2138 : 		}
; 2139 : 
; 2140 : 	int compare(const _Elem *_Ptr) const
; 2141 : 		{	// compare [0, _Mysize()) with [_Ptr, <null>)
; 2142 : 		_DEBUG_POINTER(_Ptr);
; 2143 : 		return (_Traits_compare(this->_Myptr(), this->_Mysize(),
; 2144 : 			_Ptr, _Traits::length(_Ptr)));
; 2145 : 		}
; 2146 : 
; 2147 : 	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
; 2148 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, <null>)
; 2149 : 		_DEBUG_POINTER(_Ptr);
; 2150 : 		_Check_offset(_Off);
; 2151 : 		return (_Traits_compare(this->_Myptr() + _Off, _Clamp_suffix_size(_Off, _N0),
; 2152 : 			_Ptr, _Traits::length(_Ptr)));
; 2153 : 		}
; 2154 : 
; 2155 : 	int compare(size_type _Off,
; 2156 : 		size_type _N0, const _Elem *_Ptr, size_type _Count) const
; 2157 : 		{	// compare [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)
; 2158 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 2159 : 		_Check_offset(_Off);
; 2160 : 		return (_Traits_compare(this->_Myptr() + _Off, _Clamp_suffix_size(_Off, _N0),
; 2161 : 			_Ptr, _Count));
; 2162 : 		}
; 2163 : 
; 2164 : 	allocator_type get_allocator() const _NOEXCEPT
; 2165 : 		{	// return allocator object for values
; 2166 : 		return (this->_Getal());
; 2167 : 		}
; 2168 : 
; 2169 : 	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
; 2170 : 		{	// assign _Count copies of _Ch beginning at _Off
; 2171 : 		if (_Count == 1)
; 2172 : 			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
; 2173 : 		else
; 2174 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
; 2175 : 		}
; 2176 : 
; 2177 : 	void _Copy(size_type _Newsize, size_type _Oldlen)
; 2178 : 		{	// copy _Oldlen elements to newly allocated buffer
; 2179 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;
; 2180 : 		if (max_size() < _Newres)
; 2181 : 			_Newres = _Newsize;	// undo roundup if too big
; 2182 : 		else if (this->_Myres() / 2 <= _Newres / 3)
; 2183 : 			;
; 2184 : 		else if (this->_Myres() <= max_size() - this->_Myres() / 2)
; 2185 : 			_Newres = this->_Myres()
; 2186 : 				+ this->_Myres() / 2;	// grow exponentially if possible
; 2187 : 		else
; 2188 : 			_Newres = max_size();	// settle for max_size()
; 2189 : 
; 2190 : 		_Elem *_Ptr;
; 2191 : 		_TRY_BEGIN
; 2192 : 			_Ptr = this->_Getal().allocate(_Newres + 1);
; 2193 : 		_CATCH_ALL
; 2194 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry
; 2195 : 			_TRY_BEGIN
; 2196 : 				_Ptr = this->_Getal().allocate(_Newres + 1);
; 2197 : 			_CATCH_ALL

  00037	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0003c	53		 push	 rbx
  0003d	55		 push	 rbp
  0003e	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00042	48 8b ea	 mov	 rbp, rdx
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z$1:

; 728  : 		return (_Get_data()._Myres);

  00045	48 8b 5d 60	 mov	 rbx, QWORD PTR this$[rbp]

; 2246 : 		else if (this->_BUF_SIZE <= this->_Myres())

  00049	48 8b 53 20	 mov	 rdx, QWORD PTR [rbx+32]
  0004d	48 83 fa 10	 cmp	 rdx, 16
  00051	72 12		 jb	 SHORT $LN148@catch$0

; 2247 : 			{	// copy any leftovers to small buffer and deallocate
; 2248 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2249 : 			this->_Getal().destroy(&this->_Bx()._Ptr);
; 2250 : 			if (0 < _Newsize)
; 2251 : 				_Traits::copy(this->_Bx()._Buf,
; 2252 : 					_STD addressof(*_Ptr), _Newsize);
; 2253 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

  00053	48 ff c2	 inc	 rdx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 620  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00056	41 b8 01 00 00
	00		 mov	 r8d, 1
  0005c	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
  00060	e8 00 00 00 00	 call	 ?_Deallocate@std@@YAXPEAX_K1@Z ; std::_Deallocate
$LN148@catch$0:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2255 : 		this->_Myres() = this->_BUF_SIZE - 1;

  00065	48 c7 43 20 0f
	00 00 00	 mov	 QWORD PTR [rbx+32], 15

; 2214 : 		_Traits::assign(this->_Myptr()[this->_Mysize() = _Newsize], _Elem());

  0006d	48 c7 43 18 00
	00 00 00	 mov	 QWORD PTR [rbx+24], 0

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  00075	48 83 7b 20 10	 cmp	 QWORD PTR [rbx+32], 16
  0007a	72 06		 jb	 SHORT $LN252@catch$0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 708  : 	return (reinterpret_cast<_Ty *>(

  0007c	48 8b 5b 08	 mov	 rbx, QWORD PTR [rbx+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  00080	eb 04		 jmp	 SHORT $LN253@catch$0
$LN252@catch$0:
  00082	48 83 c3 08	 add	 rbx, 8
$LN253@catch$0:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  00086	c6 03 00	 mov	 BYTE PTR [rbx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2199 : 			_RERAISE;

  00089	33 d2		 xor	 edx, edx
  0008b	33 c9		 xor	 ecx, ecx
  0008d	e8 00 00 00 00	 call	 _CxxThrowException
  00092	90		 npad	 1
?catch$0@?0??_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z@4HA ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy'::`1'::catch$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0D@Z
_TEXT	SEGMENT
this$ = 8
_Off$ = 16
_Count$ = 24
_Ch$ = 32
?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0D@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Chassign, COMDAT

; 2170 : 		{	// assign _Count copies of _Ch beginning at _Off

  00000	48 8b c2	 mov	 rax, rdx

; 2171 : 		if (_Count == 1)

  00003	49 83 f8 01	 cmp	 r8, 1
  00007	75 19		 jne	 SHORT $LN2@Chassign

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  00009	48 83 79 20 10	 cmp	 QWORD PTR [rcx+32], 16
  0000e	72 09		 jb	 SHORT $LN15@Chassign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 708  : 	return (reinterpret_cast<_Ty *>(

  00010	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  00014	44 88 0c 11	 mov	 BYTE PTR [rcx+rdx], r9b
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2175 : 		}

  00018	c3		 ret	 0
$LN15@Chassign:

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  00019	48 83 c1 08	 add	 rcx, 8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  0001d	44 88 0c 11	 mov	 BYTE PTR [rcx+rdx], r9b
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2175 : 		}

  00021	c3		 ret	 0
$LN2@Chassign:

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  00022	48 83 79 20 10	 cmp	 QWORD PTR [rcx+32], 16
  00027	72 10		 jb	 SHORT $LN36@Chassign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 708  : 	return (reinterpret_cast<_Ty *>(

  00029	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2174 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);

  0002d	48 03 c8	 add	 rcx, rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 560  : 		return ((_Elem *)_CSTD memset(_First, _Ch, _Count));

  00030	41 0f be d1	 movsx	 edx, r9b
  00034	e9 00 00 00 00	 jmp	 memset
$LN36@Chassign:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  00039	48 83 c1 08	 add	 rcx, 8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 560  : 		return ((_Elem *)_CSTD memset(_First, _Ch, _Count));

  0003d	41 0f be d1	 movsx	 edx, r9b
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2174 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);

  00041	48 03 c8	 add	 rcx, rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 560  : 		return ((_Elem *)_CSTD memset(_First, _Ch, _Count));

  00044	e9 00 00 00 00	 jmp	 memset
?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0D@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Chassign
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT

; 1747 : 		const size_type _Num = this->_Getal().max_size();
; 1748 : 		return (_Num <= 1 ? 1 : _Num - 1);

  00000	48 c7 c0 fe ff
	ff ff		 mov	 rax, -2

; 1749 : 		}

  00007	c3		 ret	 0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT

; 1742 : 		return (this->_Mysize());

  00000	48 8b 41 18	 mov	 rax, QWORD PTR [rcx+24]

; 1743 : 		}

  00004	c3		 ret	 0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
__$ReturnUdt$ = 72
?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin, COMDAT

; 1589 : 		{	// return iterator for beginning of mutable sequence

$LN35:
  00000	40 57		 push	 rdi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  0000f	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00014	48 8b da	 mov	 rbx, rdx

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  00017	48 83 79 20 10	 cmp	 QWORD PTR [rcx+32], 16
  0001c	72 06		 jb	 SHORT $LN19@begin
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 716  : 	return (_Addressof(_Val, is_function<_Ty>()));

  0001e	48 8b 79 08	 mov	 rdi, QWORD PTR [rcx+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  00022	eb 04		 jmp	 SHORT $LN20@begin
$LN19@begin:
  00024	48 8d 79 08	 lea	 rdi, QWORD PTR [rcx+8]
$LN20@begin:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 113  : 		: _Myproxy(0), _Mynextiter(0)

  00028	33 c0		 xor	 eax, eax
  0002a	48 89 02	 mov	 QWORD PTR [rdx], rax
  0002d	48 89 42 08	 mov	 QWORD PTR [rdx+8], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 49   : 		this->_Adopt(_Pstring);

  00031	48 8b d1	 mov	 rdx, rcx
  00034	48 8b cb	 mov	 rcx, rbx
  00037	e8 00 00 00 00	 call	 ?_Adopt@_Iterator_base12@std@@QEAAXPEBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt
  0003c	90		 npad	 1

; 50   : 		_Ptr = _Parg;

  0003d	48 89 7b 10	 mov	 QWORD PTR [rbx+16], rdi

; 1590 : 		return (iterator(this->_Myptr(), &this->_Get_data()));

  00041	48 8b c3	 mov	 rax, rbx

; 1591 : 		}

  00044	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00049	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0004d	5f		 pop	 rdi
  0004e	c3		 ret	 0
?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K0@Z
_TEXT	SEGMENT
this$ = 48
_Off$ = 56
_Count$ = 64
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K0@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT

; 1342 : 		{	// erase elements [_Off, _Off + _Count)

$LN128:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	56		 push	 rsi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 2266 : 		if (this->_Mysize() < _Off)

  0000a	48 8b 71 18	 mov	 rsi, QWORD PTR [rcx+24]

; 1342 : 		{	// erase elements [_Off, _Off + _Count)

  0000e	48 8b d9	 mov	 rbx, rcx

; 2266 : 		if (this->_Mysize() < _Off)

  00011	48 3b f2	 cmp	 rsi, rdx
  00014	73 0e		 jae	 SHORT $LN7@erase

; 2278 : 		_Xout_of_range("invalid string position");

  00016	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  0001d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Xout_of_range@std@@YAXPEBD@Z
  00023	cc		 int	 3
$LN7@erase:

; 1343 : 		_Check_offset(_Off);
; 1344 : 		if (this->_Mysize() - _Off <= _Count)

  00024	48 8b c6	 mov	 rax, rsi
  00027	48 2b c2	 sub	 rax, rdx
  0002a	49 3b c0	 cmp	 rax, r8
  0002d	77 37		 ja	 SHORT $LN2@erase

; 2214 : 		_Traits::assign(this->_Myptr()[this->_Mysize() = _Newsize], _Elem());

  0002f	48 89 51 18	 mov	 QWORD PTR [rcx+24], rdx

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  00033	48 83 79 20 10	 cmp	 QWORD PTR [rcx+32], 16
  00038	72 16		 jb	 SHORT $LN52@erase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 708  : 	return (reinterpret_cast<_Ty *>(

  0003a	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  0003e	c6 04 10 00	 mov	 BYTE PTR [rax+rdx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1353 : 		return (*this);

  00042	48 8b c3	 mov	 rax, rbx

; 1354 : 		}

  00045	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0004a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004e	5e		 pop	 rsi
  0004f	c3		 ret	 0
$LN52@erase:

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  00050	48 8d 41 08	 lea	 rax, QWORD PTR [rcx+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  00054	c6 04 10 00	 mov	 BYTE PTR [rax+rdx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1353 : 		return (*this);

  00058	48 8b c3	 mov	 rax, rbx

; 1354 : 		}

  0005b	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00060	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00064	5e		 pop	 rsi
  00065	c3		 ret	 0
$LN2@erase:

; 1345 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1346 : 		else if (0 < _Count)

  00066	4d 85 c0	 test	 r8, r8
  00069	74 4b		 je	 SHORT $LN124@erase

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  0006b	48 83 79 20 10	 cmp	 QWORD PTR [rcx+32], 16
  00070	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  00075	48 8d 79 08	 lea	 rdi, QWORD PTR [rcx+8]
  00079	72 05		 jb	 SHORT $LN73@erase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 708  : 	return (reinterpret_cast<_Ty *>(

  0007b	48 8b 07	 mov	 rax, QWORD PTR [rdi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  0007e	eb 03		 jmp	 SHORT $LN74@erase
$LN73@erase:
  00080	48 8b c7	 mov	 rax, rdi
$LN74@erase:

; 1347 : 			{	// move elements down
; 1348 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1349 : 			size_type _Newsize = this->_Mysize() - _Count;

  00083	49 2b f0	 sub	 rsi, r8
  00086	48 8d 0c 10	 lea	 rcx, QWORD PTR [rax+rdx]

; 1350 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

  0008a	48 8b c6	 mov	 rax, rsi
  0008d	48 2b c2	 sub	 rax, rdx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

  00090	74 0d		 je	 SHORT $LN93@erase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1350 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

  00092	4a 8d 14 01	 lea	 rdx, QWORD PTR [rcx+r8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

  00096	4c 8b c0	 mov	 r8, rax
  00099	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
$LN93@erase:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2214 : 		_Traits::assign(this->_Myptr()[this->_Mysize() = _Newsize], _Elem());

  0009f	48 89 73 18	 mov	 QWORD PTR [rbx+24], rsi

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  000a3	48 83 7b 20 10	 cmp	 QWORD PTR [rbx+32], 16
  000a8	72 03		 jb	 SHORT $LN115@erase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 708  : 	return (reinterpret_cast<_Ty *>(

  000aa	48 8b 3f	 mov	 rdi, QWORD PTR [rdi]
$LN115@erase:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  000ad	c6 04 37 00	 mov	 BYTE PTR [rdi+rsi], 0
  000b1	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
$LN124@erase:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1353 : 		return (*this);

  000b6	48 8b c3	 mov	 rax, rbx

; 1354 : 		}

  000b9	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  000be	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000c2	5e		 pop	 rsi
  000c3	c3		 ret	 0
$LN127@erase:
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K0@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z
_TEXT	SEGMENT
this$ = 48
_Count$ = 56
_Ch$ = 64
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT

; 1181 : 		{	// assign _Count * _Ch

$LN188:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	41 0f b6 e8	 movzx	 ebp, r8b
  00013	48 8b fa	 mov	 rdi, rdx
  00016	48 8b d9	 mov	 rbx, rcx

; 1182 : 		if (_Count == npos)

  00019	48 83 fa ff	 cmp	 rdx, -1
  0001d	75 0e		 jne	 SHORT $LN2@assign

; 2261 : 		_Xlength_error("string too long");

  0001f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00026	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
  0002c	cc		 int	 3
$LN2@assign:

; 2220 : 		if (max_size() < _Newsize)

  0002d	48 83 fa fe	 cmp	 rdx, -2
  00031	76 0e		 jbe	 SHORT $LN9@assign

; 2261 : 		_Xlength_error("string too long");

  00033	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  0003a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
  00040	cc		 int	 3
$LN9@assign:

; 2222 : 		if (this->_Myres() < _Newsize)

  00041	48 39 51 20	 cmp	 QWORD PTR [rcx+32], rdx
  00045	73 30		 jae	 SHORT $LN10@assign

; 2223 : 			_Copy(_Newsize, this->_Mysize());	// reallocate to grow

  00047	4c 8b 41 18	 mov	 r8, QWORD PTR [rcx+24]
  0004b	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
$LN107@assign:

; 2228 : 			_Eos(0);	// new size is zero, just null terminate
; 2229 : 		return (0 < _Newsize);	// return true only if more work to do

  00050	48 85 ff	 test	 rdi, rdi

; 1183 : 			_Xlen();	// result too long
; 1184 : 
; 1185 : 		if (_Grow(_Count))

  00053	0f 84 9b 00 00
	00		 je	 $LN184@assign
  00059	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  0005e	48 8d 73 08	 lea	 rsi, QWORD PTR [rbx+8]

; 2171 : 		if (_Count == 1)

  00062	48 83 ff 01	 cmp	 rdi, 1
  00066	75 5a		 jne	 SHORT $LN110@assign

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  00068	48 83 7b 20 10	 cmp	 QWORD PTR [rbx+32], 16
  0006d	72 4b		 jb	 SHORT $LN123@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 708  : 	return (reinterpret_cast<_Ty *>(

  0006f	48 8b 06	 mov	 rax, QWORD PTR [rsi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  00072	40 88 28	 mov	 BYTE PTR [rax], bpl
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2173 : 		else

  00075	eb 66		 jmp	 SHORT $LN111@assign
$LN10@assign:

; 2227 : 		else if (_Newsize == 0)

  00077	48 85 d2	 test	 rdx, rdx
  0007a	75 d4		 jne	 SHORT $LN107@assign

; 2214 : 		_Traits::assign(this->_Myptr()[this->_Mysize() = _Newsize], _Elem());

  0007c	48 89 51 18	 mov	 QWORD PTR [rcx+24], rdx

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  00080	48 83 79 20 10	 cmp	 QWORD PTR [rcx+32], 16
  00085	72 19		 jb	 SHORT $LN98@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 708  : 	return (reinterpret_cast<_Ty *>(

  00087	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  0008b	88 10		 mov	 BYTE PTR [rax], dl
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1190 : 		return (*this);

  0008d	48 8b c3	 mov	 rax, rbx

; 1191 : 		}

  00090	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00095	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  0009a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0009e	5f		 pop	 rdi
  0009f	c3		 ret	 0
$LN98@assign:

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  000a0	48 8d 41 08	 lea	 rax, QWORD PTR [rcx+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  000a4	c6 00 00	 mov	 BYTE PTR [rax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1190 : 		return (*this);

  000a7	48 8b c3	 mov	 rax, rbx

; 1191 : 		}

  000aa	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  000af	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  000b4	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b8	5f		 pop	 rdi
  000b9	c3		 ret	 0
$LN123@assign:

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  000ba	48 8b c6	 mov	 rax, rsi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  000bd	40 88 28	 mov	 BYTE PTR [rax], bpl
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2173 : 		else

  000c0	eb 1b		 jmp	 SHORT $LN111@assign
$LN110@assign:

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  000c2	48 83 7b 20 10	 cmp	 QWORD PTR [rbx+32], 16
  000c7	72 05		 jb	 SHORT $LN144@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 708  : 	return (reinterpret_cast<_Ty *>(

  000c9	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  000cc	eb 03		 jmp	 SHORT $LN145@assign
$LN144@assign:
  000ce	48 8b ce	 mov	 rcx, rsi
$LN145@assign:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 560  : 		return ((_Elem *)_CSTD memset(_First, _Ch, _Count));

  000d1	40 0f be d5	 movsx	 edx, bpl
  000d5	4c 8b c7	 mov	 r8, rdi
  000d8	e8 00 00 00 00	 call	 memset
$LN111@assign:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2214 : 		_Traits::assign(this->_Myptr()[this->_Mysize() = _Newsize], _Elem());

  000dd	48 89 7b 18	 mov	 QWORD PTR [rbx+24], rdi

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  000e1	48 83 7b 20 10	 cmp	 QWORD PTR [rbx+32], 16
  000e6	72 03		 jb	 SHORT $LN175@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 708  : 	return (reinterpret_cast<_Ty *>(

  000e8	48 8b 36	 mov	 rsi, QWORD PTR [rsi]
$LN175@assign:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  000eb	c6 04 3e 00	 mov	 BYTE PTR [rsi+rdi], 0
  000ef	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
$LN184@assign:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1191 : 		}

  000f4	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  000f9	48 8b c3	 mov	 rax, rbx
  000fc	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00101	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00105	5f		 pop	 rdi
  00106	c3		 ret	 0
$LN187@assign:
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z
_TEXT	SEGMENT
this$ = 48
_Count$ = 56
_Ch$ = 64
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT

; 1106 : 		{	// append _Count * _Ch

$LN218:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  0000a	41 56		 push	 r14
  0000c	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1107 : 		if (npos - this->_Mysize() <= _Count)

  00010	48 83 c8 ff	 or	 rax, -1
  00014	45 0f b6 f0	 movzx	 r14d, r8b
  00018	4c 8b 41 18	 mov	 r8, QWORD PTR [rcx+24]
  0001c	48 8b ea	 mov	 rbp, rdx
  0001f	49 2b c0	 sub	 rax, r8
  00022	48 8b d9	 mov	 rbx, rcx
  00025	48 3b c2	 cmp	 rax, rdx
  00028	77 0e		 ja	 SHORT $LN2@append

; 2261 : 		_Xlength_error("string too long");

  0002a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
  00037	cc		 int	 3
$LN2@append:
  00038	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi

; 1108 : 			_Xlen();	// result too long
; 1109 : 
; 1110 : 		const size_type _Num = this->_Mysize() + _Count;

  0003d	49 8d 34 10	 lea	 rsi, QWORD PTR [r8+rdx]

; 1111 : 		if (0 < _Count && _Grow(_Num))

  00041	48 85 d2	 test	 rdx, rdx
  00044	0f 84 ae 00 00
	00		 je	 $LN211@append

; 2220 : 		if (max_size() < _Newsize)

  0004a	48 83 fe fe	 cmp	 rsi, -2
  0004e	76 0e		 jbe	 SHORT $LN27@append

; 2261 : 		_Xlength_error("string too long");

  00050	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  00057	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
  0005d	cc		 int	 3
$LN27@append:

; 2222 : 		if (this->_Myres() < _Newsize)

  0005e	48 39 71 20	 cmp	 QWORD PTR [rcx+32], rsi
  00062	73 34		 jae	 SHORT $LN28@append

; 2223 : 			_Copy(_Newsize, this->_Mysize());	// reallocate to grow

  00064	48 8b d6	 mov	 rdx, rsi
  00067	e8 00 00 00 00	 call	 ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy

; 2229 : 		return (0 < _Newsize);	// return true only if more work to do

  0006c	48 85 f6	 test	 rsi, rsi

; 1111 : 		if (0 < _Count && _Grow(_Num))

  0006f	0f 84 83 00 00
	00		 je	 $LN211@append
$LN216@append:

; 1112 : 			{	// make room and append new stuff using assign
; 1113 : 			_Chassign(this->_Mysize(), _Count, _Ch);

  00075	48 8b 4b 18	 mov	 rcx, QWORD PTR [rbx+24]
  00079	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  0007e	48 8d 7b 08	 lea	 rdi, QWORD PTR [rbx+8]

; 2171 : 		if (_Count == 1)

  00082	48 83 fd 01	 cmp	 rbp, 1
  00086	75 3b		 jne	 SHORT $LN137@append

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  00088	48 83 7b 20 10	 cmp	 QWORD PTR [rbx+32], 16
  0008d	72 2b		 jb	 SHORT $LN150@append
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 708  : 	return (reinterpret_cast<_Ty *>(

  0008f	48 8b 07	 mov	 rax, QWORD PTR [rdi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  00092	44 88 34 08	 mov	 BYTE PTR [rax+rcx], r14b
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2173 : 		else

  00096	eb 49		 jmp	 SHORT $LN138@append
$LN28@append:

; 2227 : 		else if (_Newsize == 0)

  00098	48 85 f6	 test	 rsi, rsi
  0009b	75 d8		 jne	 SHORT $LN216@append

; 2214 : 		_Traits::assign(this->_Myptr()[this->_Mysize() = _Newsize], _Elem());

  0009d	48 89 71 18	 mov	 QWORD PTR [rcx+24], rsi

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  000a1	48 83 79 20 10	 cmp	 QWORD PTR [rcx+32], 16
  000a6	72 09		 jb	 SHORT $LN116@append
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 708  : 	return (reinterpret_cast<_Ty *>(

  000a8	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  000ac	40 88 30	 mov	 BYTE PTR [rax], sil
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2229 : 		return (0 < _Newsize);	// return true only if more work to do

  000af	eb 47		 jmp	 SHORT $LN211@append
$LN116@append:

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  000b1	48 8d 41 08	 lea	 rax, QWORD PTR [rcx+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  000b5	c6 00 00	 mov	 BYTE PTR [rax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2229 : 		return (0 < _Newsize);	// return true only if more work to do

  000b8	eb 3e		 jmp	 SHORT $LN211@append
$LN150@append:

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  000ba	48 8b c7	 mov	 rax, rdi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  000bd	44 88 34 08	 mov	 BYTE PTR [rax+rcx], r14b
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2173 : 		else

  000c1	eb 1e		 jmp	 SHORT $LN138@append
$LN137@append:

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  000c3	48 83 7b 20 10	 cmp	 QWORD PTR [rbx+32], 16
  000c8	72 05		 jb	 SHORT $LN171@append
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 708  : 	return (reinterpret_cast<_Ty *>(

  000ca	48 8b 07	 mov	 rax, QWORD PTR [rdi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  000cd	eb 03		 jmp	 SHORT $LN172@append
$LN171@append:
  000cf	48 8b c7	 mov	 rax, rdi
$LN172@append:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 560  : 		return ((_Elem *)_CSTD memset(_First, _Ch, _Count));

  000d2	41 0f be d6	 movsx	 edx, r14b
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2174 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);

  000d6	48 03 c8	 add	 rcx, rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 560  : 		return ((_Elem *)_CSTD memset(_First, _Ch, _Count));

  000d9	4c 8b c5	 mov	 r8, rbp
  000dc	e8 00 00 00 00	 call	 memset
$LN138@append:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2214 : 		_Traits::assign(this->_Myptr()[this->_Mysize() = _Newsize], _Elem());

  000e1	48 89 73 18	 mov	 QWORD PTR [rbx+24], rsi

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  000e5	48 83 7b 20 10	 cmp	 QWORD PTR [rbx+32], 16
  000ea	72 03		 jb	 SHORT $LN202@append
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 708  : 	return (reinterpret_cast<_Ty *>(

  000ec	48 8b 3f	 mov	 rdi, QWORD PTR [rdi]
$LN202@append:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  000ef	c6 04 37 00	 mov	 BYTE PTR [rdi+rsi], 0
  000f3	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]
$LN211@append:
  000f8	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1116 : 		return (*this);

  000fd	48 8b c3	 mov	 rax, rbx

; 1117 : 		}

  00100	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00105	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  0010a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0010e	41 5e		 pop	 r14
  00110	c3		 ret	 0
$LN217@append:
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 1011 : 		{	// destroy the string

$LN130:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  0000f	48 8b d9	 mov	 rbx, rcx

; 2246 : 		else if (this->_BUF_SIZE <= this->_Myres())

  00012	48 8b 51 20	 mov	 rdx, QWORD PTR [rcx+32]
  00016	48 83 fa 10	 cmp	 rdx, 16
  0001a	72 13		 jb	 SHORT $LN6@basic_stri

; 2247 : 			{	// copy any leftovers to small buffer and deallocate
; 2248 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2249 : 			this->_Getal().destroy(&this->_Bx()._Ptr);
; 2250 : 			if (0 < _Newsize)
; 2251 : 				_Traits::copy(this->_Bx()._Buf,
; 2252 : 					_STD addressof(*_Ptr), _Newsize);
; 2253 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

  0001c	48 ff c2	 inc	 rdx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 620  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  0001f	41 b8 01 00 00
	00		 mov	 r8d, 1
  00025	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00029	e8 00 00 00 00	 call	 ?_Deallocate@std@@YAXPEAX_K1@Z ; std::_Deallocate
  0002e	90		 npad	 1
$LN6@basic_stri:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2255 : 		this->_Myres() = this->_BUF_SIZE - 1;

  0002f	48 c7 43 20 0f
	00 00 00	 mov	 QWORD PTR [rbx+32], 15

; 2214 : 		_Traits::assign(this->_Myptr()[this->_Mysize() = _Newsize], _Elem());

  00037	48 c7 43 18 00
	00 00 00	 mov	 QWORD PTR [rbx+24], 0

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  0003f	48 83 7b 20 10	 cmp	 QWORD PTR [rbx+32], 16
  00044	72 06		 jb	 SHORT $LN110@basic_stri
  00046	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
  0004a	eb 04		 jmp	 SHORT $LN111@basic_stri
$LN110@basic_stri:
  0004c	48 8d 43 08	 lea	 rax, QWORD PTR [rbx+8]
$LN111@basic_stri:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  00050	c6 00 00	 mov	 BYTE PTR [rax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 616  : 		_Free_proxy();

  00053	48 8b cb	 mov	 rcx, rbx
  00056	e8 00 00 00 00	 call	 ?_Free_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAXXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Free_proxy
  0005b	90		 npad	 1
  0005c	48 8b cb	 mov	 rcx, rbx
  0005f	e8 00 00 00 00	 call	 ??1_Container_base12@std@@QEAA@XZ ; std::_Container_base12::~_Container_base12
  00064	90		 npad	 1

; 1012 : 		_Tidy(true);
; 1013 : 		}

  00065	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00069	5b		 pop	 rbx
  0006a	c3		 ret	 0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
?dtor$32@?0???1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$32
  00000	e9 00 00 00 00	 jmp	 __std_terminate
?dtor$32@?0???1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$32
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
?dtor$32@?0???1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$32
  00000	e9 00 00 00 00	 jmp	 __std_terminate
?dtor$32@?0???1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ@4HA ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$32
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_Count$ = 72
_Ch$ = 80
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 844  : 		{	// construct from _Count * _Ch

$LN197:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  00013	48 89 5c 24 48	 mov	 QWORD PTR [rsp+72], rbx
  00018	48 89 6c 24 50	 mov	 QWORD PTR [rsp+80], rbp
  0001d	48 89 74 24 58	 mov	 QWORD PTR [rsp+88], rsi
  00022	41 0f b6 f8	 movzx	 edi, r8b
  00026	48 8b f2	 mov	 rsi, rdx
  00029	48 8b d9	 mov	 rbx, rcx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 79   : 		: _Myproxy(0)

  0002c	33 ed		 xor	 ebp, ebp
  0002e	48 89 29	 mov	 QWORD PTR [rcx], rbp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 488  : 		_Mysize = 0;

  00031	48 89 69 18	 mov	 QWORD PTR [rcx+24], rbp

; 489  : 		_Myres = 0;

  00035	48 89 69 20	 mov	 QWORD PTR [rcx+32], rbp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 625  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

  00039	41 b0 01	 mov	 r8b, 1
  0003c	8d 55 10	 lea	 edx, QWORD PTR [rbp+16]
  0003f	8d 4d 01	 lea	 ecx, QWORD PTR [rbp+1]
  00042	e8 00 00 00 00	 call	 ?_Allocate@std@@YAPEAX_K0_N@Z ; std::_Allocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 643  : 		_Myproxy() = _Alproxy.allocate(1);

  00047	48 89 03	 mov	 QWORD PTR [rbx], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 637  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  0004a	48 85 c0	 test	 rax, rax
  0004d	74 06		 je	 SHORT $LN57@basic_stri
  0004f	0f 57 c0	 xorps	 xmm0, xmm0
  00052	0f 11 00	 movups	 XMMWORD PTR [rax], xmm0
$LN57@basic_stri:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 645  : 		_Myproxy()->_Mycont = &_Get_data();

  00055	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00058	48 89 18	 mov	 QWORD PTR [rax], rbx

; 2255 : 		this->_Myres() = this->_BUF_SIZE - 1;

  0005b	48 c7 43 20 0f
	00 00 00	 mov	 QWORD PTR [rbx+32], 15

; 2214 : 		_Traits::assign(this->_Myptr()[this->_Mysize() = _Newsize], _Elem());

  00063	48 89 6b 18	 mov	 QWORD PTR [rbx+24], rbp

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  00067	48 83 7b 20 10	 cmp	 QWORD PTR [rbx+32], 16
  0006c	72 06		 jb	 SHORT $LN186@basic_stri
  0006e	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
  00072	eb 04		 jmp	 SHORT $LN187@basic_stri
$LN186@basic_stri:
  00074	48 8d 43 08	 lea	 rax, QWORD PTR [rbx+8]
$LN187@basic_stri:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  00078	c6 00 00	 mov	 BYTE PTR [rax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 846  : 		assign(_Count, _Ch);

  0007b	44 0f b6 c7	 movzx	 r8d, dil
  0007f	48 8b d6	 mov	 rdx, rsi
  00082	48 8b cb	 mov	 rcx, rbx
  00085	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  0008a	90		 npad	 1

; 847  : 		}

  0008b	48 8b c3	 mov	 rax, rbx
  0008e	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00093	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  00098	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  0009d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000a1	5f		 pop	 rdi
  000a2	c3		 ret	 0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
_Count$ = 72
_Ch$ = 80
?dtor$1@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z@4HA PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$1
  00000	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
?dtor$1@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z@4HA ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$1
$T1 = 32
this$ = 64
_Count$ = 72
_Ch$ = 80
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z@4HA PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
  0000c	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00013	e9 00 00 00 00	 jmp	 ??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAA@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z@4HA ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
_Count$ = 72
_Ch$ = 80
?dtor$1@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z@4HA PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$1
  00000	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
?dtor$1@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z@4HA ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
_Count$ = 72
_Ch$ = 80
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z@4HA PROC ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
  0000c	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00013	e9 00 00 00 00	 jmp	 ??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAA@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >
?dtor$0@?0???0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z@4HA ENDP ; `std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 788  : 		{	// construct empty string

$LN196:
  00000	40 57		 push	 rdi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  0000f	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00014	48 8b d9	 mov	 rbx, rcx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 79   : 		: _Myproxy(0)

  00017	33 ff		 xor	 edi, edi
  00019	48 89 39	 mov	 QWORD PTR [rcx], rdi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 488  : 		_Mysize = 0;

  0001c	48 89 79 18	 mov	 QWORD PTR [rcx+24], rdi

; 489  : 		_Myres = 0;

  00020	48 89 79 20	 mov	 QWORD PTR [rcx+32], rdi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 625  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

  00024	41 b0 01	 mov	 r8b, 1
  00027	8d 57 10	 lea	 edx, QWORD PTR [rdi+16]
  0002a	8d 4f 01	 lea	 ecx, QWORD PTR [rdi+1]
  0002d	e8 00 00 00 00	 call	 ?_Allocate@std@@YAPEAX_K0_N@Z ; std::_Allocate
  00032	90		 npad	 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 643  : 		_Myproxy() = _Alproxy.allocate(1);

  00033	48 89 03	 mov	 QWORD PTR [rbx], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 637  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00036	48 85 c0	 test	 rax, rax
  00039	74 06		 je	 SHORT $LN55@basic_stri
  0003b	0f 57 c0	 xorps	 xmm0, xmm0
  0003e	0f 11 00	 movups	 XMMWORD PTR [rax], xmm0
$LN55@basic_stri:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 645  : 		_Myproxy()->_Mycont = &_Get_data();

  00041	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00044	48 89 18	 mov	 QWORD PTR [rax], rbx

; 2255 : 		this->_Myres() = this->_BUF_SIZE - 1;

  00047	48 c7 43 20 0f
	00 00 00	 mov	 QWORD PTR [rbx+32], 15

; 2214 : 		_Traits::assign(this->_Myptr()[this->_Mysize() = _Newsize], _Elem());

  0004f	48 89 7b 18	 mov	 QWORD PTR [rbx+24], rdi

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  00053	48 83 7b 20 10	 cmp	 QWORD PTR [rbx+32], 16
  00058	72 09		 jb	 SHORT $LN184@basic_stri
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 708  : 	return (reinterpret_cast<_Ty *>(

  0005a	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  0005e	40 88 38	 mov	 BYTE PTR [rax], dil
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  00061	eb 04		 jmp	 SHORT $LN195@basic_stri
$LN184@basic_stri:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

  00063	40 88 7b 08	 mov	 BYTE PTR [rbx+8], dil
$LN195@basic_stri:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 790  : 		}

  00067	48 8b c3	 mov	 rax, rbx
  0006a	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0006f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00073	5f		 pop	 rdi
  00074	c3		 ret	 0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>, COMDAT
  00000	e9 00 00 00 00	 jmp	 ??1_Container_base12@std@@QEAA@XZ ; std::_Container_base12::~_Container_base12
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second, COMDAT

; 319  : 		return (_Myval2);

  00000	48 8b c1	 mov	 rax, rcx

; 320  : 		}

  00003	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second, COMDAT

; 314  : 		return (_Myval2);

  00000	48 8b c1	 mov	 rax, rcx

; 315  : 		}

  00003	c3		 ret	 0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT

; 299  : 		return (*this);

  00000	48 8b c1	 mov	 rax, rcx

; 300  : 		}

  00003	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT

; 294  : 		return (*this);

  00000	48 8b c1	 mov	 rax, rcx

; 295  : 		}

  00003	c3		 ret	 0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAAEA_KXZ
_TEXT	SEGMENT
this$ = 8
?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAAEA_KXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres, COMDAT

; 728  : 		return (_Get_data()._Myres);

  00000	48 8d 41 20	 lea	 rax, QWORD PTR [rcx+32]

; 729  : 		}

  00004	c3		 ret	 0
?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAAEA_KXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEBAAEB_KXZ
_TEXT	SEGMENT
this$ = 8
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEBAAEB_KXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize, COMDAT

; 723  : 		return (_Get_data()._Mysize);

  00000	48 8d 41 18	 lea	 rax, QWORD PTR [rcx+24]

; 724  : 		}

  00004	c3		 ret	 0
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEBAAEB_KXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAAEA_KXZ
_TEXT	SEGMENT
this$ = 8
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAAEA_KXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize, COMDAT

; 718  : 		return (_Get_data()._Mysize);

  00000	48 8d 41 18	 lea	 rax, QWORD PTR [rcx+24]

; 719  : 		}

  00004	c3		 ret	 0
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAAEA_KXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Bx@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAAEAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Bx@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAAEAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Bx, COMDAT

; 708  : 		return (_Get_data()._Bx);

  00000	48 8d 41 08	 lea	 rax, QWORD PTR [rcx+8]

; 709  : 		}

  00004	c3		 ret	 0
?_Bx@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAAEAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Bx
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEBAAEBV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEBAAEBV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data, COMDAT

; 701  : 		return (_Mypair._Get_second());

  00000	48 8b c1	 mov	 rax, rcx

; 702  : 		}

  00003	c3		 ret	 0
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEBAAEBV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAAEAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAAEAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data, COMDAT

; 696  : 		return (_Mypair._Get_second());

  00000	48 8b c1	 mov	 rax, rcx

; 697  : 		}

  00003	c3		 ret	 0
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAAEAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT

; 691  : 		return (_Mypair._Get_first());

  00000	48 8b c1	 mov	 rax, rcx

; 692  : 		}

  00003	c3		 ret	 0
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEBAAEBU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT

; 686  : 		return (_Mypair._Get_first());

  00000	48 8b c1	 mov	 rax, rcx

; 687  : 		}

  00003	c3		 ret	 0
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAAEAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Orphan_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
_Lock$1 = 48
this$ = 48
?_Orphan_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAXXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Orphan_all, COMDAT

; 675  : 		{	// orphan all iterators

$LN21:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 216  : 	if (_Myproxy != 0)

  00006	48 83 39 00	 cmp	 QWORD PTR [rcx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 675  : 		{	// orphan all iterators

  0000a	48 8b d9	 mov	 rbx, rcx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 216  : 	if (_Myproxy != 0)

  0000d	74 4b		 je	 SHORT $LN13@Orphan_all

; 217  : 		{	// proxy allocated, drain it
; 218  : 		_Lockit _Lock(_LOCK_DEBUG);

  0000f	ba 03 00 00 00	 mov	 edx, 3
  00014	48 8d 4c 24 30	 lea	 rcx, QWORD PTR _Lock$1[rsp]
  00019	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0_Lockit@std@@QEAA@H@Z

; 219  : 
; 220  : 		for (_Iterator_base12 **_Pnext = &_Myproxy->_Myfirstiter;

  0001f	48 8b 13	 mov	 rdx, QWORD PTR [rbx]

; 221  : 			*_Pnext != 0; *_Pnext = (*_Pnext)->_Mynextiter)

  00022	45 33 c0	 xor	 r8d, r8d
  00025	4c 39 42 08	 cmp	 QWORD PTR [rdx+8], r8
  00029	74 1d		 je	 SHORT $LN11@Orphan_all
  0002b	0f 1f 44 00 00	 npad	 5
$LL12@Orphan_all:

; 222  : 			(*_Pnext)->_Myproxy = 0;

  00030	48 8b 42 08	 mov	 rax, QWORD PTR [rdx+8]
  00034	4c 89 00	 mov	 QWORD PTR [rax], r8
  00037	48 8b 42 08	 mov	 rax, QWORD PTR [rdx+8]
  0003b	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0003f	48 89 4a 08	 mov	 QWORD PTR [rdx+8], rcx
  00043	48 85 c9	 test	 rcx, rcx
  00046	75 e8		 jne	 SHORT $LL12@Orphan_all
$LN11@Orphan_all:

; 223  : 		_Myproxy->_Myfirstiter = 0;

  00048	48 8b 03	 mov	 rax, QWORD PTR [rbx]

; 224  : 		}

  0004b	48 8d 4c 24 30	 lea	 rcx, QWORD PTR _Lock$1[rsp]
  00050	4c 89 40 08	 mov	 QWORD PTR [rax+8], r8
  00054	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
$LN13@Orphan_all:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 677  : 		}

  0005a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005e	5b		 pop	 rbx
  0005f	c3		 ret	 0
?_Orphan_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAXXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myproxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAAEAPEAU_Container_proxy@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Myproxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAAEAPEAU_Container_proxy@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myproxy, COMDAT

; 665  : 		return (_Get_data()._Myproxy);

  00000	48 8b c1	 mov	 rax, rcx

; 666  : 		}

  00003	c3		 ret	 0
?_Myproxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAAEAPEAU_Container_proxy@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myproxy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Free_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
_Lock$1 = 48
this$ = 48
?_Free_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAXXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Free_proxy, COMDAT

; 649  : 		{	// destroy proxy

$LN60:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 216  : 	if (_Myproxy != 0)

  0000a	33 ff		 xor	 edi, edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 649  : 		{	// destroy proxy

  0000c	48 8b d9	 mov	 rbx, rcx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 216  : 	if (_Myproxy != 0)

  0000f	48 39 39	 cmp	 QWORD PTR [rcx], rdi
  00012	74 46		 je	 SHORT $LN21@Free_proxy

; 217  : 		{	// proxy allocated, drain it
; 218  : 		_Lockit _Lock(_LOCK_DEBUG);

  00014	8d 57 03	 lea	 edx, QWORD PTR [rdi+3]
  00017	48 8d 4c 24 30	 lea	 rcx, QWORD PTR _Lock$1[rsp]
  0001c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0_Lockit@std@@QEAA@H@Z

; 219  : 
; 220  : 		for (_Iterator_base12 **_Pnext = &_Myproxy->_Myfirstiter;

  00022	48 8b 13	 mov	 rdx, QWORD PTR [rbx]

; 221  : 			*_Pnext != 0; *_Pnext = (*_Pnext)->_Mynextiter)

  00025	48 39 7a 08	 cmp	 QWORD PTR [rdx+8], rdi
  00029	74 1d		 je	 SHORT $LN19@Free_proxy
  0002b	0f 1f 44 00 00	 npad	 5
$LL20@Free_proxy:

; 222  : 			(*_Pnext)->_Myproxy = 0;

  00030	48 8b 42 08	 mov	 rax, QWORD PTR [rdx+8]
  00034	48 89 38	 mov	 QWORD PTR [rax], rdi
  00037	48 8b 42 08	 mov	 rax, QWORD PTR [rdx+8]
  0003b	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0003f	48 89 4a 08	 mov	 QWORD PTR [rdx+8], rcx
  00043	48 85 c9	 test	 rcx, rcx
  00046	75 e8		 jne	 SHORT $LL20@Free_proxy
$LN19@Free_proxy:

; 223  : 		_Myproxy->_Myfirstiter = 0;

  00048	48 8b 03	 mov	 rax, QWORD PTR [rbx]

; 224  : 		}

  0004b	48 8d 4c 24 30	 lea	 rcx, QWORD PTR _Lock$1[rsp]
  00050	48 89 78 08	 mov	 QWORD PTR [rax+8], rdi
  00054	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
$LN21@Free_proxy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 620  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  0005a	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  0005d	ba 01 00 00 00	 mov	 edx, 1
  00062	44 8d 42 0f	 lea	 r8d, QWORD PTR [rdx+15]
  00066	e8 00 00 00 00	 call	 ?_Deallocate@std@@YAXPEAX_K1@Z ; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 655  : 		_Myproxy() = 0;

  0006b	48 89 3b	 mov	 QWORD PTR [rbx], rdi

; 656  : 		}

  0006e	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00073	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00077	5f		 pop	 rdi
  00078	c3		 ret	 0
?_Free_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAXXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Free_proxy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Alloc_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Alloc_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAXXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Alloc_proxy, COMDAT

; 640  : 		{	// construct proxy

$LN69:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 625  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

  00006	ba 10 00 00 00	 mov	 edx, 16
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 640  : 		{	// construct proxy

  0000b	48 8b d9	 mov	 rbx, rcx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 625  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

  0000e	41 b0 01	 mov	 r8b, 1
  00011	8d 4a f1	 lea	 ecx, QWORD PTR [rdx-15]
  00014	e8 00 00 00 00	 call	 ?_Allocate@std@@YAPEAX_K0_N@Z ; std::_Allocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 643  : 		_Myproxy() = _Alproxy.allocate(1);

  00019	48 89 03	 mov	 QWORD PTR [rbx], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 637  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  0001c	48 85 c0	 test	 rax, rax
  0001f	74 09		 je	 SHORT $LN67@Alloc_prox
  00021	0f 57 c0	 xorps	 xmm0, xmm0
  00024	0f 11 00	 movups	 XMMWORD PTR [rax], xmm0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 645  : 		_Myproxy()->_Mycont = &_Get_data();

  00027	48 8b 03	 mov	 rax, QWORD PTR [rbx]
$LN67@Alloc_prox:
  0002a	48 89 18	 mov	 QWORD PTR [rax], rbx

; 646  : 		}

  0002d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00031	5b		 pop	 rbx
  00032	c3		 ret	 0
?_Alloc_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAXXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Alloc_proxy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAA@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >, COMDAT

; 615  : 		{	// destroy the object

$LN9:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  0000f	48 8b d9	 mov	 rbx, rcx

; 616  : 		_Free_proxy();

  00012	e8 00 00 00 00	 call	 ?_Free_proxy@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAXXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Free_proxy
  00017	90		 npad	 1
  00018	48 8b cb	 mov	 rcx, rbx

; 617  : 		}

  0001b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0001f	5b		 pop	 rbx
  00020	e9 00 00 00 00	 jmp	 ??1_Container_base12@std@@QEAA@XZ ; std::_Container_base12::~_Container_base12
??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAA@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAA@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >, COMDAT

; 601  : 		{	// default construct allocator

$LN76:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	53		 push	 rbx
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  00013	48 8b d9	 mov	 rbx, rcx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 79   : 		: _Myproxy(0)

  00016	33 c0		 xor	 eax, eax
  00018	48 89 01	 mov	 QWORD PTR [rcx], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 488  : 		_Mysize = 0;

  0001b	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 489  : 		_Myres = 0;

  0001f	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 625  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

  00023	41 b0 01	 mov	 r8b, 1
  00026	8d 50 10	 lea	 edx, QWORD PTR [rax+16]
  00029	8d 48 01	 lea	 ecx, QWORD PTR [rax+1]
  0002c	e8 00 00 00 00	 call	 ?_Allocate@std@@YAPEAX_K0_N@Z ; std::_Allocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 643  : 		_Myproxy() = _Alproxy.allocate(1);

  00031	48 89 03	 mov	 QWORD PTR [rbx], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 637  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

  00034	48 85 c0	 test	 rax, rax
  00037	74 06		 je	 SHORT $LN54@String_all
  00039	0f 57 c0	 xorps	 xmm0, xmm0
  0003c	0f 11 00	 movups	 XMMWORD PTR [rax], xmm0
$LN54@String_all:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 645  : 		_Myproxy()->_Mycont = &_Get_data();

  0003f	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00042	48 89 18	 mov	 QWORD PTR [rax], rbx

; 602  : 		_Alloc_proxy();
; 603  : 		}

  00045	48 8b c3	 mov	 rax, rbx
  00048	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0004c	5b		 pop	 rbx
  0004d	c3		 ret	 0
??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAA@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
?dtor$0@?0???0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAA@XZ@4HA PROC ; `std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >'::`1'::dtor$0
  00000	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
?dtor$0@?0???0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAA@XZ@4HA ENDP ; `std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
?dtor$0@?0???0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAA@XZ@4HA PROC ; `std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >'::`1'::dtor$0
  00000	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
?dtor$0@?0???0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAA@XZ@4HA ENDP ; `std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 8
?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAPEADXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr, COMDAT

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  00000	48 83 79 20 10	 cmp	 QWORD PTR [rcx+32], 16
  00005	72 05		 jb	 SHORT $LN11@Myptr

; 561  : 		return (_Get_data()._Myptr());

  00007	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]

; 562  : 		}

  0000b	c3		 ret	 0
$LN11@Myptr:

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  0000c	48 8d 41 08	 lea	 rax, QWORD PTR [rcx+8]

; 562  : 		}

  00010	c3		 ret	 0
?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAPEADXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >, COMDAT
  00000	e9 00 00 00 00	 jmp	 ??1_Container_base12@std@@QEAA@XZ ; std::_Container_base12::~_Container_base12
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 8
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  00000	48 83 79 20 10	 cmp	 QWORD PTR [rcx+32], 16
  00005	72 05		 jb	 SHORT $LN3@Myptr
  00007	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]

; 506  : 			? _STD addressof(*this->_Bx._Ptr)
; 507  : 			: this->_Bx._Buf);
; 508  : 		}

  0000b	c3		 ret	 0
$LN3@Myptr:

; 505  : 		return (this->_BUF_SIZE <= this->_Myres

  0000c	48 8d 41 08	 lea	 rax, QWORD PTR [rcx+8]

; 506  : 			? _STD addressof(*this->_Bx._Ptr)
; 507  : 			: this->_Bx._Buf);
; 508  : 		}

  00010	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 79   : 		: _Myproxy(0)

  00000	33 c0		 xor	 eax, eax
  00002	48 89 01	 mov	 QWORD PTR [rcx], rax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 488  : 		_Mysize = 0;

  00005	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 489  : 		_Myres = 0;

  00009	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 490  : 		}

  0000d	48 8b c1	 mov	 rax, rcx
  00010	c3		 ret	 0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QEBA_KU_Nil@2@@Z
_TEXT	SEGMENT
this$ = 8
__formal$ = 16
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QEBA_KU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::max_size, COMDAT

; 906  : 		return (_Mytraits::max_size(*this));

  00000	48 83 c8 ff	 or	 rax, -1

; 907  : 		}

  00004	c3		 ret	 0
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QEBA_KU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QEAAXPEAD_K@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
_Count$ = 24
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QEAAXPEAD_K@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::deallocate, COMDAT

; 884  : 		{	// deallocate object at _Ptr, ignore size

  00000	49 8b c0	 mov	 rax, r8
  00003	48 8b ca	 mov	 rcx, rdx

; 620  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00006	48 8b d0	 mov	 rdx, rax
  00009	41 b8 01 00 00
	00		 mov	 r8d, 1
  0000f	e9 00 00 00 00	 jmp	 ?_Deallocate@std@@YAXPEAX_K1@Z ; std::_Deallocate
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QEAAXPEAD_K@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QEAAPEAD_K@Z
_TEXT	SEGMENT
this$ = 8
_Count$ = 16
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QEAAPEAD_K@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::allocate, COMDAT

; 873  : 		{	// allocate array of _Count elements

  00000	48 8b ca	 mov	 rcx, rdx

; 625  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

  00003	41 b0 01	 mov	 r8b, 1
  00006	ba 01 00 00 00	 mov	 edx, 1
  0000b	e9 00 00 00 00	 jmp	 ?_Allocate@std@@YAPEAX_K0_N@Z ; std::_Allocate
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QEAAPEAD_K@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QEAA@XZ PROC	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT

; 835  : 		}

  00000	48 8b c1	 mov	 rax, rcx
  00003	c3		 ret	 0
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QEAA@XZ ENDP	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z
_TEXT	SEGMENT
_Al$ = 8
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z PROC ; std::allocator_traits<std::allocator<char> >::max_size, COMDAT

; 767  : 		return (_Al.max_size());

  00000	48 83 c8 ff	 or	 rax, -1

; 768  : 		}

  00004	c3		 ret	 0
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z ENDP ; std::allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@D@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?max_size@?$allocator@D@std@@QEBA_KXZ PROC		; std::allocator<char>::max_size, COMDAT

; 649  : 		return ((size_t)(-1) / sizeof (_Ty));

  00000	48 83 c8 ff	 or	 rax, -1

; 650  : 		}

  00004	c3		 ret	 0
?max_size@?$allocator@D@std@@QEBA_KXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@D@std@@QEAAPEAD_K@Z
_TEXT	SEGMENT
this$ = 8
_Count$ = 16
?allocate@?$allocator@D@std@@QEAAPEAD_K@Z PROC		; std::allocator<char>::allocate, COMDAT

; 624  : 		{	// allocate array of _Count elements

  00000	48 8b ca	 mov	 rcx, rdx

; 625  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

  00003	41 b0 01	 mov	 r8b, 1
  00006	ba 01 00 00 00	 mov	 edx, 1
  0000b	e9 00 00 00 00	 jmp	 ?_Allocate@std@@YAPEAX_K0_N@Z ; std::_Allocate
?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@D@std@@QEAAXPEAD_K@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
_Count$ = 24
?deallocate@?$allocator@D@std@@QEAAXPEAD_K@Z PROC	; std::allocator<char>::deallocate, COMDAT

; 619  : 		{	// deallocate object at _Ptr

  00000	49 8b c0	 mov	 rax, r8
  00003	48 8b ca	 mov	 rcx, rdx

; 620  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

  00006	48 8b d0	 mov	 rdx, rax
  00009	41 b8 01 00 00
	00		 mov	 r8d, 1
  0000f	e9 00 00 00 00	 jmp	 ?_Deallocate@std@@YAXPEAX_K1@Z ; std::_Deallocate
?deallocate@?$allocator@D@std@@QEAAXPEAD_K@Z ENDP	; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@D@std@@QEAA@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT

; 600  : 		{	// construct default allocator (do nothing)
; 601  : 		}

  00000	48 8b c1	 mov	 rax, rcx
  00003	c3		 ret	 0
??0?$allocator@D@std@@QEAA@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?_Deallocate@std@@YAXPEAX_K1@Z
_TEXT	SEGMENT
_Ptr$ = 64
_Count$ = 72
_Sz$ = 80
?_Deallocate@std@@YAXPEAX_K1@Z PROC			; std::_Deallocate, COMDAT

; 92   : 	{	// deallocate storage for _Count elements of size _Sz

$LN23:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 56		 push	 r14
  00016	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0001a	48 8b fa	 mov	 rdi, rdx

; 93   :  #if defined(_M_IX86) || defined(_M_X64)
; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

  0001d	4c 8d 35 00 00
	00 00		 lea	 r14, OFFSET FLAT:??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs?$AA?$AA@
  00024	33 d2		 xor	 edx, edx
  00026	48 83 c8 ff	 or	 rax, -1
  0002a	49 f7 f0	 div	 r8
  0002d	33 ed		 xor	 ebp, ebp
  0002f	49 8b f0	 mov	 rsi, r8
  00032	48 8b d9	 mov	 rbx, rcx
  00035	48 3b f8	 cmp	 rdi, rax
  00038	76 54		 jbe	 SHORT $LN2@Deallocate
  0003a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1EI@MLOBABC@?$AA?$CC?$AA_?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA?$CI?$AAs?$AAi?$AAz?$AAe?$AA_?$AAt?$AA?$CJ?$AA?$CI?$AA?9?$AA1?$AA?$CJ?$AA?5?$AA?1?$AA?5?$AA_?$AAS?$AAz?$AA?$CC?$AA?5?$AA?$CG@
  00041	45 33 c9	 xor	 r9d, r9d
  00044	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00049	44 8d 45 5e	 lea	 r8d, QWORD PTR [rbp+94]
  0004d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1JA@HEEMAOGC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  00054	4c 89 74 24 20	 mov	 QWORD PTR [rsp+32], r14
  00059	8d 4d 02	 lea	 ecx, QWORD PTR [rbp+2]
  0005c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__CrtDbgReportW
  00062	83 f8 01	 cmp	 eax, 1
  00065	75 01		 jne	 SHORT $LN11@Deallocate
  00067	cc		 int	 3
$LN11@Deallocate:
  00068	41 b9 5e 00 00
	00		 mov	 r9d, 94			; 0000005eH
  0006e	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  00073	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_1JA@HEEMAOGC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  0007a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CC@LOFJFFDB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA?$AA@
  00081	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@
  00088	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter
$LN2@Deallocate:

; 95   : 	const size_t _User_size = _Count * _Sz;

  0008e	48 0f af fe	 imul	 rdi, rsi

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

  00092	48 81 ff 00 10
	00 00		 cmp	 rdi, 4096		; 00001000H
  00099	0f 82 d9 01 00
	00		 jb	 $LN3@Deallocate

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

  0009f	f6 c3 1f	 test	 bl, 31
  000a2	74 55		 je	 SHORT $LN4@Deallocate
  000a4	45 33 c9	 xor	 r9d, r9d
  000a7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1HE@CDMBFOKC@?$AA?$CC?$AA?$CI?$AA_?$AAP?$AAt?$AAr?$AA_?$AAu?$AAs?$AAe?$AAr?$AA?5?$AA?$CG?$AA?5?$AA?$CI?$AA_?$AAB?$AAI?$AAG?$AA_?$AAA?$AAL?$AAL?$AAO?$AAC?$AAA?$AAT?$AAI?$AAO?$AAN?$AA_?$AAA@
  000ae	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  000b3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1JA@HEEMAOGC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  000ba	4c 89 74 24 20	 mov	 QWORD PTR [rsp+32], r14
  000bf	45 8d 41 64	 lea	 r8d, QWORD PTR [r9+100]
  000c3	41 8d 49 02	 lea	 ecx, QWORD PTR [r9+2]
  000c7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__CrtDbgReportW
  000cd	83 f8 01	 cmp	 eax, 1
  000d0	75 01		 jne	 SHORT $LN13@Deallocate
  000d2	cc		 int	 3
$LN13@Deallocate:
  000d3	41 b9 64 00 00
	00		 mov	 r9d, 100		; 00000064H
  000d9	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  000de	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_1JA@HEEMAOGC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  000e5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CC@LOFJFFDB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA?$AA@
  000ec	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@
  000f3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter
$LN4@Deallocate:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  000f9	48 8b 7b f8	 mov	 rdi, QWORD PTR [rbx-8]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(

  000fd	48 b8 fa fa fa
	fa fa fa fa fa	 mov	 rax, -361700864190383366 ; fafafafafafafafaH
  00107	48 39 43 f0	 cmp	 QWORD PTR [rbx-16], rax
  0010b	74 55		 je	 SHORT $LN5@Deallocate
  0010d	45 33 c9	 xor	 r9d, r9d
  00110	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1JO@EKLKIEHP@?$AA?$CC?$AAr?$AAe?$AAi?$AAn?$AAt?$AAe?$AAr?$AAp?$AAr?$AAe?$AAt?$AA_?$AAc?$AAa?$AAs?$AAt?$AA?$DM?$AAu?$AAi?$AAn?$AAt?$AAp?$AAt?$AAr?$AA_?$AAt?$AA?5?$AA?$CK?$AA?$DO?$AA?$CI?$AA_@
  00117	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0011c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1JA@HEEMAOGC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  00123	4c 89 74 24 20	 mov	 QWORD PTR [rsp+32], r14
  00128	45 8d 41 6e	 lea	 r8d, QWORD PTR [r9+110]
  0012c	41 8d 49 02	 lea	 ecx, QWORD PTR [r9+2]
  00130	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__CrtDbgReportW
  00136	83 f8 01	 cmp	 eax, 1
  00139	75 01		 jne	 SHORT $LN15@Deallocate
  0013b	cc		 int	 3
$LN15@Deallocate:
  0013c	41 b9 6e 00 00
	00		 mov	 r9d, 110		; 0000006eH
  00142	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  00147	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_1JA@HEEMAOGC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  0014e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CC@LOFJFFDB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA?$AA@
  00155	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@
  0015c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter
$LN5@Deallocate:

; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

  00162	48 3b fb	 cmp	 rdi, rbx
  00165	72 55		 jb	 SHORT $LN6@Deallocate
  00167	45 33 c9	 xor	 r9d, r9d
  0016a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1EE@PDHAHDDC@?$AA?$CC?$AA_?$AAP?$AAt?$AAr?$AA_?$AAc?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn?$AAe?$AAr?$AA?5?$AA?$DM?$AA?5?$AA_?$AAP?$AAt?$AAr?$AA_?$AAu?$AAs?$AAe?$AAr?$AA?$CC?$AA?5?$AA?$CG?$AA?$CG?$AA?5@
  00171	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00176	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1JA@HEEMAOGC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  0017d	4c 89 74 24 20	 mov	 QWORD PTR [rsp+32], r14
  00182	45 8d 41 72	 lea	 r8d, QWORD PTR [r9+114]
  00186	41 8d 49 02	 lea	 ecx, QWORD PTR [r9+2]
  0018a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__CrtDbgReportW
  00190	83 f8 01	 cmp	 eax, 1
  00193	75 01		 jne	 SHORT $LN17@Deallocate
  00195	cc		 int	 3
$LN17@Deallocate:
  00196	41 b9 72 00 00
	00		 mov	 r9d, 114		; 00000072H
  0019c	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  001a1	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_1JA@HEEMAOGC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  001a8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CC@LOFJFFDB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA?$AA@
  001af	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@
  001b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter
$LN6@Deallocate:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)

  001bc	48 2b df	 sub	 rbx, rdi
  001bf	48 83 fb 10	 cmp	 rbx, 16
  001c3	73 55		 jae	 SHORT $LN7@Deallocate
  001c5	45 33 c9	 xor	 r9d, r9d
  001c8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1HA@NAPGMHAO@?$AA?$CC?$AA2?$AA?5?$AA?$CK?$AA?5?$AAs?$AAi?$AAz?$AAe?$AAo?$AAf?$AA?$CI?$AAv?$AAo?$AAi?$AAd?$AA?5?$AA?$CK?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA_?$AAP?$AAt?$AAr?$AA_?$AAu?$AAs?$AAe?$AAr@
  001cf	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001d4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1JA@HEEMAOGC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  001db	4c 89 74 24 20	 mov	 QWORD PTR [rsp+32], r14
  001e0	45 8d 41 76	 lea	 r8d, QWORD PTR [r9+118]
  001e4	41 8d 49 02	 lea	 ecx, QWORD PTR [r9+2]
  001e8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__CrtDbgReportW
  001ee	83 f8 01	 cmp	 eax, 1
  001f1	75 01		 jne	 SHORT $LN19@Deallocate
  001f3	cc		 int	 3
$LN19@Deallocate:
  001f4	41 b9 76 00 00
	00		 mov	 r9d, 118		; 00000076H
  001fa	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  001ff	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_1JA@HEEMAOGC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  00206	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CC@LOFJFFDB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA?$AA@
  0020d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@
  00214	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter
$LN7@Deallocate:

; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)
; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

  0021a	48 83 fb 2f	 cmp	 rbx, 47			; 0000002fH
  0021e	76 55		 jbe	 SHORT $LN8@Deallocate
  00220	45 33 c9	 xor	 r9d, r9d
  00223	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1GI@DHJGPFNI@?$AA?$CC?$AA_?$AAP?$AAt?$AAr?$AA_?$AAu?$AAs?$AAe?$AAr?$AA?5?$AA?9?$AA?5?$AA_?$AAP?$AAt?$AAr?$AA_?$AAc?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn?$AAe?$AAr?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA_@
  0022a	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0022f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1JA@HEEMAOGC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  00236	4c 89 74 24 20	 mov	 QWORD PTR [rsp+32], r14
  0023b	45 8d 41 7e	 lea	 r8d, QWORD PTR [r9+126]
  0023f	41 8d 49 02	 lea	 ecx, QWORD PTR [r9+2]
  00243	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__CrtDbgReportW
  00249	83 f8 01	 cmp	 eax, 1
  0024c	75 01		 jne	 SHORT $LN21@Deallocate
  0024e	cc		 int	 3
$LN21@Deallocate:
  0024f	41 b9 7e 00 00
	00		 mov	 r9d, 126		; 0000007eH
  00255	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  0025a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_1JA@HEEMAOGC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  00261	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CC@LOFJFFDB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA?$AA@
  00268	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@
  0026f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter
$LN8@Deallocate:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00275	48 8b df	 mov	 rbx, rdi
$LN3@Deallocate:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

  00278	48 8b cb	 mov	 rcx, rbx

; 133  : 	}

  0027b	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00280	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  00285	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  0028a	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  0028f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00293	41 5e		 pop	 r14

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

  00295	e9 00 00 00 00	 jmp	 ??3@YAXPEAX@Z		; operator delete
?_Deallocate@std@@YAXPEAX_K1@Z ENDP			; std::_Deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?_Allocate@std@@YAPEAX_K0_N@Z
_TEXT	SEGMENT
_Count$ = 64
_Sz$ = 72
_Try_aligned_allocation$ = 80
?_Allocate@std@@YAPEAX_K0_N@Z PROC			; std::_Allocate, COMDAT

; 48   : 	{	// allocate storage for _Count elements of size _Sz

$LN17:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00004	4c 8b ca	 mov	 r9, rdx

; 49   : 	void *_Ptr = 0;
; 50   : 
; 51   : 	if (_Count == 0)

  00007	48 85 c9	 test	 rcx, rcx
  0000a	75 07		 jne	 SHORT $LN2@Allocate

; 52   : 		return (_Ptr);

  0000c	33 c0		 xor	 eax, eax

; 87   : 	}

  0000e	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00012	c3		 ret	 0
$LN2@Allocate:

; 53   : 
; 54   : 	// check overflow of multiply
; 55   : 	if ((size_t)(-1) / _Sz < _Count)

  00013	33 d2		 xor	 edx, edx
  00015	48 83 c8 ff	 or	 rax, -1
  00019	49 f7 f1	 div	 r9
  0001c	48 3b c1	 cmp	 rax, rcx
  0001f	73 07		 jae	 SHORT $LN3@Allocate

; 56   : 		_Xbad_alloc();	// report no memory

  00021	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
  00027	cc		 int	 3
$LN3@Allocate:

; 57   : 	const size_t _User_size = _Count * _Sz;

  00028	49 0f af c9	 imul	 rcx, r9
  0002c	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx

; 58   : 
; 59   :  #if defined(_M_IX86) || defined(_M_X64)
; 60   : 	if (_Try_aligned_allocation
; 61   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

  00031	45 84 c0	 test	 r8b, r8b
  00034	0f 84 bd 00 00
	00		 je	 $LN4@Allocate
  0003a	48 81 f9 00 10
	00 00		 cmp	 rcx, 4096		; 00001000H
  00041	0f 82 b0 00 00
	00		 jb	 $LN4@Allocate

; 62   : 		{	// allocate large block
; 63   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 64   : 			"Big allocations should at least match vector register size");
; 65   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

  00047	48 8d 41 2f	 lea	 rax, QWORD PTR [rcx+47]

; 66   : 		if (_Block_size <= _User_size)

  0004b	48 3b c1	 cmp	 rax, rcx
  0004e	77 07		 ja	 SHORT $LN6@Allocate

; 67   : 			_Xbad_alloc();	// report no memory

  00050	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
  00056	cc		 int	 3
$LN6@Allocate:

; 68   : 		const uintptr_t _Ptr_container =
; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  00057	48 8b c8	 mov	 rcx, rax
  0005a	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  0005f	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00064	48 8b f8	 mov	 rdi, rax

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

  00067	48 85 c0	 test	 rax, rax
  0006a	75 5f		 jne	 SHORT $LN7@Allocate
  0006c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1DG@HGDKEBPG@?$AA?$CC?$AA_?$AAP?$AAt?$AAr?$AA_?$AAc?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn?$AAe?$AAr?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?$CC?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA0?$AA?$AA@
  00073	45 33 c9	 xor	 r9d, r9d
  00076	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0007b	44 8d 47 46	 lea	 r8d, QWORD PTR [rdi+70]
  0007f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs?$AA?$AA@
  00086	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1JA@HEEMAOGC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  0008d	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00092	8d 4f 02	 lea	 ecx, QWORD PTR [rdi+2]
  00095	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__CrtDbgReportW
  0009b	83 f8 01	 cmp	 eax, 1
  0009e	75 01		 jne	 SHORT $LN11@Allocate
  000a0	cc		 int	 3
$LN11@Allocate:
  000a1	41 b9 46 00 00
	00		 mov	 r9d, 70			; 00000046H
  000a7	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  000b0	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_1JA@HEEMAOGC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  000b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1BO@NKFMJPA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA?$AA@
  000be	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@
  000c5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter
$LN7@Allocate:

; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

  000cb	48 8d 5f 2f	 lea	 rbx, QWORD PTR [rdi+47]

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;
; 74   : 
; 75   :  #ifdef _DEBUG
; 76   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;

  000cf	48 b8 fa fa fa
	fa fa fa fa fa	 mov	 rax, -361700864190383366 ; fafafafafafafafaH
  000d9	48 83 e3 e0	 and	 rbx, -32		; ffffffffffffffe0H
  000dd	48 89 43 f0	 mov	 QWORD PTR [rbx-16], rax

; 85   : 		}
; 86   : 	return (_Ptr);

  000e1	48 8b c3	 mov	 rax, rbx
  000e4	48 89 7b f8	 mov	 QWORD PTR [rbx-8], rdi
  000e8	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000ed	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 87   : 	}

  000f2	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000f6	c3		 ret	 0
$LN4@Allocate:

; 77   :  #endif /* _DEBUG */
; 78   : 		}
; 79   : 	else
; 80   :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 81   : 
; 82   : 		{	// allocate normal block
; 83   : 		_Ptr = ::operator new(_User_size);

  000f7	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  000fc	48 8b d8	 mov	 rbx, rax

; 84   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

  000ff	48 85 c0	 test	 rax, rax
  00102	75 5f		 jne	 SHORT $LN8@Allocate
  00104	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_1CC@GKJLLHIM@?$AA?$CC?$AA_?$AAP?$AAt?$AAr?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?$CC?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA0?$AA?$AA@
  0010b	45 33 c9	 xor	 r9d, r9d
  0010e	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00113	44 8d 43 54	 lea	 r8d, QWORD PTR [rbx+84]
  00117	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs?$AA?$AA@
  0011e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1JA@HEEMAOGC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  00125	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0012a	8d 4b 02	 lea	 ecx, QWORD PTR [rbx+2]
  0012d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__CrtDbgReportW
  00133	83 f8 01	 cmp	 eax, 1
  00136	75 01		 jne	 SHORT $LN13@Allocate
  00138	cc		 int	 3
$LN13@Allocate:
  00139	41 b9 54 00 00
	00		 mov	 r9d, 84			; 00000054H
  0013f	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR [rsp+32], 0
  00148	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_1JA@HEEMAOGC@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  0014f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1BO@NKFMJPA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA?$AA@
  00156	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@
  0015d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter
$LN8@Allocate:

; 85   : 		}
; 86   : 	return (_Ptr);

  00163	48 8b c3	 mov	 rax, rbx
  00166	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 87   : 	}

  0016b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0016f	c3		 ret	 0
$LN16@Allocate:
?_Allocate@std@@YAPEAX_K0_N@Z ENDP			; std::_Allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Orphan_me@_Iterator_base12@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Orphan_me@_Iterator_base12@std@@QEAAXXZ PROC		; std::_Iterator_base12::_Orphan_me, COMDAT

; 192  : 		{	// cut ties with parent

$LN13:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 193  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 194  : 		if (_Myproxy != 0)

  0000a	48 8b 19	 mov	 rbx, QWORD PTR [rcx]
  0000d	48 8b f9	 mov	 rdi, rcx
  00010	48 85 db	 test	 rbx, rbx
  00013	74 4c		 je	 SHORT $LN4@Orphan_me

; 195  : 			{	// adopted, remove self from list
; 196  : 			_Iterator_base12 **_Pnext = &_Myproxy->_Myfirstiter;

  00015	48 83 c3 08	 add	 rbx, 8

; 197  : 			while (*_Pnext != 0 && *_Pnext != this)

  00019	48 83 3b 00	 cmp	 QWORD PTR [rbx], 0
  0001d	74 1a		 je	 SHORT $LN11@Orphan_me
  0001f	90		 npad	 1
$LL2@Orphan_me:
  00020	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00023	48 3b c1	 cmp	 rax, rcx
  00026	74 0b		 je	 SHORT $LN3@Orphan_me
  00028	48 83 78 08 00	 cmp	 QWORD PTR [rax+8], 0

; 198  : 				_Pnext = &(*_Pnext)->_Mynextiter;

  0002d	48 8d 58 08	 lea	 rbx, QWORD PTR [rax+8]
  00031	75 ed		 jne	 SHORT $LL2@Orphan_me
$LN3@Orphan_me:

; 199  : 
; 200  : 			if (*_Pnext == 0)

  00033	48 83 3b 00	 cmp	 QWORD PTR [rbx], 0
  00037	75 1a		 jne	 SHORT $LN5@Orphan_me
$LN11@Orphan_me:

; 201  : 				_DEBUG_ERROR("ITERATOR LIST CORRUPTED!");

  00039	41 b8 c9 00 00
	00		 mov	 r8d, 201		; 000000c9H
  0003f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1JA@IJKHNLMB@?$AAC?$AA?3?$AA?2?$AAP?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAF?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAM?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  00046	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@
  0004d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Debug_message@std@@YAXPEB_W0I@Z
$LN5@Orphan_me:

; 202  : 			*_Pnext = _Mynextiter;

  00053	48 8b 47 08	 mov	 rax, QWORD PTR [rdi+8]
  00057	48 89 03	 mov	 QWORD PTR [rbx], rax

; 203  : 			_Myproxy = 0;

  0005a	48 c7 07 00 00
	00 00		 mov	 QWORD PTR [rdi], 0
$LN4@Orphan_me:

; 204  : 			}
; 205  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 206  : 		}

  00061	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00066	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0006a	5f		 pop	 rdi
  0006b	c3		 ret	 0
?_Orphan_me@_Iterator_base12@std@@QEAAXXZ ENDP		; std::_Iterator_base12::_Orphan_me
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Getcont@_Iterator_base12@std@@QEBAPEBU_Container_base12@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getcont@_Iterator_base12@std@@QEBAPEBU_Container_base12@2@XZ PROC ; std::_Iterator_base12::_Getcont, COMDAT

; 183  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00003	48 85 c0	 test	 rax, rax
  00006	75 01		 jne	 SHORT $LN3@Getcont

; 184  : 		}

  00008	c3		 ret	 0
$LN3@Getcont:

; 183  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

  00009	48 8b 00	 mov	 rax, QWORD PTR [rax]

; 184  : 		}

  0000c	c3		 ret	 0
?_Getcont@_Iterator_base12@std@@QEBAPEBU_Container_base12@2@XZ ENDP ; std::_Iterator_base12::_Getcont
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Adopt@_Iterator_base12@std@@QEAAXPEBU_Container_base12@2@@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_Lock$2 = 72
_Lock$3 = 72
_Parent$ = 72
?_Adopt@_Iterator_base12@std@@QEAAXPEBU_Container_base12@2@@Z PROC ; std::_Iterator_base12::_Adopt, COMDAT

; 148  : 		{	// adopt this iterator by parent

$LN9:
  00000	40 57		 push	 rdi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  0000f	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00014	48 8b d9	 mov	 rbx, rcx

; 149  : 		if (_Parent == 0)

  00017	48 85 d2	 test	 rdx, rdx
  0001a	75 1c		 jne	 SHORT $LN2@Adopt

; 150  : 			{	// no future parent, just disown current parent
; 151  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 152  : 			_Lockit _Lock(_LOCK_DEBUG);

  0001c	ba 03 00 00 00	 mov	 edx, 3
  00021	48 8d 4c 24 48	 lea	 rcx, QWORD PTR _Lock$3[rsp]
  00026	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0_Lockit@std@@QEAA@H@Z
  0002c	90		 npad	 1

; 153  : 			_Orphan_me();

  0002d	48 8b cb	 mov	 rcx, rbx
  00030	e8 00 00 00 00	 call	 ?_Orphan_me@_Iterator_base12@std@@QEAAXXZ ; std::_Iterator_base12::_Orphan_me
  00035	90		 npad	 1

; 154  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 155  : 			}
; 156  : 		else

  00036	eb 30		 jmp	 SHORT $LN8@Adopt
$LN2@Adopt:

; 157  : 			{	// have a parent, do adoption
; 158  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;

  00038	48 8b 3a	 mov	 rdi, QWORD PTR [rdx]

; 159  : 
; 160  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 161  : 			if (_Myproxy != _Parent_proxy)

  0003b	48 39 39	 cmp	 QWORD PTR [rcx], rdi
  0003e	74 33		 je	 SHORT $LN4@Adopt

; 162  : 				{	// change parentage
; 163  : 				_Lockit _Lock(_LOCK_DEBUG);

  00040	ba 03 00 00 00	 mov	 edx, 3
  00045	48 8d 4c 24 48	 lea	 rcx, QWORD PTR _Lock$2[rsp]
  0004a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0_Lockit@std@@QEAA@H@Z
  00050	90		 npad	 1

; 164  : 				_Orphan_me();

  00051	48 8b cb	 mov	 rcx, rbx
  00054	e8 00 00 00 00	 call	 ?_Orphan_me@_Iterator_base12@std@@QEAAXXZ ; std::_Iterator_base12::_Orphan_me

; 165  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;

  00059	48 8b 47 08	 mov	 rax, QWORD PTR [rdi+8]
  0005d	48 89 43 08	 mov	 QWORD PTR [rbx+8], rax

; 166  : 				_Parent_proxy->_Myfirstiter = this;

  00061	48 89 5f 08	 mov	 QWORD PTR [rdi+8], rbx

; 167  : 				_Myproxy = _Parent_proxy;

  00065	48 89 3b	 mov	 QWORD PTR [rbx], rdi
$LN8@Adopt:

; 168  : 				}

  00068	48 8d 4c 24 48	 lea	 rcx, QWORD PTR _Lock$2[rsp]
  0006d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
$LN4@Adopt:

; 169  : 
; 170  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 171  : 			_Myproxy = _Parent_proxy;
; 172  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 173  : 			}
; 174  : 		}

  00073	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00078	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0007c	5f		 pop	 rdi
  0007d	c3		 ret	 0
?_Adopt@_Iterator_base12@std@@QEAAXPEBU_Container_base12@2@@Z ENDP ; std::_Iterator_base12::_Adopt
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
_Lock$2 = 72
_Lock$3 = 72
_Parent$ = 72
?dtor$0@?0??_Adopt@_Iterator_base12@std@@QEAAXPEBU_Container_base12@2@@Z@4HA PROC ; `std::_Iterator_base12::_Adopt'::`1'::dtor$0
  00000	48 8d 8a 48 00
	00 00		 lea	 rcx, QWORD PTR _Lock$3[rdx]
  00007	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
?dtor$0@?0??_Adopt@_Iterator_base12@std@@QEAAXPEBU_Container_base12@2@@Z@4HA ENDP ; `std::_Iterator_base12::_Adopt'::`1'::dtor$0
$T1 = 32
this$ = 64
_Lock$2 = 72
_Lock$3 = 72
_Parent$ = 72
?dtor$1@?0??_Adopt@_Iterator_base12@std@@QEAAXPEBU_Container_base12@2@@Z@4HA PROC ; `std::_Iterator_base12::_Adopt'::`1'::dtor$1
  0000e	48 8d 8a 48 00
	00 00		 lea	 rcx, QWORD PTR _Lock$2[rdx]
  00015	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
?dtor$1@?0??_Adopt@_Iterator_base12@std@@QEAAXPEBU_Container_base12@2@@Z@4HA ENDP ; `std::_Iterator_base12::_Adopt'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
_Lock$2 = 72
_Lock$3 = 72
_Parent$ = 72
?dtor$0@?0??_Adopt@_Iterator_base12@std@@QEAAXPEBU_Container_base12@2@@Z@4HA PROC ; `std::_Iterator_base12::_Adopt'::`1'::dtor$0
  00000	48 8d 8a 48 00
	00 00		 lea	 rcx, QWORD PTR _Lock$3[rdx]
  00007	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
?dtor$0@?0??_Adopt@_Iterator_base12@std@@QEAAXPEBU_Container_base12@2@@Z@4HA ENDP ; `std::_Iterator_base12::_Adopt'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
_Lock$2 = 72
_Lock$3 = 72
_Parent$ = 72
?dtor$1@?0??_Adopt@_Iterator_base12@std@@QEAAXPEBU_Container_base12@2@@Z@4HA PROC ; `std::_Iterator_base12::_Adopt'::`1'::dtor$1
  0000e	48 8d 8a 48 00
	00 00		 lea	 rcx, QWORD PTR _Lock$2[rdx]
  00015	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
?dtor$1@?0??_Adopt@_Iterator_base12@std@@QEAAXPEBU_Container_base12@2@@Z@4HA ENDP ; `std::_Iterator_base12::_Adopt'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??1_Iterator_base12@std@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_Lock$ = 72
??1_Iterator_base12@std@@QEAA@XZ PROC			; std::_Iterator_base12::~_Iterator_base12, COMDAT

; 140  : 		{	// destroy the iterator

$LN3:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  0000f	48 8b d9	 mov	 rbx, rcx

; 141  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 142  : 		_Lockit _Lock(_LOCK_DEBUG);

  00012	ba 03 00 00 00	 mov	 edx, 3
  00017	48 8d 4c 24 48	 lea	 rcx, QWORD PTR _Lock$[rsp]
  0001c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0_Lockit@std@@QEAA@H@Z
  00022	90		 npad	 1

; 143  : 		_Orphan_me();

  00023	48 8b cb	 mov	 rcx, rbx
  00026	e8 00 00 00 00	 call	 ?_Orphan_me@_Iterator_base12@std@@QEAAXXZ ; std::_Iterator_base12::_Orphan_me
  0002b	90		 npad	 1

; 144  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 145  : 		}

  0002c	48 8d 4c 24 48	 lea	 rcx, QWORD PTR _Lock$[rsp]
  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
  00037	90		 npad	 1
  00038	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0003c	5b		 pop	 rbx
  0003d	c3		 ret	 0
??1_Iterator_base12@std@@QEAA@XZ ENDP			; std::_Iterator_base12::~_Iterator_base12
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??0_Iterator_base12@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0_Iterator_base12@std@@QEAA@XZ PROC			; std::_Iterator_base12::_Iterator_base12, COMDAT

; 113  : 		: _Myproxy(0), _Mynextiter(0)

  00000	33 c0		 xor	 eax, eax
  00002	48 89 01	 mov	 QWORD PTR [rcx], rax
  00005	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 115  : 		}

  00009	48 8b c1	 mov	 rax, rcx
  0000c	c3		 ret	 0
??0_Iterator_base12@std@@QEAA@XZ ENDP			; std::_Iterator_base12::_Iterator_base12
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Orphan_all@_Container_base12@std@@QEAAXXZ
_TEXT	SEGMENT
_Lock$1 = 48
this$ = 48
?_Orphan_all@_Container_base12@std@@QEAAXXZ PROC	; std::_Container_base12::_Orphan_all, COMDAT

; 214  : 	{	// orphan all iterators

$LN13:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 215  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 216  : 	if (_Myproxy != 0)

  00006	48 83 39 00	 cmp	 QWORD PTR [rcx], 0
  0000a	48 8b d9	 mov	 rbx, rcx
  0000d	74 4b		 je	 SHORT $LN5@Orphan_all

; 217  : 		{	// proxy allocated, drain it
; 218  : 		_Lockit _Lock(_LOCK_DEBUG);

  0000f	ba 03 00 00 00	 mov	 edx, 3
  00014	48 8d 4c 24 30	 lea	 rcx, QWORD PTR _Lock$1[rsp]
  00019	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0_Lockit@std@@QEAA@H@Z

; 219  : 
; 220  : 		for (_Iterator_base12 **_Pnext = &_Myproxy->_Myfirstiter;

  0001f	48 8b 13	 mov	 rdx, QWORD PTR [rbx]

; 221  : 			*_Pnext != 0; *_Pnext = (*_Pnext)->_Mynextiter)

  00022	45 33 c0	 xor	 r8d, r8d
  00025	4c 39 42 08	 cmp	 QWORD PTR [rdx+8], r8
  00029	74 1d		 je	 SHORT $LN3@Orphan_all
  0002b	0f 1f 44 00 00	 npad	 5
$LL4@Orphan_all:

; 222  : 			(*_Pnext)->_Myproxy = 0;

  00030	48 8b 42 08	 mov	 rax, QWORD PTR [rdx+8]
  00034	4c 89 00	 mov	 QWORD PTR [rax], r8
  00037	48 8b 42 08	 mov	 rax, QWORD PTR [rdx+8]
  0003b	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0003f	48 89 4a 08	 mov	 QWORD PTR [rdx+8], rcx
  00043	48 85 c9	 test	 rcx, rcx
  00046	75 e8		 jne	 SHORT $LL4@Orphan_all
$LN3@Orphan_all:

; 223  : 		_Myproxy->_Myfirstiter = 0;

  00048	48 8b 03	 mov	 rax, QWORD PTR [rbx]

; 224  : 		}

  0004b	48 8d 4c 24 30	 lea	 rcx, QWORD PTR _Lock$1[rsp]
  00050	4c 89 40 08	 mov	 QWORD PTR [rax+8], r8
  00054	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
$LN5@Orphan_all:

; 225  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 226  : 	}

  0005a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005e	5b		 pop	 rbx
  0005f	c3		 ret	 0
?_Orphan_all@_Container_base12@std@@QEAAXXZ ENDP	; std::_Container_base12::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??1_Container_base12@std@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
_Lock$2 = 64
this$ = 64
??1_Container_base12@std@@QEAA@XZ PROC			; std::_Container_base12::~_Container_base12, COMDAT

; 94   : 		{	// destroy the container

$LN13:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  0000f	48 8b d9	 mov	 rbx, rcx

; 216  : 	if (_Myproxy != 0)

  00012	48 83 39 00	 cmp	 QWORD PTR [rcx], 0
  00016	74 53		 je	 SHORT $LN7@Container_

; 217  : 		{	// proxy allocated, drain it
; 218  : 		_Lockit _Lock(_LOCK_DEBUG);

  00018	ba 03 00 00 00	 mov	 edx, 3
  0001d	48 8d 4c 24 40	 lea	 rcx, QWORD PTR _Lock$2[rsp]
  00022	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0_Lockit@std@@QEAA@H@Z
  00028	90		 npad	 1

; 219  : 
; 220  : 		for (_Iterator_base12 **_Pnext = &_Myproxy->_Myfirstiter;

  00029	48 8b 13	 mov	 rdx, QWORD PTR [rbx]

; 221  : 			*_Pnext != 0; *_Pnext = (*_Pnext)->_Mynextiter)

  0002c	45 33 c0	 xor	 r8d, r8d
  0002f	4c 39 42 08	 cmp	 QWORD PTR [rdx+8], r8
  00033	74 23		 je	 SHORT $LN5@Container_
  00035	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL6@Container_:

; 222  : 			(*_Pnext)->_Myproxy = 0;

  00040	48 8b 42 08	 mov	 rax, QWORD PTR [rdx+8]
  00044	4c 89 00	 mov	 QWORD PTR [rax], r8

; 221  : 			*_Pnext != 0; *_Pnext = (*_Pnext)->_Mynextiter)

  00047	48 8b 42 08	 mov	 rax, QWORD PTR [rdx+8]
  0004b	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  0004f	48 89 4a 08	 mov	 QWORD PTR [rdx+8], rcx
  00053	48 85 c9	 test	 rcx, rcx
  00056	75 e8		 jne	 SHORT $LL6@Container_
$LN5@Container_:

; 223  : 		_Myproxy->_Myfirstiter = 0;

  00058	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0005b	4c 89 40 08	 mov	 QWORD PTR [rax+8], r8

; 224  : 		}

  0005f	48 8d 4c 24 40	 lea	 rcx, QWORD PTR _Lock$2[rsp]
  00064	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
  0006a	90		 npad	 1
$LN7@Container_:

; 95   : 		_Orphan_all();
; 96   : 		}

  0006b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0006f	5b		 pop	 rbx
  00070	c3		 ret	 0
??1_Container_base12@std@@QEAA@XZ ENDP			; std::_Container_base12::~_Container_base12
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??0_Container_base12@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0_Container_base12@std@@QEAA@XZ PROC			; std::_Container_base12::_Container_base12, COMDAT

; 79   : 		: _Myproxy(0)

  00000	48 c7 01 00 00
	00 00		 mov	 QWORD PTR [rcx], 0

; 81   : 		}

  00007	48 8b c1	 mov	 rax, rcx
  0000a	c3		 ret	 0
??0_Container_base12@std@@QEAA@XZ ENDP			; std::_Container_base12::_Container_base12
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??0_Container_proxy@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0_Container_proxy@std@@QEAA@XZ PROC			; std::_Container_proxy::_Container_proxy, COMDAT

; 67   : 		: _Mycont(0), _Myfirstiter(0)

  00000	33 c0		 xor	 eax, eax
  00002	48 89 01	 mov	 QWORD PTR [rcx], rax
  00005	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax

; 69   : 		}

  00009	48 8b c1	 mov	 rax, rcx
  0000c	c3		 ret	 0
??0_Container_proxy@std@@QEAA@XZ ENDP			; std::_Container_proxy::_Container_proxy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?eof@?$char_traits@D@std@@SAHXZ
_TEXT	SEGMENT
?eof@?$char_traits@D@std@@SAHXZ PROC			; std::char_traits<char>::eof, COMDAT

; 606  : 		return (EOF);

  00000	83 c8 ff	 or	 eax, -1

; 607  : 		}

  00003	c3		 ret	 0
?eof@?$char_traits@D@std@@SAHXZ ENDP			; std::char_traits<char>::eof
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?not_eof@?$char_traits@D@std@@SAHAEBH@Z
_TEXT	SEGMENT
_Meta$ = 8
?not_eof@?$char_traits@D@std@@SAHAEBH@Z PROC		; std::char_traits<char>::not_eof, COMDAT

; 601  : 		return (_Meta != eof() ? _Meta : !eof());

  00000	33 c0		 xor	 eax, eax
  00002	83 39 ff	 cmp	 DWORD PTR [rcx], -1
  00005	0f 45 01	 cmovne	 eax, DWORD PTR [rcx]

; 602  : 		}

  00008	c3		 ret	 0
?not_eof@?$char_traits@D@std@@SAHAEBH@Z ENDP		; std::char_traits<char>::not_eof
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?eq_int_type@?$char_traits@D@std@@SA_NAEBH0@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
?eq_int_type@?$char_traits@D@std@@SA_NAEBH0@Z PROC	; std::char_traits<char>::eq_int_type, COMDAT

; 595  : 		return (_Left == _Right);

  00000	8b 12		 mov	 edx, DWORD PTR [rdx]
  00002	39 11		 cmp	 DWORD PTR [rcx], edx
  00004	0f 94 c0	 sete	 al

; 596  : 		}

  00007	c3		 ret	 0
?eq_int_type@?$char_traits@D@std@@SA_NAEBH0@Z ENDP	; std::char_traits<char>::eq_int_type
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?to_int_type@?$char_traits@D@std@@SAHAEBD@Z
_TEXT	SEGMENT
_Ch$ = 8
?to_int_type@?$char_traits@D@std@@SAHAEBD@Z PROC	; std::char_traits<char>::to_int_type, COMDAT

; 589  : 		return ((unsigned char)_Ch);

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 590  : 		}

  00003	c3		 ret	 0
?to_int_type@?$char_traits@D@std@@SAHAEBD@Z ENDP	; std::char_traits<char>::to_int_type
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?to_char_type@?$char_traits@D@std@@SADAEBH@Z
_TEXT	SEGMENT
_Meta$ = 8
?to_char_type@?$char_traits@D@std@@SADAEBH@Z PROC	; std::char_traits<char>::to_char_type, COMDAT

; 583  : 		return ((_Elem)_Meta);

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 584  : 		}

  00003	c3		 ret	 0
?to_char_type@?$char_traits@D@std@@SADAEBH@Z ENDP	; std::char_traits<char>::to_char_type
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAEADAEBD@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
?assign@?$char_traits@D@std@@SAXAEADAEBD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 565  : 		_Left = _Right;

  00000	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  00003	88 01		 mov	 BYTE PTR [rcx], al

; 566  : 		}

  00005	c3		 ret	 0
?assign@?$char_traits@D@std@@SAXAEADAEBD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAPEADPEAD_KD@Z
_TEXT	SEGMENT
_First$ = 48
_Count$ = 56
_Ch$ = 64
?assign@?$char_traits@D@std@@SAPEADPEAD_KD@Z PROC	; std::char_traits<char>::assign, COMDAT

; 559  : 		{	// assign _Count * _Ch to [_First, ...)

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b c2	 mov	 rax, rdx
  00009	48 8b d9	 mov	 rbx, rcx

; 560  : 		return ((_Elem *)_CSTD memset(_First, _Ch, _Count));

  0000c	41 0f be d0	 movsx	 edx, r8b
  00010	4c 8b c0	 mov	 r8, rax
  00013	e8 00 00 00 00	 call	 memset
  00018	48 8b c3	 mov	 rax, rbx

; 561  : 		}

  0001b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001f	5b		 pop	 rbx
  00020	c3		 ret	 0
?assign@?$char_traits@D@std@@SAPEADPEAD_KD@Z ENDP	; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPEADPEADPEBD_K@Z
_TEXT	SEGMENT
_First1$ = 8
_First2$ = 16
_Count$ = 24
?move@?$char_traits@D@std@@SAPEADPEADPEBD_K@Z PROC	; std::char_traits<char>::move, COMDAT

; 553  : 		return (_Count == 0 ? _First1

  00000	4d 85 c0	 test	 r8, r8
  00003	75 04		 jne	 SHORT $LN3@move
  00005	48 8b c1	 mov	 rax, rcx

; 554  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));
; 555  : 		}

  00008	c3		 ret	 0
$LN3@move:

; 553  : 		return (_Count == 0 ? _First1

  00009	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_memmove
?move@?$char_traits@D@std@@SAPEADPEADPEBD_K@Z ENDP	; std::char_traits<char>::move
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPEADPEADPEBD_K@Z
_TEXT	SEGMENT
_First1$ = 48
_First2$ = 56
_Count$ = 64
?copy@?$char_traits@D@std@@SAPEADPEADPEBD_K@Z PROC	; std::char_traits<char>::copy, COMDAT

; 529  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

$LN7:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 530  : 		return (_Count == 0 ? _First1

  00009	4d 85 c0	 test	 r8, r8
  0000c	74 05		 je	 SHORT $LN5@copy
  0000e	e8 00 00 00 00	 call	 memcpy
$LN5@copy:
  00013	48 8b c3	 mov	 rax, rbx

; 531  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));
; 532  : 		}

  00016	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001a	5b		 pop	 rbx
  0001b	c3		 ret	 0
?copy@?$char_traits@D@std@@SAPEADPEADPEBD_K@Z ENDP	; std::char_traits<char>::copy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SA_KPEBD@Z
_TEXT	SEGMENT
_First$ = 8
?length@?$char_traits@D@std@@SA_KPEBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 523  : 		return (*_First == 0 ? 0

  00000	80 39 00	 cmp	 BYTE PTR [rcx], 0
  00003	75 03		 jne	 SHORT $LN3@length
  00005	33 c0		 xor	 eax, eax

; 524  : 			: _CSTD strlen(_First));
; 525  : 		}

  00007	c3		 ret	 0
$LN3@length:

; 523  : 		return (*_First == 0 ? 0

  00008	48 83 c8 ff	 or	 rax, -1
  0000c	0f 1f 40 00	 npad	 4
$LL5@length:
  00010	48 ff c0	 inc	 rax
  00013	80 3c 01 00	 cmp	 BYTE PTR [rcx+rax], 0
  00017	75 f7		 jne	 SHORT $LL5@length

; 524  : 			: _CSTD strlen(_First));
; 525  : 		}

  00019	c3		 ret	 0
?length@?$char_traits@D@std@@SA_KPEBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_new.h
;	COMDAT ??2@YAPEAX_KPEAX@Z
_TEXT	SEGMENT
_Size$ = 8
_Where$ = 16
??2@YAPEAX_KPEAX@Z PROC					; operator new, COMDAT

; 88   :         (void)_Size;
; 89   :         return _Where;

  00000	48 8b c2	 mov	 rax, rdx

; 90   :     }

  00003	c3		 ret	 0
??2@YAPEAX_KPEAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gexception@std@@UEAAPEAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
$LN8:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 83   :     {

  0000a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7exception@std@@6B@
  00011	48 8b f9	 mov	 rdi, rcx
  00014	48 89 01	 mov	 QWORD PTR [rcx], rax
  00017	8b da		 mov	 ebx, edx

; 84   :         __std_exception_destroy(&_Data);

  00019	48 83 c1 08	 add	 rcx, 8
  0001d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___std_exception_destroy
  00023	f6 c3 01	 test	 bl, 1
  00026	74 0d		 je	 SHORT $LN6@scalar
  00028	ba 18 00 00 00	 mov	 edx, 24
  0002d	48 8b cf	 mov	 rcx, rdi
  00030	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN6@scalar:
  00035	48 8b c7	 mov	 rax, rdi
  00038	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0003d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00041	5f		 pop	 rdi
  00042	c3		 ret	 0
??_Gexception@std@@UEAAPEAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?what@exception@std@@UEBAPEBDXZ PROC			; std::exception::what, COMDAT

; 89   :         return _Data._What ? _Data._What : "Unknown exception";

  00000	48 8b 51 08	 mov	 rdx, QWORD PTR [rcx+8]
  00004	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BC@EOODALEL@Unknown?5exception?$AA@
  0000b	48 85 d2	 test	 rdx, rdx
  0000e	48 0f 45 c2	 cmovne	 rax, rdx

; 90   :     }

  00012	c3		 ret	 0
?what@exception@std@@UEBAPEBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1exception@std@@UEAA@XZ PROC				; std::exception::~exception, COMDAT

; 83   :     {

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7exception@std@@6B@
  00007	48 89 01	 mov	 QWORD PTR [rcx], rax

; 84   :         __std_exception_destroy(&_Data);

  0000a	48 83 c1 08	 add	 rcx, 8
  0000e	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp___std_exception_destroy
??1exception@std@@UEAA@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
_Other$ = 56
??0exception@std@@QEAA@AEBV01@@Z PROC			; std::exception::exception, COMDAT

; 66   :     {

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx
  00009	48 8b c2	 mov	 rax, rdx
  0000c	48 8d 53 08	 lea	 rdx, QWORD PTR [rbx+8]
  00010	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_7exception@std@@6B@
  00017	48 89 0b	 mov	 QWORD PTR [rbx], rcx
  0001a	33 c9		 xor	 ecx, ecx
  0001c	48 89 0a	 mov	 QWORD PTR [rdx], rcx
  0001f	48 89 4a 08	 mov	 QWORD PTR [rdx+8], rcx

; 67   :         __std_exception_copy(&_Other._Data, &_Data);

  00023	48 8d 48 08	 lea	 rcx, QWORD PTR [rax+8]
  00027	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___std_exception_copy

; 68   :     }

  0002d	48 8b c3	 mov	 rax, rbx
  00030	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00034	5b		 pop	 rbx
  00035	c3		 ret	 0
??0exception@std@@QEAA@AEBV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QEAA@QEBDH@Z
_TEXT	SEGMENT
this$ = 8
_Message$ = 16
__formal$ = 24
??0exception@std@@QEAA@QEBDH@Z PROC			; std::exception::exception, COMDAT

; 60   :     {

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7exception@std@@6B@
  00007	48 89 01	 mov	 QWORD PTR [rcx], rax
  0000a	33 c0		 xor	 eax, eax
  0000c	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 61   :         _Data._What = _Message;
; 62   :     }

  00010	48 8b c1	 mov	 rax, rcx
  00013	48 89 51 08	 mov	 QWORD PTR [rcx+8], rdx
  00017	c3		 ret	 0
??0exception@std@@QEAA@QEBDH@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_memcpy_s.h
;	COMDAT memcpy_s
_TEXT	SEGMENT
_Destination$ = 48
_DestinationSize$ = 56
_Source$ = 64
_SourceSize$ = 72
memcpy_s PROC						; COMDAT

; 41   :     {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	49 8b d9	 mov	 rbx, r9
  00012	49 8b f0	 mov	 rsi, r8
  00015	48 8b fa	 mov	 rdi, rdx

; 42   :         if (_SourceSize == 0)

  00018	4d 85 c9	 test	 r9, r9
  0001b	74 41		 je	 SHORT $LN10@memcpy_s

; 43   :         {
; 44   :             return 0;
; 45   :         }
; 46   : 
; 47   :         _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Destination != NULL, EINVAL);

  0001d	48 85 c9	 test	 rcx, rcx
  00020	75 27		 jne	 SHORT $LN3@memcpy_s
$LN9@memcpy_s:
  00022	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00028	c7 00 16 00 00
	00		 mov	 DWORD PTR [rax], 22
  0002e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo
$LN7@memcpy_s:

; 54   : 
; 55   :             // Unreachable, but required to suppress /analyze warnings:
; 56   :             return EINVAL;

  00034	b8 16 00 00 00	 mov	 eax, 22

; 61   :     }

  00039	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0003e	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00043	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00047	5f		 pop	 rdi
  00048	c3		 ret	 0
$LN3@memcpy_s:

; 48   :         if (_Source == NULL || _DestinationSize < _SourceSize)

  00049	4d 85 c0	 test	 r8, r8
  0004c	74 22		 je	 SHORT $LN5@memcpy_s
  0004e	48 3b d3	 cmp	 rdx, rbx
  00051	72 1d		 jb	 SHORT $LN5@memcpy_s

; 57   :         }
; 58   : 
; 59   :         memcpy(_Destination, _Source, _SourceSize);

  00053	4c 8b c3	 mov	 r8, rbx
  00056	48 8b d6	 mov	 rdx, rsi
  00059	e8 00 00 00 00	 call	 memcpy
$LN10@memcpy_s:

; 60   :         return 0;

  0005e	33 c0		 xor	 eax, eax

; 61   :     }

  00060	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00065	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0006a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0006e	5f		 pop	 rdi
  0006f	c3		 ret	 0
$LN5@memcpy_s:

; 49   :         {
; 50   :             memset(_Destination, 0, _DestinationSize);

  00070	4c 8b c2	 mov	 r8, rdx
  00073	33 d2		 xor	 edx, edx
  00075	e8 00 00 00 00	 call	 memset

; 51   : 
; 52   :             _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Source != NULL,                 EINVAL);

  0007a	48 85 f6	 test	 rsi, rsi
  0007d	74 a3		 je	 SHORT $LN9@memcpy_s

; 53   :             _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_DestinationSize >= _SourceSize, ERANGE);

  0007f	48 3b fb	 cmp	 rdi, rbx
  00082	73 b0		 jae	 SHORT $LN7@memcpy_s
  00084	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0008a	c7 00 22 00 00
	00		 mov	 DWORD PTR [rax], 34	; 00000022H
  00090	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo

; 61   :     }

  00096	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0009b	b8 22 00 00 00	 mov	 eax, 34			; 00000022H
  000a0	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000a5	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a9	5f		 pop	 rdi
  000aa	c3		 ret	 0
memcpy_s ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\coschm\desktop\fall-2016\security\des\des\des\main.cpp
;	COMDAT ?__empty_global_delete@@YAXPEAX_K@Z
_TEXT	SEGMENT
__formal$ = 8
__formal$ = 16
?__empty_global_delete@@YAXPEAX_K@Z PROC		; __empty_global_delete, COMDAT

  00000	c2 00 00	 ret	 0
?__empty_global_delete@@YAXPEAX_K@Z ENDP		; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\users\coschm\desktop\fall-2016\security\des\des\des\main.cpp
;	COMDAT ?__empty_global_delete@@YAXPEAX@Z
_TEXT	SEGMENT
__formal$ = 8
?__empty_global_delete@@YAXPEAX@Z PROC			; __empty_global_delete, COMDAT

; 1306 : }

  00000	c2 00 00	 ret	 0
?__empty_global_delete@@YAXPEAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
